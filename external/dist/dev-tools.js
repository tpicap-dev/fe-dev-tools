this["dev-tools"] = (function () {
  'use strict';

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param argument - The value to convert
   *
   * @returns The parsed date in the local time zone
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */
  function toDate(argument) {
    const argStr = Object.prototype.toString.call(argument);

    // Clone the date
    if (
      argument instanceof Date ||
      (typeof argument === "object" && argStr === "[object Date]")
    ) {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new argument.constructor(+argument);
    } else if (
      typeof argument === "number" ||
      argStr === "[object Number]" ||
      typeof argument === "string" ||
      argStr === "[object String]"
    ) {
      // TODO: Can we get rid of as?
      return new Date(argument);
    } else {
      // TODO: Can we get rid of as?
      return new Date(NaN);
    }
  }

  /**
   * @name constructFrom
   * @category Generic Helpers
   * @summary Constructs a date using the reference date and the value
   *
   * @description
   * The function constructs a new date using the constructor from the reference
   * date and the given value. It helps to build generic functions that accept
   * date extensions.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The reference date to take constructor from
   * @param value - The value to create the date
   *
   * @returns Date initialized using the given date and value
   *
   * @example
   * import { constructFrom } from 'date-fns'
   *
   * // A function that clones a date preserving the original type
   * function cloneDate<DateType extends Date(date: DateType): DateType {
   *   return constructFrom(
   *     date, // Use contrustor from the given date
   *     date.getTime() // Use the date value to create a new date
   *   )
   * }
   */
  function constructFrom(date, value) {
    if (date instanceof Date) {
      return new date.constructor(value);
    } else {
      return new Date(value);
    }
  }

  /**
   * @name addDays
   * @category Day Helpers
   * @summary Add the specified number of days to the given date.
   *
   * @description
   * Add the specified number of days to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of days to be added.
   *
   * @returns The new date with the days added
   *
   * @example
   * // Add 10 days to 1 September 2014:
   * const result = addDays(new Date(2014, 8, 1), 10)
   * //=> Thu Sep 11 2014 00:00:00
   */
  function addDays(date, amount) {
    const _date = toDate(date);
    if (isNaN(amount)) return constructFrom(date, NaN);
    if (!amount) {
      // If 0 days, no-op to avoid changing times in the hour before end of DST
      return _date;
    }
    _date.setDate(_date.getDate() + amount);
    return _date;
  }

  /**
   * @name addMonths
   * @category Month Helpers
   * @summary Add the specified number of months to the given date.
   *
   * @description
   * Add the specified number of months to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of months to be added.
   *
   * @returns The new date with the months added
   *
   * @example
   * // Add 5 months to 1 September 2014:
   * const result = addMonths(new Date(2014, 8, 1), 5)
   * //=> Sun Feb 01 2015 00:00:00
   *
   * // Add one month to 30 January 2023:
   * const result = addMonths(new Date(2023, 0, 30), 1)
   * //=> Tue Feb 28 2023 00:00:00
   */
  function addMonths(date, amount) {
    const _date = toDate(date);
    if (isNaN(amount)) return constructFrom(date, NaN);
    if (!amount) {
      // If 0 months, no-op to avoid changing times in the hour before end of DST
      return _date;
    }
    const dayOfMonth = _date.getDate();

    // The JS Date object supports date math by accepting out-of-bounds values for
    // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
    // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
    // want except that dates will wrap around the end of a month, meaning that
    // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
    // we'll default to the end of the desired month by adding 1 to the desired
    // month and using a date of 0 to back up one day to the end of the desired
    // month.
    const endOfDesiredMonth = constructFrom(date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      // If we're already at the end of the month, then this is the correct date
      // and we're done.
      return endOfDesiredMonth;
    } else {
      // Otherwise, we now know that setting the original day-of-month value won't
      // cause an overflow, so set the desired day-of-month. Note that we can't
      // just set the date of `endOfDesiredMonth` because that object may have had
      // its time changed in the unusual case where where a DST transition was on
      // the last day of the month and its local time was in the hour skipped or
      // repeated next to a DST transition.  So we use `date` instead which is
      // guaranteed to still have the original time.
      _date.setFullYear(
        endOfDesiredMonth.getFullYear(),
        endOfDesiredMonth.getMonth(),
        dayOfMonth,
      );
      return _date;
    }
  }

  /**
   * @name add
   * @category Common Helpers
   * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
   *
   * @description
   * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
   *
   * | Key            | Description                        |
   * |----------------|------------------------------------|
   * | years          | Amount of years to be added        |
   * | months         | Amount of months to be added       |
   * | weeks          | Amount of weeks to be added        |
   * | days           | Amount of days to be added         |
   * | hours          | Amount of hours to be added        |
   * | minutes        | Amount of minutes to be added      |
   * | seconds        | Amount of seconds to be added      |
   *
   * All values default to 0
   *
   * @returns The new date with the seconds added
   *
   * @example
   * // Add the following duration to 1 September 2014, 10:19:50
   * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
   *   years: 2,
   *   months: 9,
   *   weeks: 1,
   *   days: 7,
   *   hours: 5,\\-7
   *   minutes: 9,
   *   seconds: 30,
   * })
   * //=> Thu Jun 15 2017 15:29:20
   */
  function add$2(date, duration) {
    const {
      years = 0,
      months = 0,
      weeks = 0,
      days = 0,
      hours = 0,
      minutes = 0,
      seconds = 0,
    } = duration;

    // Add years and months
    const _date = toDate(date);
    const dateWithMonths =
      months || years ? addMonths(_date, months + years * 12) : _date;

    // Add weeks and days
    const dateWithDays =
      days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;

    // Add days, hours, minutes and seconds
    const minutesToAdd = minutes + hours * 60;
    const secondsToAdd = seconds + minutesToAdd * 60;
    const msToAdd = secondsToAdd * 1000;
    const finalDate = constructFrom(date, dateWithDays.getTime() + msToAdd);

    return finalDate;
  }

  /**
   * @name isSaturday
   * @category Weekday Helpers
   * @summary Is the given date Saturday?
   *
   * @description
   * Is the given date Saturday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Saturday
   *
   * @example
   * // Is 27 September 2014 Saturday?
   * const result = isSaturday(new Date(2014, 8, 27))
   * //=> true
   */
  function isSaturday(date) {
    return toDate(date).getDay() === 6;
  }

  /**
   * @name isSunday
   * @category Weekday Helpers
   * @summary Is the given date Sunday?
   *
   * @description
   * Is the given date Sunday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Sunday
   *
   * @example
   * // Is 21 September 2014 Sunday?
   * const result = isSunday(new Date(2014, 8, 21))
   * //=> true
   */
  function isSunday(date) {
    return toDate(date).getDay() === 0;
  }

  /**
   * @name isWeekend
   * @category Weekday Helpers
   * @summary Does the given date fall on a weekend?
   *
   * @description
   * Does the given date fall on a weekend?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date falls on a weekend
   *
   * @example
   * // Does 5 October 2014 fall on a weekend?
   * const result = isWeekend(new Date(2014, 9, 5))
   * //=> true
   */
  function isWeekend(date) {
    const day = toDate(date).getDay();
    return day === 0 || day === 6;
  }

  /**
   * @name addBusinessDays
   * @category Date Extension Helpers
   * @summary Add the specified number of business days (mon - fri) to the given date.
   *
   * @description
   * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of business days to be added.
   *
   * @returns The new date with the business days added
   *
   * @example
   * // Add 10 business days to 1 September 2014:
   * const result = addBusinessDays(new Date(2014, 8, 1), 10)
   * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)
   */
  function addBusinessDays(date, amount) {
    const _date = toDate(date);
    const startedOnWeekend = isWeekend(_date);

    if (isNaN(amount)) return constructFrom(date, NaN);

    const hours = _date.getHours();
    const sign = amount < 0 ? -1 : 1;
    const fullWeeks = Math.trunc(amount / 5);

    _date.setDate(_date.getDate() + fullWeeks * 7);

    // Get remaining days not part of a full week
    let restDays = Math.abs(amount % 5);

    // Loops over remaining days
    while (restDays > 0) {
      _date.setDate(_date.getDate() + sign);
      if (!isWeekend(_date)) restDays -= 1;
    }

    // If the date is a weekend day and we reduce a dividable of
    // 5 from it, we land on a weekend date.
    // To counter this, we add days accordingly to land on the next business day
    if (startedOnWeekend && isWeekend(_date) && amount !== 0) {
      // If we're reducing days, we want to add days until we land on a weekday
      // If we're adding days we want to reduce days until we land on a weekday
      if (isSaturday(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));
      if (isSunday(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));
    }

    // Restore hours to avoid DST lag
    _date.setHours(hours);

    return _date;
  }

  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of milliseconds to be added.
   *
   * @returns The new date with the milliseconds added
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */
  function addMilliseconds(date, amount) {
    const timestamp = +toDate(date);
    return constructFrom(date, timestamp + amount);
  }

  /**
   * @module constants
   * @summary Useful constants
   * @description
   * Collection of useful date constants.
   *
   * The constants could be imported from `date-fns/constants`:
   *
   * ```ts
   * import { maxTime, minTime } from "./constants/date-fns/constants";
   *
   * function isAllowedTime(time) {
   *   return time <= maxTime && time >= minTime;
   * }
   * ```
   */

  /**
   * @constant
   * @name daysInWeek
   * @summary Days in 1 week.
   */
  const daysInWeek = 7;

  /**
   * @constant
   * @name daysInYear
   * @summary Days in 1 year.
   *
   * @description
   * How many days in a year.
   *
   * One years equals 365.2425 days according to the formula:
   *
   * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
   * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
   */
  const daysInYear = 365.2425;

  /**
   * @constant
   * @name millisecondsInWeek
   * @summary Milliseconds in 1 week.
   */
  const millisecondsInWeek = 604800000;

  /**
   * @constant
   * @name millisecondsInDay
   * @summary Milliseconds in 1 day.
   */
  const millisecondsInDay = 86400000;

  /**
   * @constant
   * @name millisecondsInMinute
   * @summary Milliseconds in 1 minute
   */
  const millisecondsInMinute = 60000;

  /**
   * @constant
   * @name millisecondsInHour
   * @summary Milliseconds in 1 hour
   */
  const millisecondsInHour = 3600000;

  /**
   * @constant
   * @name millisecondsInSecond
   * @summary Milliseconds in 1 second
   */
  const millisecondsInSecond = 1000;

  /**
   * @constant
   * @name minutesInYear
   * @summary Minutes in 1 year.
   */
  const minutesInYear = 525600;

  /**
   * @constant
   * @name minutesInMonth
   * @summary Minutes in 1 month.
   */
  const minutesInMonth = 43200;

  /**
   * @constant
   * @name minutesInDay
   * @summary Minutes in 1 day.
   */
  const minutesInDay = 1440;

  /**
   * @constant
   * @name minutesInHour
   * @summary Minutes in 1 hour.
   */
  const minutesInHour = 60;

  /**
   * @constant
   * @name monthsInQuarter
   * @summary Months in 1 quarter.
   */
  const monthsInQuarter = 3;

  /**
   * @constant
   * @name monthsInYear
   * @summary Months in 1 year.
   */
  const monthsInYear = 12;

  /**
   * @constant
   * @name quartersInYear
   * @summary Quarters in 1 year
   */
  const quartersInYear = 4;

  /**
   * @constant
   * @name secondsInHour
   * @summary Seconds in 1 hour.
   */
  const secondsInHour = 3600;

  /**
   * @constant
   * @name secondsInMinute
   * @summary Seconds in 1 minute.
   */
  const secondsInMinute = 60;

  /**
   * @constant
   * @name secondsInDay
   * @summary Seconds in 1 day.
   */
  const secondsInDay = secondsInHour * 24;

  /**
   * @constant
   * @name secondsInWeek
   * @summary Seconds in 1 week.
   */
  const secondsInWeek = secondsInDay * 7;

  /**
   * @constant
   * @name secondsInYear
   * @summary Seconds in 1 year.
   */
  const secondsInYear = secondsInDay * daysInYear;

  /**
   * @constant
   * @name secondsInMonth
   * @summary Seconds in 1 month
   */
  const secondsInMonth = secondsInYear / 12;

  /**
   * @constant
   * @name secondsInQuarter
   * @summary Seconds in 1 quarter.
   */
  const secondsInQuarter = secondsInMonth * 3;

  /**
   * @name addHours
   * @category Hour Helpers
   * @summary Add the specified number of hours to the given date.
   *
   * @description
   * Add the specified number of hours to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of hours to be added.
   *
   * @returns The new date with the hours added
   *
   * @example
   * // Add 2 hours to 10 July 2014 23:00:00:
   * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
   * //=> Fri Jul 11 2014 01:00:00
   */
  function addHours(date, amount) {
    return addMilliseconds(date, amount * millisecondsInHour);
  }

  let defaultOptions = {};

  function getDefaultOptions$1() {
    return defaultOptions;
  }

  function setDefaultOptions$1(newOptions) {
    defaultOptions = newOptions;
  }

  /**
   * The {@link startOfWeek} function options.
   */

  /**
   * @name startOfWeek
   * @category Week Helpers
   * @summary Return the start of a week for the given date.
   *
   * @description
   * Return the start of a week for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options
   *
   * @returns The start of a week
   *
   * @example
   * // The start of a week for 2 September 2014 11:55:00:
   * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Sun Aug 31 2014 00:00:00
   *
   * @example
   * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
   * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
   * //=> Mon Sep 01 2014 00:00:00
   */
  function startOfWeek(date, options) {
    const defaultOptions = getDefaultOptions$1();
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const _date = toDate(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * @name startOfISOWeek
   * @category ISO Week Helpers
   * @summary Return the start of an ISO week for the given date.
   *
   * @description
   * Return the start of an ISO week for the given date.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of an ISO week
   *
   * @example
   * // The start of an ISO week for 2 September 2014 11:55:00:
   * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Mon Sep 01 2014 00:00:00
   */
  function startOfISOWeek(date) {
    return startOfWeek(date, { weekStartsOn: 1 });
  }

  /**
   * @name getISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Get the ISO week-numbering year of the given date.
   *
   * @description
   * Get the ISO week-numbering year of the given date,
   * which always starts 3 days before the year's first Thursday.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The ISO week-numbering year
   *
   * @example
   * // Which ISO-week numbering year is 2 January 2005?
   * const result = getISOWeekYear(new Date(2005, 0, 2))
   * //=> 2004
   */
  function getISOWeekYear(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();

    const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);

    const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);

    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  /**
   * @name startOfDay
   * @category Day Helpers
   * @summary Return the start of a day for the given date.
   *
   * @description
   * Return the start of a day for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a day
   *
   * @example
   * // The start of a day for 2 September 2014 11:55:00:
   * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 02 2014 00:00:00
   */
  function startOfDay(date) {
    const _date = toDate(date);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */
  function getTimezoneOffsetInMilliseconds(date) {
    const utcDate = new Date(
      Date.UTC(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds(),
        date.getMilliseconds(),
      ),
    );
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
  }

  /**
   * @name differenceInCalendarDays
   * @category Day Helpers
   * @summary Get the number of calendar days between the given dates.
   *
   * @description
   * Get the number of calendar days between the given dates. This means that the times are removed
   * from the dates and then the difference in days is calculated.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of calendar days
   *
   * @example
   * // How many calendar days are between
   * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
   * const result = differenceInCalendarDays(
   *   new Date(2012, 6, 2, 0, 0),
   *   new Date(2011, 6, 2, 23, 0)
   * )
   * //=> 366
   * // How many calendar days are between
   * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
   * const result = differenceInCalendarDays(
   *   new Date(2011, 6, 3, 0, 1),
   *   new Date(2011, 6, 2, 23, 59)
   * )
   * //=> 1
   */
  function differenceInCalendarDays(dateLeft, dateRight) {
    const startOfDayLeft = startOfDay(dateLeft);
    const startOfDayRight = startOfDay(dateRight);

    const timestampLeft =
      startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
    const timestampRight =
      startOfDayRight.getTime() -
      getTimezoneOffsetInMilliseconds(startOfDayRight);

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a day is not constant
    // (e.g. it's different in the day of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
  }

  /**
   * @name startOfISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Return the start of an ISO week-numbering year for the given date.
   *
   * @description
   * Return the start of an ISO week-numbering year,
   * which always starts 3 days before the year's first Thursday.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of an ISO week-numbering year
   *
   * @example
   * // The start of an ISO week-numbering year for 2 July 2005:
   * const result = startOfISOWeekYear(new Date(2005, 6, 2))
   * //=> Mon Jan 03 2005 00:00:00
   */
  function startOfISOWeekYear(date) {
    const year = getISOWeekYear(date);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }

  /**
   * @name setISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Set the ISO week-numbering year to the given date.
   *
   * @description
   * Set the ISO week-numbering year to the given date,
   * saving the week number and the weekday number.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param weekYear - The ISO week-numbering year of the new date
   *
   * @returns The new date with the ISO week-numbering year set
   *
   * @example
   * // Set ISO week-numbering year 2007 to 29 December 2008:
   * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
   * //=> Mon Jan 01 2007 00:00:00
   */
  function setISOWeekYear(date, weekYear) {
    let _date = toDate(date);
    const diff = differenceInCalendarDays(_date, startOfISOWeekYear(_date));
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(weekYear, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    _date = startOfISOWeekYear(fourthOfJanuary);
    _date.setDate(_date.getDate() + diff);
    return _date;
  }

  /**
   * @name addISOWeekYears
   * @category ISO Week-Numbering Year Helpers
   * @summary Add the specified number of ISO week-numbering years to the given date.
   *
   * @description
   * Add the specified number of ISO week-numbering years to the given date.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of ISO week-numbering years to be added.
   *
   * @returns The new date with the ISO week-numbering years added
   *
   * @example
   * // Add 5 ISO week-numbering years to 2 July 2010:
   * const result = addISOWeekYears(new Date(2010, 6, 2), 5)
   * //=> Fri Jn 26 2015 00:00:00
   */
  function addISOWeekYears(date, amount) {
    return setISOWeekYear(date, getISOWeekYear(date) + amount);
  }

  /**
   * @name addMinutes
   * @category Minute Helpers
   * @summary Add the specified number of minutes to the given date.
   *
   * @description
   * Add the specified number of minutes to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of minutes to be added.
   *
   * @returns The new date with the minutes added
   *
   * @example
   * // Add 30 minutes to 10 July 2014 12:00:00:
   * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 12:30:00
   */
  function addMinutes(date, amount) {
    return addMilliseconds(date, amount * millisecondsInMinute);
  }

  /**
   * @name addQuarters
   * @category Quarter Helpers
   * @summary Add the specified number of year quarters to the given date.
   *
   * @description
   * Add the specified number of year quarters to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of quarters to be added.
   *
   * @returns The new date with the quarters added
   *
   * @example
   * // Add 1 quarter to 1 September 2014:
   * const result = addQuarters(new Date(2014, 8, 1), 1)
   * //=> Mon Dec 01 2014 00:00:00
   */
  function addQuarters(date, amount) {
    const months = amount * 3;
    return addMonths(date, months);
  }

  /**
   * @name addSeconds
   * @category Second Helpers
   * @summary Add the specified number of seconds to the given date.
   *
   * @description
   * Add the specified number of seconds to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of seconds to be added.
   *
   * @returns The new date with the seconds added
   *
   * @example
   * // Add 30 seconds to 10 July 2014 12:45:00:
   * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
   * //=> Thu Jul 10 2014 12:45:30
   */
  function addSeconds(date, amount) {
    return addMilliseconds(date, amount * 1000);
  }

  /**
   * @name addWeeks
   * @category Week Helpers
   * @summary Add the specified number of weeks to the given date.
   *
   * @description
   * Add the specified number of week to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of weeks to be added.
   *
   * @returns The new date with the weeks added
   *
   * @example
   * // Add 4 weeks to 1 September 2014:
   * const result = addWeeks(new Date(2014, 8, 1), 4)
   * //=> Mon Sep 29 2014 00:00:00
   */
  function addWeeks(date, amount) {
    const days = amount * 7;
    return addDays(date, days);
  }

  /**
   * @name addYears
   * @category Year Helpers
   * @summary Add the specified number of years to the given date.
   *
   * @description
   * Add the specified number of years to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of years to be added.
   *
   * @returns The new date with the years added
   *
   * @example
   * // Add 5 years to 1 September 2014:
   * const result = addYears(new Date(2014, 8, 1), 5)
   * //=> Sun Sep 01 2019 00:00:00
   */
  function addYears(date, amount) {
    return addMonths(date, amount * 12);
  }

  /**
   * The {@link areIntervalsOverlapping} function options.
   */

  /**
   * @name areIntervalsOverlapping
   * @category Interval Helpers
   * @summary Is the given time interval overlapping with another time interval?
   *
   * @description
   * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.
   *
   * @param intervalLeft - The first interval to compare.
   * @param intervalRight - The second interval to compare.
   * @param options - The object with options
   *
   * @returns Whether the time intervals are overlapping
   *
   * @example
   * // For overlapping time intervals:
   * areIntervalsOverlapping(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
   * )
   * //=> true
   *
   * @example
   * // For non-overlapping time intervals:
   * areIntervalsOverlapping(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
   * )
   * //=> false
   *
   * @example
   * // For adjacent time intervals:
   * areIntervalsOverlapping(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }
   * )
   * //=> false
   *
   * @example
   * // Using the inclusive option:
   * areIntervalsOverlapping(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }
   * )
   * //=> false
   *
   * @example
   * areIntervalsOverlapping(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },
   *   { inclusive: true }
   * )
   * //=> true
   */
  function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
    const [leftStartTime, leftEndTime] = [
      +toDate(intervalLeft.start),
      +toDate(intervalLeft.end),
    ].sort((a, b) => a - b);
    const [rightStartTime, rightEndTime] = [
      +toDate(intervalRight.start),
      +toDate(intervalRight.end),
    ].sort((a, b) => a - b);

    if (options?.inclusive)
      return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;

    return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  }

  /**
   * @name max
   * @category Common Helpers
   * @summary Return the latest of the given dates.
   *
   * @description
   * Return the latest of the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dates - The dates to compare
   *
   * @returns The latest of the dates
   *
   * @example
   * // Which of these dates is the latest?
   * const result = max([
   *   new Date(1989, 6, 10),
   *   new Date(1987, 1, 11),
   *   new Date(1995, 6, 2),
   *   new Date(1990, 0, 1)
   * ])
   * //=> Sun Jul 02 1995 00:00:00
   */
  function max$2(dates) {
    let result;
    dates.forEach(function (dirtyDate) {
      const currentDate = toDate(dirtyDate);

      if (
        result === undefined ||
        result < currentDate ||
        isNaN(Number(currentDate))
      ) {
        result = currentDate;
      }
    });

    return result || new Date(NaN);
  }

  /**
   * @name min
   * @category Common Helpers
   * @summary Returns the earliest of the given dates.
   *
   * @description
   * Returns the earliest of the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dates - The dates to compare
   *
   * @returns The earliest of the dates
   *
   * @example
   * // Which of these dates is the earliest?
   * const result = min([
   *   new Date(1989, 6, 10),
   *   new Date(1987, 1, 11),
   *   new Date(1995, 6, 2),
   *   new Date(1990, 0, 1)
   * ])
   * //=> Wed Feb 11 1987 00:00:00
   */
  function min$2(dates) {
    let result;

    dates.forEach((dirtyDate) => {
      const date = toDate(dirtyDate);
      if (!result || result > date || isNaN(+date)) {
        result = date;
      }
    });

    return result || new Date(NaN);
  }

  /**
   * @name clamp
   * @category Interval Helpers
   * @summary Return a date bounded by the start and the end of the given interval
   *
   * @description
   * Clamps a date to the lower bound with the start of the interval and the upper
   * bound with the end of the interval.
   *
   * - When the date is less than the start of the interval, the start is returned.
   * - When the date is greater than the end of the interval, the end is returned.
   * - Otherwise the date is returned.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be bounded
   * @param interval - The interval to bound to
   *
   * @returns The date bounded by the start and the end of the interval
   *
   * @example
   * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021
   * const result = clamp(new Date(2021, 2, 21), {
   *   start: new Date(2021, 2, 22),
   *   end: new Date(2021, 3, 1),
   * })
   * //=> Mon Mar 22 2021 00:00:00
   */
  function clamp$2(date, interval) {
    return min$2([max$2([date, interval.start]), interval.end]);
  }

  /**
   * @name closestIndexTo
   * @category Common Helpers
   * @summary Return an index of the closest date from the array comparing to the given date.
   *
   * @description
   * Return an index of the closest date from the array comparing to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateToCompare - The date to compare with
   * @param dates - The array to search
   *
   * @returns An index of the date closest to the given date or undefined if no valid value is given
   *
   * @example
   * // Which date is closer to 6 September 2015?
   * const dateToCompare = new Date(2015, 8, 6)
   * const datesArray = [
   *   new Date(2015, 0, 1),
   *   new Date(2016, 0, 1),
   *   new Date(2017, 0, 1)
   * ]
   * const result = closestIndexTo(dateToCompare, datesArray)
   * //=> 1
   */
  function closestIndexTo(dateToCompare, dates) {
    const date = toDate(dateToCompare);

    if (isNaN(Number(date))) return NaN;

    const timeToCompare = date.getTime();

    let result;
    let minDistance;
    dates.forEach(function (dirtyDate, index) {
      const currentDate = toDate(dirtyDate);

      if (isNaN(Number(currentDate))) {
        result = NaN;
        minDistance = NaN;
        return;
      }

      const distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < minDistance) {
        result = index;
        minDistance = distance;
      }
    });

    return result;
  }

  /**
   * @name closestTo
   * @category Common Helpers
   * @summary Return a date from the array closest to the given date.
   *
   * @description
   * Return a date from the array closest to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateToCompare - The date to compare with
   * @param dates - The array to search
   *
   * @returns The date from the array closest to the given date or undefined if no valid value is given
   *
   * @example
   * // Which date is closer to 6 September 2015: 1 January 2000 or 1 January 2030?
   * const dateToCompare = new Date(2015, 8, 6)
   * const result = closestTo(dateToCompare, [
   *   new Date(2000, 0, 1),
   *   new Date(2030, 0, 1)
   * ])
   * //=> Tue Jan 01 2030 00:00:00
   */
  function closestTo(dateToCompare, dates) {
    const date = toDate(dateToCompare);

    if (isNaN(Number(date))) return constructFrom(dateToCompare, NaN);

    const timeToCompare = date.getTime();

    let result;
    let minDistance;
    dates.forEach((dirtyDate) => {
      const currentDate = toDate(dirtyDate);

      if (isNaN(Number(currentDate))) {
        result = constructFrom(dateToCompare, NaN);
        minDistance = NaN;
        return;
      }

      const distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < minDistance) {
        result = currentDate;
        minDistance = distance;
      }
    });

    return result;
  }

  /**
   * @name compareAsc
   * @category Common Helpers
   * @summary Compare the two dates and return -1, 0 or 1.
   *
   * @description
   * Compare the two dates and return 1 if the first date is after the second,
   * -1 if the first date is before the second or 0 if dates are equal.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to compare
   * @param dateRight - The second date to compare
   *
   * @returns The result of the comparison
   *
   * @example
   * // Compare 11 February 1987 and 10 July 1989:
   * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
   * //=> -1
   *
   * @example
   * // Sort the array of dates:
   * const result = [
   *   new Date(1995, 6, 2),
   *   new Date(1987, 1, 11),
   *   new Date(1989, 6, 10)
   * ].sort(compareAsc)
   * //=> [
   * //   Wed Feb 11 1987 00:00:00,
   * //   Mon Jul 10 1989 00:00:00,
   * //   Sun Jul 02 1995 00:00:00
   * // ]
   */
  function compareAsc(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const diff = _dateLeft.getTime() - _dateRight.getTime();

    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
      // Return 0 if diff is 0; return NaN if diff is NaN
    } else {
      return diff;
    }
  }

  /**
   * @name compareDesc
   * @category Common Helpers
   * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
   *
   * @description
   * Compare the two dates and return -1 if the first date is after the second,
   * 1 if the first date is before the second or 0 if dates are equal.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to compare
   * @param dateRight - The second date to compare
   *
   * @returns The result of the comparison
   *
   * @example
   * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
   * const result = compareDesc(new Date(1987, 1, 11), new Date(1989, 6, 10))
   * //=> 1
   *
   * @example
   * // Sort the array of dates in reverse chronological order:
   * const result = [
   *   new Date(1995, 6, 2),
   *   new Date(1987, 1, 11),
   *   new Date(1989, 6, 10)
   * ].sort(compareDesc)
   * //=> [
   * //   Sun Jul 02 1995 00:00:00,
   * //   Mon Jul 10 1989 00:00:00,
   * //   Wed Feb 11 1987 00:00:00
   * // ]
   */
  function compareDesc(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const diff = _dateLeft.getTime() - _dateRight.getTime();

    if (diff > 0) {
      return -1;
    } else if (diff < 0) {
      return 1;
      // Return 0 if diff is 0; return NaN if diff is NaN
    } else {
      return diff;
    }
  }

  /**
   * @name daysToWeeks
   * @category Conversion Helpers
   * @summary Convert days to weeks.
   *
   * @description
   * Convert a number of days to a full number of weeks.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param days - The number of days to be converted
   *
   * @returns The number of days converted in weeks
   *
   * @example
   * // Convert 14 days to weeks:
   * const result = daysToWeeks(14)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = daysToWeeks(13)
   * //=> 1
   */
  function daysToWeeks(days) {
    const weeks = days / daysInWeek;
    return Math.floor(weeks);
  }

  /**
   * @name isSameDay
   * @category Day Helpers
   * @summary Are the given dates in the same day (and year and month)?
   *
   * @description
   * Are the given dates in the same day (and year and month)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check

   * @returns The dates are in the same day (and year and month)
   *
   * @example
   * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
   * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
   * //=> true
   *
   * @example
   * // Are 4 September and 4 October in the same day?
   * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
   * //=> false
   *
   * @example
   * // Are 4 September, 2014 and 4 September, 2015 in the same day?
   * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
   * //=> false
   */
  function isSameDay(dateLeft, dateRight) {
    const dateLeftStartOfDay = startOfDay(dateLeft);
    const dateRightStartOfDay = startOfDay(dateRight);

    return +dateLeftStartOfDay === +dateRightStartOfDay;
  }

  /**
   * @name isDate
   * @category Common Helpers
   * @summary Is the given value a date?
   *
   * @description
   * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
   *
   * @param value - The value to check
   *
   * @returns True if the given value is a date
   *
   * @example
   * // For a valid date:
   * const result = isDate(new Date())
   * //=> true
   *
   * @example
   * // For an invalid date:
   * const result = isDate(new Date(NaN))
   * //=> true
   *
   * @example
   * // For some value:
   * const result = isDate('2014-02-31')
   * //=> false
   *
   * @example
   * // For an object:
   * const result = isDate({})
   * //=> false
   */
  function isDate(value) {
    return (
      value instanceof Date ||
      (typeof value === "object" &&
        Object.prototype.toString.call(value) === "[object Date]")
    );
  }

  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is valid
   *
   * @example
   * // For the valid date:
   * const result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * const result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * const result = isValid(new Date(''))
   * //=> false
   */
  function isValid(date) {
    if (!isDate(date) && typeof date !== "number") {
      return false;
    }
    const _date = toDate(date);
    return !isNaN(Number(_date));
  }

  /**
   * @name differenceInBusinessDays
   * @category Day Helpers
   * @summary Get the number of business days between the given dates.
   *
   * @description
   * Get the number of business day periods between the given dates.
   * Business days being days that arent in the weekend.
   * Like `differenceInCalendarDays`, the function removes the times from
   * the dates before calculating the difference.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of business days
   *
   * @example
   * // How many business days are between
   * // 10 January 2014 and 20 July 2014?
   * const result = differenceInBusinessDays(
   *   new Date(2014, 6, 20),
   *   new Date(2014, 0, 10)
   * )
   * //=> 136
   *
   * // How many business days are between
   * // 30 November 2021 and 1 November 2021?
   * const result = differenceInBusinessDays(
   *   new Date(2021, 10, 30),
   *   new Date(2021, 10, 1)
   * )
   * //=> 21
   *
   * // How many business days are between
   * // 1 November 2021 and 1 December 2021?
   * const result = differenceInBusinessDays(
   *   new Date(2021, 10, 1),
   *   new Date(2021, 11, 1)
   * )
   * //=> -22
   *
   * // How many business days are between
   * // 1 November 2021 and 1 November 2021 ?
   * const result = differenceInBusinessDays(
   *   new Date(2021, 10, 1),
   *   new Date(2021, 10, 1)
   * )
   * //=> 0
   */
  function differenceInBusinessDays(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    let _dateRight = toDate(dateRight);

    if (!isValid(_dateLeft) || !isValid(_dateRight)) return NaN;

    const calendarDifference = differenceInCalendarDays(_dateLeft, _dateRight);
    const sign = calendarDifference < 0 ? -1 : 1;

    const weeks = Math.trunc(calendarDifference / 7);

    let result = weeks * 5;
    _dateRight = addDays(_dateRight, weeks * 7);

    // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week
    while (!isSameDay(_dateLeft, _dateRight)) {
      // sign is used to account for both negative and positive differences
      result += isWeekend(_dateRight) ? 0 : sign;
      _dateRight = addDays(_dateRight, sign);
    }

    // Prevent negative zero
    return result === 0 ? 0 : result;
  }

  /**
   * @name differenceInCalendarISOWeekYears
   * @category ISO Week-Numbering Year Helpers
   * @summary Get the number of calendar ISO week-numbering years between the given dates.
   *
   * @description
   * Get the number of calendar ISO week-numbering years between the given dates.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of calendar ISO week-numbering years
   *
   * @example
   * // How many calendar ISO week-numbering years are 1 January 2010 and 1 January 2012?
   * const result = differenceInCalendarISOWeekYears(
   *   new Date(2012, 0, 1),
   *   new Date(2010, 0, 1)
   * )
   * //=> 2
   */
  function differenceInCalendarISOWeekYears(dateLeft, dateRight) {
    return getISOWeekYear(dateLeft) - getISOWeekYear(dateRight);
  }

  /**
   * @name differenceInCalendarISOWeeks
   * @category ISO Week Helpers
   * @summary Get the number of calendar ISO weeks between the given dates.
   *
   * @description
   * Get the number of calendar ISO weeks between the given dates.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of calendar ISO weeks
   *
   * @example
   * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?
   * const result = differenceInCalendarISOWeeks(
   *   new Date(2014, 6, 21),
   *   new Date(2014, 6, 6)
   * )
   * //=> 3
   */
  function differenceInCalendarISOWeeks(dateLeft, dateRight) {
    const startOfISOWeekLeft = startOfISOWeek(dateLeft);
    const startOfISOWeekRight = startOfISOWeek(dateRight);

    const timestampLeft =
      startOfISOWeekLeft.getTime() -
      getTimezoneOffsetInMilliseconds(startOfISOWeekLeft);
    const timestampRight =
      startOfISOWeekRight.getTime() -
      getTimezoneOffsetInMilliseconds(startOfISOWeekRight);

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);
  }

  /**
   * @name differenceInCalendarMonths
   * @category Month Helpers
   * @summary Get the number of calendar months between the given dates.
   *
   * @description
   * Get the number of calendar months between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of calendar months
   *
   * @example
   * // How many calendar months are between 31 January 2014 and 1 September 2014?
   * const result = differenceInCalendarMonths(
   *   new Date(2014, 8, 1),
   *   new Date(2014, 0, 31)
   * )
   * //=> 8
   */
  function differenceInCalendarMonths(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
    const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();

    return yearDiff * 12 + monthDiff;
  }

  /**
   * @name getQuarter
   * @category Quarter Helpers
   * @summary Get the year quarter of the given date.
   *
   * @description
   * Get the year quarter of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The quarter
   *
   * @example
   * // Which quarter is 2 July 2014?
   * const result = getQuarter(new Date(2014, 6, 2))
   * //=> 3
   */
  function getQuarter(date) {
    const _date = toDate(date);
    const quarter = Math.floor(_date.getMonth() / 3) + 1;
    return quarter;
  }

  /**
   * @name differenceInCalendarQuarters
   * @category Quarter Helpers
   * @summary Get the number of calendar quarters between the given dates.
   *
   * @description
   * Get the number of calendar quarters between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date

   * @returns The number of calendar quarters
   *
   * @example
   * // How many calendar quarters are between 31 December 2013 and 2 July 2014?
   * const result = differenceInCalendarQuarters(
   *   new Date(2014, 6, 2),
   *   new Date(2013, 11, 31)
   * )
   * //=> 3
   */
  function differenceInCalendarQuarters(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
    const quarterDiff = getQuarter(_dateLeft) - getQuarter(_dateRight);

    return yearDiff * 4 + quarterDiff;
  }

  /**
   * The {@link differenceInCalendarWeeks} function options.
   */

  /**
   * @name differenceInCalendarWeeks
   * @category Week Helpers
   * @summary Get the number of calendar weeks between the given dates.
   *
   * @description
   * Get the number of calendar weeks between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options.
   *
   * @returns The number of calendar weeks
   *
   * @example
   * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
   * const result = differenceInCalendarWeeks(
   *   new Date(2014, 6, 20),
   *   new Date(2014, 6, 5)
   * )
   * //=> 3
   *
   * @example
   * // If the week starts on Monday,
   * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
   * const result = differenceInCalendarWeeks(
   *   new Date(2014, 6, 20),
   *   new Date(2014, 6, 5),
   *   { weekStartsOn: 1 }
   * )
   * //=> 2
   */
  function differenceInCalendarWeeks(dateLeft, dateRight, options) {
    const startOfWeekLeft = startOfWeek(dateLeft, options);
    const startOfWeekRight = startOfWeek(dateRight, options);

    const timestampLeft =
      startOfWeekLeft.getTime() -
      getTimezoneOffsetInMilliseconds(startOfWeekLeft);
    const timestampRight =
      startOfWeekRight.getTime() -
      getTimezoneOffsetInMilliseconds(startOfWeekRight);

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / millisecondsInWeek);
  }

  /**
   * @name differenceInCalendarYears
   * @category Year Helpers
   * @summary Get the number of calendar years between the given dates.
   *
   * @description
   * Get the number of calendar years between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date

   * @returns The number of calendar years
   *
   * @example
   * // How many calendar years are between 31 December 2013 and 11 February 2015?
   * const result = differenceInCalendarYears(
   *   new Date(2015, 1, 11),
   *   new Date(2013, 11, 31)
   * )
   * //=> 2
   */
  function differenceInCalendarYears(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    return _dateLeft.getFullYear() - _dateRight.getFullYear();
  }

  /**
   * @name differenceInDays
   * @category Day Helpers
   * @summary Get the number of full days between the given dates.
   *
   * @description
   * Get the number of full day periods between two dates. Fractional days are
   * truncated towards zero.
   *
   * One "full day" is the distance between a local time in one day to the same
   * local time on the next or previous day. A full day can sometimes be less than
   * or more than 24 hours if a daylight savings change happens between two dates.
   *
   * To ignore DST and only measure exact 24-hour periods, use this instead:
   * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of full days according to the local timezone
   *
   * @example
   * // How many full days are between
   * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
   * const result = differenceInDays(
   *   new Date(2012, 6, 2, 0, 0),
   *   new Date(2011, 6, 2, 23, 0)
   * )
   * //=> 365
   *
   * @example
   * // How many full days are between
   * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
   * const result = differenceInDays(
   *   new Date(2011, 6, 3, 0, 1),
   *   new Date(2011, 6, 2, 23, 59)
   * )
   * //=> 0
   *
   * @example
   * // How many full days are between
   * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
   * // Note: because local time is used, the
   * // result will always be 92 days, even in
   * // time zones where DST starts and the
   * // period has only 92*24-1 hours.
   * const result = differenceInDays(
   *   new Date(2020, 5, 1),
   *   new Date(2020, 2, 1)
   * )
   * //=> 92
   */
  function differenceInDays(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const sign = compareLocalAsc(_dateLeft, _dateRight);
    const difference = Math.abs(differenceInCalendarDays(_dateLeft, _dateRight));

    _dateLeft.setDate(_dateLeft.getDate() - sign * difference);

    // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastDayNotFull = Number(
      compareLocalAsc(_dateLeft, _dateRight) === -sign,
    );
    const result = sign * (difference - isLastDayNotFull);
    // Prevent negative zero
    return result === 0 ? 0 : result;
  }

  // Like `compareAsc` but uses local time not UTC, which is needed
  // for accurate equality comparisons of UTC timestamps that end up
  // having the same representation in local time, e.g. one hour before
  // DST ends vs. the instant that DST ends.
  function compareLocalAsc(dateLeft, dateRight) {
    const diff =
      dateLeft.getFullYear() - dateRight.getFullYear() ||
      dateLeft.getMonth() - dateRight.getMonth() ||
      dateLeft.getDate() - dateRight.getDate() ||
      dateLeft.getHours() - dateRight.getHours() ||
      dateLeft.getMinutes() - dateRight.getMinutes() ||
      dateLeft.getSeconds() - dateRight.getSeconds() ||
      dateLeft.getMilliseconds() - dateRight.getMilliseconds();

    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
      // Return 0 if diff is 0; return NaN if diff is NaN
    } else {
      return diff;
    }
  }

  function getRoundingMethod(method) {
    return method ? Math[method] : Math.trunc;
  }

  /**
   * @name differenceInMilliseconds
   * @category Millisecond Helpers
   * @summary Get the number of milliseconds between the given dates.
   *
   * @description
   * Get the number of milliseconds between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of milliseconds
   *
   * @example
   * // How many milliseconds are between
   * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
   * const result = differenceInMilliseconds(
   *   new Date(2014, 6, 2, 12, 30, 21, 700),
   *   new Date(2014, 6, 2, 12, 30, 20, 600)
   * )
   * //=> 1100
   */
  function differenceInMilliseconds(dateLeft, dateRight) {
    return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
  }

  /**
   * The {@link differenceInHours} function options.
   */

  /**
   * @name differenceInHours
   * @category Hour Helpers
   * @summary Get the number of hours between the given dates.
   *
   * @description
   * Get the number of hours between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options.
   *
   * @returns The number of hours
   *
   * @example
   * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
   * const result = differenceInHours(
   *   new Date(2014, 6, 2, 19, 0),
   *   new Date(2014, 6, 2, 6, 50)
   * )
   * //=> 12
   */
  function differenceInHours(dateLeft, dateRight, options) {
    const diff =
      differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
    return getRoundingMethod(options?.roundingMethod)(diff);
  }

  /**
   * @name subISOWeekYears
   * @category ISO Week-Numbering Year Helpers
   * @summary Subtract the specified number of ISO week-numbering years from the given date.
   *
   * @description
   * Subtract the specified number of ISO week-numbering years from the given date.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of ISO week-numbering years to be subtracted.
   *
   * @returns The new date with the ISO week-numbering years subtracted
   *
   * @example
   * // Subtract 5 ISO week-numbering years from 1 September 2014:
   * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
   * //=> Mon Aug 31 2009 00:00:00
   */
  function subISOWeekYears(date, amount) {
    return addISOWeekYears(date, -amount);
  }

  /**
   * @name differenceInISOWeekYears
   * @category ISO Week-Numbering Year Helpers
   * @summary Get the number of full ISO week-numbering years between the given dates.
   *
   * @description
   * Get the number of full ISO week-numbering years between the given dates.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of full ISO week-numbering years
   *
   * @example
   * // How many full ISO week-numbering years are between 1 January 2010 and 1 January 2012?
   * const result = differenceInISOWeekYears(
   *   new Date(2012, 0, 1),
   *   new Date(2010, 0, 1)
   * )
   * //=> 1
   */
  function differenceInISOWeekYears(dateLeft, dateRight) {
    let _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const sign = compareAsc(_dateLeft, _dateRight);
    const difference = Math.abs(
      differenceInCalendarISOWeekYears(_dateLeft, _dateRight),
    );
    _dateLeft = subISOWeekYears(_dateLeft, sign * difference);

    // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1
    // if last calendar ISO year is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastISOWeekYearNotFull = Number(
      compareAsc(_dateLeft, _dateRight) === -sign,
    );
    const result = sign * (difference - isLastISOWeekYearNotFull);
    // Prevent negative zero
    return result === 0 ? 0 : result;
  }

  /**
   * The {@link differenceInMinutes} function options.
   */

  /**
   * @name differenceInMinutes
   * @category Minute Helpers
   * @summary Get the number of minutes between the given dates.
   *
   * @description
   * Get the signed number of full (rounded towards 0) minutes between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options.
   *
   * @returns The number of minutes
   *
   * @example
   * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
   * const result = differenceInMinutes(
   *   new Date(2014, 6, 2, 12, 20, 0),
   *   new Date(2014, 6, 2, 12, 7, 59)
   * )
   * //=> 12
   *
   * @example
   * // How many minutes are between 10:01:59 and 10:00:00
   * const result = differenceInMinutes(
   *   new Date(2000, 0, 1, 10, 0, 0),
   *   new Date(2000, 0, 1, 10, 1, 59)
   * )
   * //=> -1
   */
  function differenceInMinutes(dateLeft, dateRight, options) {
    const diff =
      differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
    return getRoundingMethod(options?.roundingMethod)(diff);
  }

  /**
   * @name endOfDay
   * @category Day Helpers
   * @summary Return the end of a day for the given date.
   *
   * @description
   * Return the end of a day for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a day
   *
   * @example
   * // The end of a day for 2 September 2014 11:55:00:
   * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 02 2014 23:59:59.999
   */
  function endOfDay(date) {
    const _date = toDate(date);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name endOfMonth
   * @category Month Helpers
   * @summary Return the end of a month for the given date.
   *
   * @description
   * Return the end of a month for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a month
   *
   * @example
   * // The end of a month for 2 September 2014 11:55:00:
   * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 30 2014 23:59:59.999
   */
  function endOfMonth(date) {
    const _date = toDate(date);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name isLastDayOfMonth
   * @category Month Helpers
   * @summary Is the given date the last day of a month?
   *
   * @description
   * Is the given date the last day of a month?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check

   * @returns The date is the last day of a month
   *
   * @example
   * // Is 28 February 2014 the last day of a month?
   * const result = isLastDayOfMonth(new Date(2014, 1, 28))
   * //=> true
   */
  function isLastDayOfMonth(date) {
    const _date = toDate(date);
    return +endOfDay(_date) === +endOfMonth(_date);
  }

  /**
   * @name differenceInMonths
   * @category Month Helpers
   * @summary Get the number of full months between the given dates.
   *
   * @description
   * Get the number of full months between the given dates using trunc as a default rounding method.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of full months
   *
   * @example
   * // How many full months are between 31 January 2014 and 1 September 2014?
   * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
   * //=> 7
   */
  function differenceInMonths(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const sign = compareAsc(_dateLeft, _dateRight);
    const difference = Math.abs(
      differenceInCalendarMonths(_dateLeft, _dateRight),
    );
    let result;

    // Check for the difference of less than month
    if (difference < 1) {
      result = 0;
    } else {
      if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
        // This will check if the date is end of Feb and assign a higher end of month date
        // to compare it with Jan
        _dateLeft.setDate(30);
      }

      _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);

      // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
      // If so, result must be decreased by 1 in absolute value
      let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;

      // Check for cases of one full calendar month
      if (
        isLastDayOfMonth(toDate(dateLeft)) &&
        difference === 1 &&
        compareAsc(dateLeft, _dateRight) === 1
      ) {
        isLastMonthNotFull = false;
      }

      result = sign * (difference - Number(isLastMonthNotFull));
    }

    // Prevent negative zero
    return result === 0 ? 0 : result;
  }

  /**
   * The {@link differenceInQuarters} function options.
   */

  /**
   * @name differenceInQuarters
   * @category Quarter Helpers
   * @summary Get the number of quarters between the given dates.
   *
   * @description
   * Get the number of quarters between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options.
   *
   * @returns The number of full quarters
   *
   * @example
   * // How many full quarters are between 31 December 2013 and 2 July 2014?
   * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
   * //=> 2
   */
  function differenceInQuarters(dateLeft, dateRight, options) {
    const diff = differenceInMonths(dateLeft, dateRight) / 3;
    return getRoundingMethod(options?.roundingMethod)(diff);
  }

  /**
   * The {@link differenceInSeconds} function options.
   */

  /**
   * @name differenceInSeconds
   * @category Second Helpers
   * @summary Get the number of seconds between the given dates.
   *
   * @description
   * Get the number of seconds between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options.
   *
   * @returns The number of seconds
   *
   * @example
   * // How many seconds are between
   * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
   * const result = differenceInSeconds(
   *   new Date(2014, 6, 2, 12, 30, 20, 0),
   *   new Date(2014, 6, 2, 12, 30, 7, 999)
   * )
   * //=> 12
   */
  function differenceInSeconds(dateLeft, dateRight, options) {
    const diff = differenceInMilliseconds(dateLeft, dateRight) / 1000;
    return getRoundingMethod(options?.roundingMethod)(diff);
  }

  /**
   * The {@link differenceInWeeks} function options.
   */

  /**
   * @name differenceInWeeks
   * @category Week Helpers
   * @summary Get the number of full weeks between the given dates.
   *
   * @description
   * Get the number of full weeks between two dates. Fractional weeks are
   * truncated towards zero by default.
   *
   * One "full week" is the distance between a local time in one day to the same
   * local time 7 days earlier or later. A full week can sometimes be less than
   * or more than 7*24 hours if a daylight savings change happens between two dates.
   *
   * To ignore DST and only measure exact 7*24-hour periods, use this instead:
   * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   * @param options - An object with options
   *
   * @returns The number of full weeks
   *
   * @example
   * // How many full weeks are between 5 July 2014 and 20 July 2014?
   * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
   * //=> 2
   *
   * @example
   * // How many full weeks are between
   * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
   * // Note: because local time is used, the
   * // result will always be 8 weeks (54 days),
   * // even if DST starts and the period has
   * // only 54*24-1 hours.
   * const result = differenceInWeeks(
   *   new Date(2020, 5, 1),
   *   new Date(2020, 2, 6)
   * )
   * //=> 8
   */
  function differenceInWeeks(dateLeft, dateRight, options) {
    const diff = differenceInDays(dateLeft, dateRight) / 7;
    return getRoundingMethod(options?.roundingMethod)(diff);
  }

  /**
   * @name differenceInYears
   * @category Year Helpers
   * @summary Get the number of full years between the given dates.
   *
   * @description
   * Get the number of full years between the given dates.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The later date
   * @param dateRight - The earlier date
   *
   * @returns The number of full years
   *
   * @example
   * // How many full years are between 31 December 2013 and 11 February 2015?
   * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
   * //=> 1
   */
  function differenceInYears(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);

    const sign = compareAsc(_dateLeft, _dateRight);
    const difference = Math.abs(differenceInCalendarYears(_dateLeft, _dateRight));

    // Set both dates to a valid leap year for accurate comparison when dealing
    // with leap days
    _dateLeft.setFullYear(1584);
    _dateRight.setFullYear(1584);

    // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastYearNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
    const result = sign * (difference - +isLastYearNotFull);

    // Prevent negative zero
    return result === 0 ? 0 : result;
  }

  /**
   * The {@link eachDayOfInterval} function options.
   */

  /**
   * @name eachDayOfInterval
   * @category Interval Helpers
   * @summary Return the array of dates within the specified time interval.
   *
   * @description
   * Return the array of dates within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval.
   * @param options - An object with options.
   *
   * @returns The array with starts of days from the day of the interval start to the day of the interval end
   *
   * @example
   * // Each day between 6 October 2014 and 10 October 2014:
   * const result = eachDayOfInterval({
   *   start: new Date(2014, 9, 6),
   *   end: new Date(2014, 9, 10)
   * })
   * //=> [
   * //   Mon Oct 06 2014 00:00:00,
   * //   Tue Oct 07 2014 00:00:00,
   * //   Wed Oct 08 2014 00:00:00,
   * //   Thu Oct 09 2014 00:00:00,
   * //   Fri Oct 10 2014 00:00:00
   * // ]
   */
  function eachDayOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate.setDate(currentDate.getDate() + step);
      currentDate.setHours(0, 0, 0, 0);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * The {@link eachHourOfInterval} function options.
   */

  /**
   * @name eachHourOfInterval
   * @category Interval Helpers
   * @summary Return the array of hours within the specified time interval.
   *
   * @description
   * Return the array of hours within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval.
   * @param options - An object with options.
   *
   * @returns The array with starts of hours from the hour of the interval start to the hour of the interval end
   *
   * @example
   * // Each hour between 6 October 2014, 12:00 and 6 October 2014, 15:00
   * const result = eachHourOfInterval({
   *   start: new Date(2014, 9, 6, 12),
   *   end: new Date(2014, 9, 6, 15)
   * })
   * //=> [
   * //   Mon Oct 06 2014 12:00:00,
   * //   Mon Oct 06 2014 13:00:00,
   * //   Mon Oct 06 2014 14:00:00,
   * //   Mon Oct 06 2014 15:00:00
   * // ]
   */
  function eachHourOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    let currentDate = reversed ? endDate : startDate;
    currentDate.setMinutes(0, 0, 0);

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate = addHours(currentDate, step);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * @name startOfMinute
   * @category Minute Helpers
   * @summary Return the start of a minute for the given date.
   *
   * @description
   * Return the start of a minute for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a minute
   *
   * @example
   * // The start of a minute for 1 December 2014 22:15:45.400:
   * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:00
   */
  function startOfMinute(date) {
    const _date = toDate(date);
    _date.setSeconds(0, 0);
    return _date;
  }

  /**
   * The {@link eachMinuteOfInterval} function options.
   */

  /**
   * @name eachMinuteOfInterval
   * @category Interval Helpers
   * @summary Return the array of minutes within the specified time interval.
   *
   * @description
   * Returns the array of minutes within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval.
   * @param options - An object with options.
   *
   * @returns The array with starts of minutes from the minute of the interval start to the minute of the interval end
   *
   * @example
   * // Each minute between 14 October 2020, 13:00 and 14 October 2020, 13:03
   * const result = eachMinuteOfInterval({
   *   start: new Date(2014, 9, 14, 13),
   *   end: new Date(2014, 9, 14, 13, 3)
   * })
   * //=> [
   * //   Wed Oct 14 2014 13:00:00,
   * //   Wed Oct 14 2014 13:01:00,
   * //   Wed Oct 14 2014 13:02:00,
   * //   Wed Oct 14 2014 13:03:00
   * // ]
   */
  function eachMinuteOfInterval(interval, options) {
    const startDate = startOfMinute(toDate(interval.start));
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    let currentDate = reversed ? endDate : startDate;

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate = addMinutes(currentDate, step);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * The {@link eachMonthOfInterval} function options.
   */

  /**
   * @name eachMonthOfInterval
   * @category Interval Helpers
   * @summary Return the array of months within the specified time interval.
   *
   * @description
   * Return the array of months within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval
   *
   * @returns The array with starts of months from the month of the interval start to the month of the interval end
   *
   * @example
   * // Each month between 6 February 2014 and 10 August 2014:
   * const result = eachMonthOfInterval({
   *   start: new Date(2014, 1, 6),
   *   end: new Date(2014, 7, 10)
   * })
   * //=> [
   * //   Sat Feb 01 2014 00:00:00,
   * //   Sat Mar 01 2014 00:00:00,
   * //   Tue Apr 01 2014 00:00:00,
   * //   Thu May 01 2014 00:00:00,
   * //   Sun Jun 01 2014 00:00:00,
   * //   Tue Jul 01 2014 00:00:00,
   * //   Fri Aug 01 2014 00:00:00
   * // ]
   */
  function eachMonthOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setDate(1);

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate.setMonth(currentDate.getMonth() + step);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * @name startOfQuarter
   * @category Quarter Helpers
   * @summary Return the start of a year quarter for the given date.
   *
   * @description
   * Return the start of a year quarter for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a quarter
   *
   * @example
   * // The start of a quarter for 2 September 2014 11:55:00:
   * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Jul 01 2014 00:00:00
   */
  function startOfQuarter(date) {
    const _date = toDate(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - (currentMonth % 3);
    _date.setMonth(month, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * The {@link eachQuarterOfInterval} function options.
   */

  /**
   * @name eachQuarterOfInterval
   * @category Interval Helpers
   * @summary Return the array of quarters within the specified time interval.
   *
   * @description
   * Return the array of quarters within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval
   *
   * @returns The array with starts of quarters from the quarter of the interval start to the quarter of the interval end
   *
   * @example
   * // Each quarter within interval 6 February 2014 - 10 August 2014:
   * const result = eachQuarterOfInterval({
   *   start: new Date(2014, 1, 6),
   *   end: new Date(2014, 7, 10)
   * })
   * //=> [
   * //   Wed Jan 01 2014 00:00:00,
   * //   Tue Apr 01 2014 00:00:00,
   * //   Tue Jul 01 2014 00:00:00,
   * // ]
   */
  function eachQuarterOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed
      ? +startOfQuarter(startDate)
      : +startOfQuarter(endDate);
    let currentDate = reversed
      ? startOfQuarter(endDate)
      : startOfQuarter(startDate);

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate = addQuarters(currentDate, step);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * The {@link eachWeekOfInterval} function options.
   */

  /**
   * @name eachWeekOfInterval
   * @category Interval Helpers
   * @summary Return the array of weeks within the specified time interval.
   *
   * @description
   * Return the array of weeks within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval.
   * @param options - An object with options.
   *
   * @returns The array with starts of weeks from the week of the interval start to the week of the interval end
   *
   * @example
   * // Each week within interval 6 October 2014 - 23 November 2014:
   * const result = eachWeekOfInterval({
   *   start: new Date(2014, 9, 6),
   *   end: new Date(2014, 10, 23)
   * })
   * //=> [
   * //   Sun Oct 05 2014 00:00:00,
   * //   Sun Oct 12 2014 00:00:00,
   * //   Sun Oct 19 2014 00:00:00,
   * //   Sun Oct 26 2014 00:00:00,
   * //   Sun Nov 02 2014 00:00:00,
   * //   Sun Nov 09 2014 00:00:00,
   * //   Sun Nov 16 2014 00:00:00,
   * //   Sun Nov 23 2014 00:00:00
   * // ]
   */
  function eachWeekOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const startDateWeek = reversed
      ? startOfWeek(endDate, options)
      : startOfWeek(startDate, options);
    const endDateWeek = reversed
      ? startOfWeek(startDate, options)
      : startOfWeek(endDate, options);

    // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet
    startDateWeek.setHours(15);
    endDateWeek.setHours(15);

    const endTime = +endDateWeek.getTime();
    let currentDate = startDateWeek;

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      currentDate.setHours(0);
      dates.push(toDate(currentDate));
      currentDate = addWeeks(currentDate, step);
      currentDate.setHours(15);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * @name eachWeekendOfInterval
   * @category Interval Helpers
   * @summary List all the Saturdays and Sundays in the given date interval.
   *
   * @description
   * Get all the Saturdays and Sundays in the given date interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The given interval
   *
   * @returns An array containing all the Saturdays and Sundays
   *
   * @example
   * // Lists all Saturdays and Sundays in the given date interval
   * const result = eachWeekendOfInterval({
   *   start: new Date(2018, 8, 17),
   *   end: new Date(2018, 8, 30)
   * })
   * //=> [
   * //   Sat Sep 22 2018 00:00:00,
   * //   Sun Sep 23 2018 00:00:00,
   * //   Sat Sep 29 2018 00:00:00,
   * //   Sun Sep 30 2018 00:00:00
   * // ]
   */
  function eachWeekendOfInterval(interval) {
    const dateInterval = eachDayOfInterval(interval);
    const weekends = [];
    let index = 0;
    while (index < dateInterval.length) {
      const date = dateInterval[index++];
      if (isWeekend(date)) weekends.push(date);
    }
    return weekends;
  }

  /**
   * @name startOfMonth
   * @category Month Helpers
   * @summary Return the start of a month for the given date.
   *
   * @description
   * Return the start of a month for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a month
   *
   * @example
   * // The start of a month for 2 September 2014 11:55:00:
   * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Mon Sep 01 2014 00:00:00
   */
  function startOfMonth(date) {
    const _date = toDate(date);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * @name eachWeekendOfMonth
   * @category Month Helpers
   * @summary List all the Saturdays and Sundays in the given month.
   *
   * @description
   * Get all the Saturdays and Sundays in the given month.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given month
   *
   * @returns An array containing all the Saturdays and Sundays
   *
   * @example
   * // Lists all Saturdays and Sundays in the given month
   * const result = eachWeekendOfMonth(new Date(2022, 1, 1))
   * //=> [
   * //   Sat Feb 05 2022 00:00:00,
   * //   Sun Feb 06 2022 00:00:00,
   * //   Sat Feb 12 2022 00:00:00,
   * //   Sun Feb 13 2022 00:00:00,
   * //   Sat Feb 19 2022 00:00:00,
   * //   Sun Feb 20 2022 00:00:00,
   * //   Sat Feb 26 2022 00:00:00,
   * //   Sun Feb 27 2022 00:00:00
   * // ]
   */
  function eachWeekendOfMonth(date) {
    const start = startOfMonth(date);
    const end = endOfMonth(date);
    return eachWeekendOfInterval({ start, end });
  }

  /**
   * @name endOfYear
   * @category Year Helpers
   * @summary Return the end of a year for the given date.
   *
   * @description
   * Return the end of a year for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a year
   *
   * @example
   * // The end of a year for 2 September 2014 11:55:00:
   * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
   * //=> Wed Dec 31 2014 23:59:59.999
   */
  function endOfYear(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name startOfYear
   * @category Year Helpers
   * @summary Return the start of a year for the given date.
   *
   * @description
   * Return the start of a year for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a year
   *
   * @example
   * // The start of a year for 2 September 2014 11:55:00:
   * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
   * //=> Wed Jan 01 2014 00:00:00
   */
  function startOfYear(date) {
    const cleanDate = toDate(date);
    const _date = constructFrom(date, 0);
    _date.setFullYear(cleanDate.getFullYear(), 0, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * @name eachWeekendOfYear
   * @category Year Helpers
   * @summary List all the Saturdays and Sundays in the year.
   *
   * @description
   * Get all the Saturdays and Sundays in the year.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given year
   *
   * @returns An array containing all the Saturdays and Sundays
   *
   * @example
   * // Lists all Saturdays and Sundays in the year
   * const result = eachWeekendOfYear(new Date(2020, 1, 1))
   * //=> [
   * //   Sat Jan 03 2020 00:00:00,
   * //   Sun Jan 04 2020 00:00:00,
   * //   ...
   * //   Sun Dec 27 2020 00:00:00
   * // ]
   * ]
   */
  function eachWeekendOfYear(date) {
    const start = startOfYear(date);
    const end = endOfYear(date);
    return eachWeekendOfInterval({ start, end });
  }

  /**
   * The {@link eachYearOfInterval} function options.
   */

  /**
   * @name eachYearOfInterval
   * @category Interval Helpers
   * @summary Return the array of yearly timestamps within the specified time interval.
   *
   * @description
   * Return the array of yearly timestamps within the specified time interval.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval.
   *
   * @returns The array with starts of yearly timestamps from the month of the interval start to the month of the interval end
   *
   * @example
   * // Each year between 6 February 2014 and 10 August 2017:
   * const result = eachYearOfInterval({
   *   start: new Date(2014, 1, 6),
   *   end: new Date(2017, 7, 10)
   * })
   * //=> [
   * //   Wed Jan 01 2014 00:00:00,
   * //   Thu Jan 01 2015 00:00:00,
   * //   Fri Jan 01 2016 00:00:00,
   * //   Sun Jan 01 2017 00:00:00
   * // ]
   */
  function eachYearOfInterval(interval, options) {
    const startDate = toDate(interval.start);
    const endDate = toDate(interval.end);

    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setMonth(0, 1);

    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
      step = -step;
      reversed = !reversed;
    }

    const dates = [];

    while (+currentDate <= endTime) {
      dates.push(toDate(currentDate));
      currentDate.setFullYear(currentDate.getFullYear() + step);
    }

    return reversed ? dates.reverse() : dates;
  }

  /**
   * @name endOfDecade
   * @category Decade Helpers
   * @summary Return the end of a decade for the given date.
   *
   * @description
   * Return the end of a decade for the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a decade
   *
   * @example
   * // The end of a decade for 12 May 1984 00:00:00:
   * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))
   * //=> Dec 31 1989 23:59:59.999
   */
  function endOfDecade(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const decade = 9 + Math.floor(year / 10) * 10;
    _date.setFullYear(decade, 11, 31);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name endOfHour
   * @category Hour Helpers
   * @summary Return the end of an hour for the given date.
   *
   * @description
   * Return the end of an hour for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of an hour
   *
   * @example
   * // The end of an hour for 2 September 2014 11:55:00:
   * const result = endOfHour(new Date(2014, 8, 2, 11, 55))
   * //=> Tue Sep 02 2014 11:59:59.999
   */
  function endOfHour(date) {
    const _date = toDate(date);
    _date.setMinutes(59, 59, 999);
    return _date;
  }

  /**
   * The {@link endOfWeek} function options.
   */

  /**
   * @name endOfWeek
   * @category Week Helpers
   * @summary Return the end of a week for the given date.
   *
   * @description
   * Return the end of a week for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options
   *
   * @returns The end of a week
   *
   * @example
   * // The end of a week for 2 September 2014 11:55:00:
   * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Sat Sep 06 2014 23:59:59.999
   *
   * @example
   * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
   * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
   * //=> Sun Sep 07 2014 23:59:59.999
   */
  function endOfWeek(date, options) {
    const defaultOptions = getDefaultOptions$1();
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const _date = toDate(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

    _date.setDate(_date.getDate() + diff);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name endOfISOWeek
   * @category ISO Week Helpers
   * @summary Return the end of an ISO week for the given date.
   *
   * @description
   * Return the end of an ISO week for the given date.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of an ISO week
   *
   * @example
   * // The end of an ISO week for 2 September 2014 11:55:00:
   * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Sun Sep 07 2014 23:59:59.999
   */
  function endOfISOWeek(date) {
    return endOfWeek(date, { weekStartsOn: 1 });
  }

  /**
   * @name endOfISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Return the end of an ISO week-numbering year for the given date.
   *
   * @description
   * Return the end of an ISO week-numbering year,
   * which always starts 3 days before the year's first Thursday.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of an ISO week-numbering year
   *
   * @example
   * // The end of an ISO week-numbering year for 2 July 2005:
   * const result = endOfISOWeekYear(new Date(2005, 6, 2))
   * //=> Sun Jan 01 2006 23:59:59.999
   */
  function endOfISOWeekYear(date) {
    const year = getISOWeekYear(date);
    const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const _date = startOfISOWeek(fourthOfJanuaryOfNextYear);
    _date.setMilliseconds(_date.getMilliseconds() - 1);
    return _date;
  }

  /**
   * @name endOfMinute
   * @category Minute Helpers
   * @summary Return the end of a minute for the given date.
   *
   * @description
   * Return the end of a minute for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a minute
   *
   * @example
   * // The end of a minute for 1 December 2014 22:15:45.400:
   * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:59.999
   */
  function endOfMinute(date) {
    const _date = toDate(date);
    _date.setSeconds(59, 999);
    return _date;
  }

  /**
   * @name endOfQuarter
   * @category Quarter Helpers
   * @summary Return the end of a year quarter for the given date.
   *
   * @description
   * Return the end of a year quarter for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a quarter
   *
   * @example
   * // The end of a quarter for 2 September 2014 11:55:00:
   * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 30 2014 23:59:59.999
   */
  function endOfQuarter(date) {
    const _date = toDate(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - (currentMonth % 3) + 3;
    _date.setMonth(month, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
  }

  /**
   * @name endOfSecond
   * @category Second Helpers
   * @summary Return the end of a second for the given date.
   *
   * @description
   * Return the end of a second for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of a second
   *
   * @example
   * // The end of a second for 1 December 2014 22:15:45.400:
   * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:45.999
   */
  function endOfSecond(date) {
    const _date = toDate(date);
    _date.setMilliseconds(999);
    return _date;
  }

  /**
   * @name endOfToday
   * @category Day Helpers
   * @summary Return the end of today.
   * @pure false
   *
   * @description
   * Return the end of today.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @returns The end of today
   *
   * @example
   * // If today is 6 October 2014:
   * const result = endOfToday()
   * //=> Mon Oct 6 2014 23:59:59.999
   */
  function endOfToday() {
    return endOfDay(Date.now());
  }

  /**
   * @name endOfTomorrow
   * @category Day Helpers
   * @summary Return the end of tomorrow.
   * @pure false
   *
   * @description
   * Return the end of tomorrow.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @returns The end of tomorrow
   *
   * @example
   * // If today is 6 October 2014:
   * const result = endOfTomorrow()
   * //=> Tue Oct 7 2014 23:59:59.999
   */
  function endOfTomorrow() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();

    const date = new Date(0);
    date.setFullYear(year, month, day + 1);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  /**
   * @name endOfYesterday
   * @category Day Helpers
   * @summary Return the end of yesterday.
   * @pure false
   *
   * @description
   * Return the end of yesterday.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @returns The end of yesterday
   *
   * @example
   * // If today is 6 October 2014:
   * const result = endOfYesterday()
   * //=> Sun Oct 5 2014 23:59:59.999
   */
  function endOfYesterday() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();

    const date = new Date(0);
    date.setFullYear(year, month, day - 1);
    date.setHours(23, 59, 59, 999);
    return date;
  }

  const formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds",
    },

    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds",
    },

    halfAMinute: "half a minute",

    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes",
    },

    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes",
    },

    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours",
    },

    xHours: {
      one: "1 hour",
      other: "{{count}} hours",
    },

    xDays: {
      one: "1 day",
      other: "{{count}} days",
    },

    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks",
    },

    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks",
    },

    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months",
    },

    xMonths: {
      one: "1 month",
      other: "{{count}} months",
    },

    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years",
    },

    xYears: {
      one: "1 year",
      other: "{{count}} years",
    },

    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years",
    },

    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years",
    },
  };

  const formatDistance$1 = (token, count, options) => {
    let result;

    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }

    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }

    return result;
  };

  function buildFormatLongFn(args) {
    return (options = {}) => {
      // TODO: Remove String()
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy",
  };

  const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a",
  };

  const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}",
  };

  const formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full",
    }),

    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full",
    }),

    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full",
    }),
  };

  const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P",
  };

  const formatRelative$1 = (token, _date, _baseDate, _options) =>
    formatRelativeLocale[token];

  /* eslint-disable no-unused-vars */

  /**
   * The localize function argument callback which allows to convert raw value to
   * the actual type.
   *
   * @param value - The value to convert
   *
   * @returns The converted value
   */

  /**
   * The map of localized values for each width.
   */

  /**
   * The index type of the locale unit value. It types conversion of units of
   * values that don't start at 0 (i.e. quarters).
   */

  /**
   * Converts the unit value to the tuple of values.
   */

  /**
   * The tuple of localized era values. The first element represents BC,
   * the second element represents AD.
   */

  /**
   * The tuple of localized quarter values. The first element represents Q1.
   */

  /**
   * The tuple of localized day values. The first element represents Sunday.
   */

  /**
   * The tuple of localized month values. The first element represents January.
   */

  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = options?.context ? String(options.context) : "standalone";

      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = options?.width ? String(options.width) : defaultWidth;

        valuesArray =
          args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = options?.width ? String(options.width) : args.defaultWidth;

        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;

      // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
      return valuesArray[index];
    };
  }

  const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"],
  };

  const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"],
  };

  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
  const monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],

    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
  };

  const dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
  };

  const dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night",
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night",
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night",
    },
  };

  const formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night",
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night",
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night",
    },
  };

  const ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);

    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`.
    //
    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'.

    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };

  const localize = {
    ordinalNumber,

    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide",
    }),

    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1,
    }),

    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide",
    }),

    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide",
    }),

    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide",
    }),
  };

  function buildMatchFn(args) {
    return (string, options = {}) => {
      const width = options.width;

      const matchPattern =
        (width && args.matchPatterns[width]) ||
        args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string.match(matchPattern);

      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];

      const parsePatterns =
        (width && args.parsePatterns[width]) ||
        args.parsePatterns[args.defaultParseWidth];

      const key = Array.isArray(parsePatterns)
        ? findIndex$1(parsePatterns, (pattern) => pattern.test(matchedString))
        : // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          findKey(parsePatterns, (pattern) => pattern.test(matchedString));

      let value;

      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback
        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          options.valueCallback(value)
        : value;

      const rest = string.slice(matchedString.length);

      return { value, rest };
    };
  }

  function findKey(object, predicate) {
    for (const key in object) {
      if (
        Object.prototype.hasOwnProperty.call(object, key) &&
        predicate(object[key])
      ) {
        return key;
      }
    }
    return undefined;
  }

  function findIndex$1(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return undefined;
  }

  function buildMatchPatternFn(args) {
    return (string, options = {}) => {
      const matchResult = string.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];

      const parseResult = string.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback
        ? args.valueCallback(parseResult[0])
        : parseResult[0];

      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      value = options.valueCallback ? options.valueCallback(value) : value;

      const rest = string.slice(matchedString.length);

      return { value, rest };
    };
  }

  const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  const parseOrdinalNumberPattern = /\d+/i;

  const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i,
  };
  const parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i],
  };

  const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i,
  };
  const parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i],
  };

  const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i,
  };
  const parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i,
    ],

    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i,
    ],
  };

  const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i,
  };
  const parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i],
  };

  const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i,
  };
  const parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i,
    },
  };

  const match$1 = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10),
    }),

    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any",
    }),

    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1,
    }),

    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any",
    }),

    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any",
    }),

    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any",
    }),
  };

  /**
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
   * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
   */
  const enUS = {
    code: "en-US",
    formatDistance: formatDistance$1,
    formatLong: formatLong,
    formatRelative: formatRelative$1,
    localize: localize,
    match: match$1,
    options: {
      weekStartsOn: 0 /* Sunday */,
      firstWeekContainsDate: 1,
    },
  };

  /**
   * @name getDayOfYear
   * @category Day Helpers
   * @summary Get the day of the year of the given date.
   *
   * @description
   * Get the day of the year of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The day of year
   *
   * @example
   * // Which day of the year is 2 July 2014?
   * const result = getDayOfYear(new Date(2014, 6, 2))
   * //=> 183
   */
  function getDayOfYear(date) {
    const _date = toDate(date);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }

  /**
   * @name getISOWeek
   * @category ISO Week Helpers
   * @summary Get the ISO week of the given date.
   *
   * @description
   * Get the ISO week of the given date.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The ISO week
   *
   * @example
   * // Which week of the ISO-week numbering year is 2 January 2005?
   * const result = getISOWeek(new Date(2005, 0, 2))
   * //=> 53
   */
  function getISOWeek(date) {
    const _date = toDate(date);
    const diff =
      startOfISOWeek(_date).getTime() - startOfISOWeekYear(_date).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  /**
   * The {@link getWeekYear} function options.
   */

  /**
   * @name getWeekYear
   * @category Week-Numbering Year Helpers
   * @summary Get the local week-numbering year of the given date.
   *
   * @description
   * Get the local week-numbering year of the given date.
   * The exact calculation depends on the values of
   * `options.weekStartsOn` (which is the index of the first day of the week)
   * and `options.firstWeekContainsDate` (which is the day of January, which is always in
   * the first week of the week-numbering year)
   *
   * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - An object with options.
   *
   * @returns The local week-numbering year
   *
   * @example
   * // Which week numbering year is 26 December 2004 with the default settings?
   * const result = getWeekYear(new Date(2004, 11, 26))
   * //=> 2005
   *
   * @example
   * // Which week numbering year is 26 December 2004 if week starts on Saturday?
   * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
   * //=> 2004
   *
   * @example
   * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
   * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
   * //=> 2004
   */
  function getWeekYear(date, options) {
    const _date = toDate(date);
    const year = _date.getFullYear();

    const defaultOptions = getDefaultOptions$1();
    const firstWeekContainsDate =
      options?.firstWeekContainsDate ??
      options?.locale?.options?.firstWeekContainsDate ??
      defaultOptions.firstWeekContainsDate ??
      defaultOptions.locale?.options?.firstWeekContainsDate ??
      1;

    const firstWeekOfNextYear = constructFrom(date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);

    const firstWeekOfThisYear = constructFrom(date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);

    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  /**
   * The {@link startOfWeekYear} function options.
   */

  /**
   * @name startOfWeekYear
   * @category Week-Numbering Year Helpers
   * @summary Return the start of a local week-numbering year for the given date.
   *
   * @description
   * Return the start of a local week-numbering year.
   * The exact calculation depends on the values of
   * `options.weekStartsOn` (which is the index of the first day of the week)
   * and `options.firstWeekContainsDate` (which is the day of January, which is always in
   * the first week of the week-numbering year)
   *
   * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options
   *
   * @returns The start of a week-numbering year
   *
   * @example
   * // The start of an a week-numbering year for 2 July 2005 with default settings:
   * const result = startOfWeekYear(new Date(2005, 6, 2))
   * //=> Sun Dec 26 2004 00:00:00
   *
   * @example
   * // The start of a week-numbering year for 2 July 2005
   * // if Monday is the first day of week
   * // and 4 January is always in the first week of the year:
   * const result = startOfWeekYear(new Date(2005, 6, 2), {
   *   weekStartsOn: 1,
   *   firstWeekContainsDate: 4
   * })
   * //=> Mon Jan 03 2005 00:00:00
   */
  function startOfWeekYear(date, options) {
    const defaultOptions = getDefaultOptions$1();
    const firstWeekContainsDate =
      options?.firstWeekContainsDate ??
      options?.locale?.options?.firstWeekContainsDate ??
      defaultOptions.firstWeekContainsDate ??
      defaultOptions.locale?.options?.firstWeekContainsDate ??
      1;

    const year = getWeekYear(date, options);
    const firstWeek = constructFrom(date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }

  /**
   * The {@link getWeek} function options.
   */

  /**
   * @name getWeek
   * @category Week Helpers
   * @summary Get the local week index of the given date.
   *
   * @description
   * Get the local week index of the given date.
   * The exact calculation depends on the values of
   * `options.weekStartsOn` (which is the index of the first day of the week)
   * and `options.firstWeekContainsDate` (which is the day of January, which is always in
   * the first week of the week-numbering year)
   *
   * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - An object with options
   *
   * @returns The week
   *
   * @example
   * // Which week of the local week numbering year is 2 January 2005 with default options?
   * const result = getWeek(new Date(2005, 0, 2))
   * //=> 2
   *
   * @example
   * // Which week of the local week numbering year is 2 January 2005,
   * // if Monday is the first day of the week,
   * // and the first week of the year always contains 4 January?
   * const result = getWeek(new Date(2005, 0, 2), {
   *   weekStartsOn: 1,
   *   firstWeekContainsDate: 4
   * })
   * //=> 53
   */

  function getWeek(date, options) {
    const _date = toDate(date);
    const diff =
      startOfWeek(_date, options).getTime() -
      startOfWeekYear(_date, options).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / millisecondsInWeek) + 1;
  }

  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }

  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* |                                |
   * |  d  | Day of month                   |  D  |                                |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  m  | Minute                         |  M  | Month                          |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  y  | Year (abs)                     |  Y  |                                |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   */

  const lightFormatters = {
    // Year
    y(date, token) {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

      const signedYear = date.getFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },

    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },

    // Day of the month
    d(date, token) {
      return addLeadingZeros(date.getDate(), token.length);
    },

    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";

      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },

    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },

    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros(date.getHours(), token.length);
    },

    // Minute
    m(date, token) {
      return addLeadingZeros(date.getMinutes(), token.length);
    },

    // Second
    s(date, token) {
      return addLeadingZeros(date.getSeconds(), token.length);
    },

    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.floor(
        milliseconds * Math.pow(10, numberOfDigits - 3),
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    },
  };

  const dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night",
  };

  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
   * |  p! | Long localized time            |  P! | Long localized date            |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   * - `P` is long localized date format
   * - `p` is long localized time format
   */

  const formatters = {
    // Era
    G: function (date, token, localize) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize.era(era, { width: "wide" });
      }
    },

    // Year
    y: function (date, token, localize) {
      // Ordinal number
      if (token === "yo") {
        const signedYear = date.getFullYear();
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, { unit: "year" });
      }

      return lightFormatters.y(date, token);
    },

    // Local week-numbering year
    Y: function (date, token, localize, options) {
      const signedWeekYear = getWeekYear(date, options);
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

      // Two digit year
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }

      // Ordinal number
      if (token === "Yo") {
        return localize.ordinalNumber(weekYear, { unit: "year" });
      }

      // Padding
      return addLeadingZeros(weekYear, token.length);
    },

    // ISO week-numbering year
    R: function (date, token) {
      const isoWeekYear = getISOWeekYear(date);

      // Padding
      return addLeadingZeros(isoWeekYear, token.length);
    },

    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function (date, token) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token.length);
    },

    // Quarter
    Q: function (date, token, localize) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "formatting",
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "formatting",
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // Stand-alone quarter
    q: function (date, token, localize) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "standalone",
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "standalone",
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "standalone",
          });
      }
    },

    // Month
    M: function (date, token, localize) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize.month(month, {
            width: "abbreviated",
            context: "formatting",
          });
        // J, F, ..., D
        case "MMMMM":
          return localize.month(month, {
            width: "narrow",
            context: "formatting",
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize.month(month, { width: "wide", context: "formatting" });
      }
    },

    // Stand-alone month
    L: function (date, token, localize) {
      const month = date.getMonth();
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize.month(month, {
            width: "abbreviated",
            context: "standalone",
          });
        // J, F, ..., D
        case "LLLLL":
          return localize.month(month, {
            width: "narrow",
            context: "standalone",
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize.month(month, { width: "wide", context: "standalone" });
      }
    },

    // Local week of year
    w: function (date, token, localize, options) {
      const week = getWeek(date, options);

      if (token === "wo") {
        return localize.ordinalNumber(week, { unit: "week" });
      }

      return addLeadingZeros(week, token.length);
    },

    // ISO week of year
    I: function (date, token, localize) {
      const isoWeek = getISOWeek(date);

      if (token === "Io") {
        return localize.ordinalNumber(isoWeek, { unit: "week" });
      }

      return addLeadingZeros(isoWeek, token.length);
    },

    // Day of the month
    d: function (date, token, localize) {
      if (token === "do") {
        return localize.ordinalNumber(date.getDate(), { unit: "date" });
      }

      return lightFormatters.d(date, token);
    },

    // Day of year
    D: function (date, token, localize) {
      const dayOfYear = getDayOfYear(date);

      if (token === "Do") {
        return localize.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }

      return addLeadingZeros(dayOfYear, token.length);
    },

    // Day of week
    E: function (date, token, localize) {
      const dayOfWeek = date.getDay();
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting",
          });
        // T
        case "EEEEE":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting",
          });
        // Tu
        case "EEEEEE":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting",
          });
        // Tuesday
        case "EEEE":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // Local day of week
    e: function (date, token, localize, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting",
          });
        // T
        case "eeeee":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting",
          });
        // Tu
        case "eeeeee":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting",
          });
        // Tuesday
        case "eeee":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // Stand-alone local day of week
    c: function (date, token, localize, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone",
          });
        // T
        case "ccccc":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "standalone",
          });
        // Tu
        case "cccccc":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "standalone",
          });
        // Tuesday
        case "cccc":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "standalone",
          });
      }
    },

    // ISO day of week
    i: function (date, token, localize) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd
        case "io":
          return localize.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting",
          });
        // T
        case "iiiii":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting",
          });
        // Tu
        case "iiiiii":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting",
          });
        // Tuesday
        case "iiii":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // AM or PM
    a: function (date, token, localize) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";

      switch (token) {
        case "a":
        case "aa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          });
        case "aaa":
          return localize
            .dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting",
            })
            .toLowerCase();
        case "aaaaa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting",
          });
        case "aaaa":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // AM, PM, midnight, noon
    b: function (date, token, localize) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }

      switch (token) {
        case "b":
        case "bb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          });
        case "bbb":
          return localize
            .dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting",
            })
            .toLowerCase();
        case "bbbbb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting",
          });
        case "bbbb":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // in the morning, in the afternoon, in the evening, at night
    B: function (date, token, localize) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }

      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting",
          });
        case "BBBBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting",
          });
        case "BBBB":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting",
          });
      }
    },

    // Hour [1-12]
    h: function (date, token, localize) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize.ordinalNumber(hours, { unit: "hour" });
      }

      return lightFormatters.h(date, token);
    },

    // Hour [0-23]
    H: function (date, token, localize) {
      if (token === "Ho") {
        return localize.ordinalNumber(date.getHours(), { unit: "hour" });
      }

      return lightFormatters.H(date, token);
    },

    // Hour [0-11]
    K: function (date, token, localize) {
      const hours = date.getHours() % 12;

      if (token === "Ko") {
        return localize.ordinalNumber(hours, { unit: "hour" });
      }

      return addLeadingZeros(hours, token.length);
    },

    // Hour [1-24]
    k: function (date, token, localize) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;

      if (token === "ko") {
        return localize.ordinalNumber(hours, { unit: "hour" });
      }

      return addLeadingZeros(hours, token.length);
    },

    // Minute
    m: function (date, token, localize) {
      if (token === "mo") {
        return localize.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }

      return lightFormatters.m(date, token);
    },

    // Second
    s: function (date, token, localize) {
      if (token === "so") {
        return localize.ordinalNumber(date.getSeconds(), { unit: "second" });
      }

      return lightFormatters.s(date, token);
    },

    // Fraction of second
    S: function (date, token) {
      return lightFormatters.S(date, token);
    },

    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timezoneOffset = originalDate.getTimezoneOffset();

      if (timezoneOffset === 0) {
        return "Z";
      }

      switch (token) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);

        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX": // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);

        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX": // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },

    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);

        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx": // Hours and minutes without `:` delimiter
          return formatTimezone(timezoneOffset);

        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx": // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },

    // Timezone (GMT)
    O: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },

    // Timezone (specific non-location)
    z: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timezoneOffset = originalDate.getTimezoneOffset();

      switch (token) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },

    // Seconds timestamp
    t: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timestamp = Math.floor(originalDate.getTime() / 1000);
      return addLeadingZeros(timestamp, token.length);
    },

    // Milliseconds timestamp
    T: function (date, token, _localize, options) {
      const originalDate = options._originalDate || date;
      const timestamp = originalDate.getTime();
      return addLeadingZeros(timestamp, token.length);
    },
  };

  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.floor(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }

  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }

  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }

  const dateLongFormatter = (pattern, formatLong) => {
    switch (pattern) {
      case "P":
        return formatLong.date({ width: "short" });
      case "PP":
        return formatLong.date({ width: "medium" });
      case "PPP":
        return formatLong.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong.date({ width: "full" });
    }
  };

  const timeLongFormatter = (pattern, formatLong) => {
    switch (pattern) {
      case "p":
        return formatLong.time({ width: "short" });
      case "pp":
        return formatLong.time({ width: "medium" });
      case "ppp":
        return formatLong.time({ width: "long" });
      case "pppp":
      default:
        return formatLong.time({ width: "full" });
    }
  };

  const dateTimeLongFormatter = (pattern, formatLong) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];

    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }

    let dateTimeFormat;

    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong.dateTime({ width: "full" });
        break;
    }

    return dateTimeFormat
      .replace("{{date}}", dateLongFormatter(datePattern, formatLong))
      .replace("{{time}}", timeLongFormatter(timePattern, formatLong));
  };

  const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter,
  };

  const dayOfYearTokenRE = /^D+$/;
  const weekYearTokenRE = /^Y+$/;

  const throwTokens = ["D", "DD", "YY", "YYYY"];

  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }

  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }

  function warnOrThrowProtectedError(token, format, input) {
    const _message = message(token, format, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
  }

  function message(token, format, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }

  // This RegExp consists of three parts separated by `|`:
  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps
  const formattingTokensRegExp$2 =
    /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

  // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
  const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

  const escapedStringRegExp$2 = /^'([^]*?)'?$/;
  const doubleQuoteRegExp$2 = /''/g;
  const unescapedLatinCharacterRegExp$2 = /[a-zA-Z]/;

  /**
   * The {@link format} function options.
   */

  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | AM, PM                          | a..aa   | AM, PM                            |       |
   * |                                 | aaa     | am, pm                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
   * |                                 | bbb     | am, pm, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 01, 02, ..., 11, 00               |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 001, ..., 999                |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
   * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 04/29/1453                        | 7     |
   * |                                 | PP      | Apr 29, 1453                      | 7     |
   * |                                 | PPP     | April 29th, 1453                  | 7     |
   * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
   * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
   *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
   *
   * 6. Specific non-location timezones are currently unavailable in `date-fns`,
   *    so right now these tokens fall back to GMT timezones.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param format - The string of tokens
   * @param options - An object with options
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   * @throws `options.locale` must contain `localize` property
   * @throws `options.locale` must contain `formatLong` property
   * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws format string contains an unescaped latin alphabet character
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */
  function format(date, formatStr, options) {
    const defaultOptions = getDefaultOptions$1();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;

    const firstWeekContainsDate =
      options?.firstWeekContainsDate ??
      options?.locale?.options?.firstWeekContainsDate ??
      defaultOptions.firstWeekContainsDate ??
      defaultOptions.locale?.options?.firstWeekContainsDate ??
      1;

    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const originalDate = toDate(date);

    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }

    const formatterOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale,
      _originalDate: originalDate,
    };

    const result = formatStr
      .match(longFormattingTokensRegExp$1)
      .map(function (substring) {
        const firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          const longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      })
      .join("")
      .match(formattingTokensRegExp$2)
      .map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        const firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString$2(substring);
        }

        const formatter = formatters[firstCharacter];
        if (formatter) {
          if (
            !options?.useAdditionalWeekYearTokens &&
            isProtectedWeekYearToken(substring)
          ) {
            warnOrThrowProtectedError(substring, formatStr, String(date));
          }
          if (
            !options?.useAdditionalDayOfYearTokens &&
            isProtectedDayOfYearToken(substring)
          ) {
            warnOrThrowProtectedError(substring, formatStr, String(date));
          }
          return formatter(
            originalDate,
            substring,
            locale.localize,
            formatterOptions,
          );
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp$2)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" +
              firstCharacter +
              "`",
          );
        }

        return substring;
      })
      .join("");

    return result;
  }

  function cleanEscapedString$2(input) {
    const matched = input.match(escapedStringRegExp$2);

    if (!matched) {
      return input;
    }

    return matched[1].replace(doubleQuoteRegExp$2, "'");
  }

  /**
   * The {@link formatDistance} function options.
   */

  /**
   * @name formatDistance
   * @category Common Helpers
   * @summary Return the distance between the given dates in words.
   *
   * @description
   * Return the distance between the given dates in words.
   *
   * | Distance between dates                                            | Result              |
   * |-------------------------------------------------------------------|---------------------|
   * | 0 ... 30 secs                                                     | less than a minute  |
   * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
   * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
   * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
   * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
   * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
   * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
   * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
   * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
   * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
   * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
   * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
   * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
   * | N yrs ... N yrs 3 months                                          | about N years       |
   * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
   * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
   *
   * With `options.includeSeconds == true`:
   * | Distance between dates | Result               |
   * |------------------------|----------------------|
   * | 0 secs ... 5 secs      | less than 5 seconds  |
   * | 5 secs ... 10 secs     | less than 10 seconds |
   * | 10 secs ... 20 secs    | less than 20 seconds |
   * | 20 secs ... 40 secs    | half a minute        |
   * | 40 secs ... 60 secs    | less than a minute   |
   * | 60 secs ... 90 secs    | 1 minute             |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date
   * @param baseDate - The date to compare with
   * @param options - An object with options
   *
   * @returns The distance in words
   *
   * @throws `date` must not be Invalid Date
   * @throws `baseDate` must not be Invalid Date
   * @throws `options.locale` must contain `formatDistance` property
   *
   * @example
   * // What is the distance between 2 July 2014 and 1 January 2015?
   * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
   * //=> '6 months'
   *
   * @example
   * // What is the distance between 1 January 2015 00:00:15
   * // and 1 January 2015 00:00:00, including seconds?
   * const result = formatDistance(
   *   new Date(2015, 0, 1, 0, 0, 15),
   *   new Date(2015, 0, 1, 0, 0, 0),
   *   { includeSeconds: true }
   * )
   * //=> 'less than 20 seconds'
   *
   * @example
   * // What is the distance from 1 January 2016
   * // to 1 January 2015, with a suffix?
   * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
   *   addSuffix: true
   * })
   * //=> 'about 1 year ago'
   *
   * @example
   * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
   * import { eoLocale } from 'date-fns/locale/eo'
   * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
   *   locale: eoLocale
   * })
   * //=> 'pli ol 1 jaro'
   */

  function formatDistance(date, baseDate, options) {
    const defaultOptions = getDefaultOptions$1();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;
    const minutesInAlmostTwoDays = 2520;

    const comparison = compareAsc(date, baseDate);

    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }

    const localizeOptions = Object.assign({}, options, {
      addSuffix: options?.addSuffix,
      comparison: comparison,
    });

    let dateLeft;
    let dateRight;
    if (comparison > 0) {
      dateLeft = toDate(baseDate);
      dateRight = toDate(date);
    } else {
      dateLeft = toDate(date);
      dateRight = toDate(baseDate);
    }

    const seconds = differenceInSeconds(dateRight, dateLeft);
    const offsetInSeconds =
      (getTimezoneOffsetInMilliseconds(dateRight) -
        getTimezoneOffsetInMilliseconds(dateLeft)) /
      1000;
    const minutes = Math.round((seconds - offsetInSeconds) / 60);
    let months;

    // 0 up to 2 mins
    if (minutes < 2) {
      if (options?.includeSeconds) {
        if (seconds < 5) {
          return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
        } else if (seconds < 10) {
          return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
        } else if (seconds < 20) {
          return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
        } else if (seconds < 40) {
          return locale.formatDistance("halfAMinute", 0, localizeOptions);
        } else if (seconds < 60) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", 1, localizeOptions);
        }
      } else {
        if (minutes === 0) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", minutes, localizeOptions);
        }
      }

      // 2 mins up to 0.75 hrs
    } else if (minutes < 45) {
      return locale.formatDistance("xMinutes", minutes, localizeOptions);

      // 0.75 hrs up to 1.5 hrs
    } else if (minutes < 90) {
      return locale.formatDistance("aboutXHours", 1, localizeOptions);

      // 1.5 hrs up to 24 hrs
    } else if (minutes < minutesInDay) {
      const hours = Math.round(minutes / 60);
      return locale.formatDistance("aboutXHours", hours, localizeOptions);

      // 1 day up to 1.75 days
    } else if (minutes < minutesInAlmostTwoDays) {
      return locale.formatDistance("xDays", 1, localizeOptions);

      // 1.75 days up to 30 days
    } else if (minutes < minutesInMonth) {
      const days = Math.round(minutes / minutesInDay);
      return locale.formatDistance("xDays", days, localizeOptions);

      // 1 month up to 2 months
    } else if (minutes < minutesInMonth * 2) {
      months = Math.round(minutes / minutesInMonth);
      return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }

    months = differenceInMonths(dateRight, dateLeft);

    // 2 months up to 12 months
    if (months < 12) {
      const nearestMonth = Math.round(minutes / minutesInMonth);
      return locale.formatDistance("xMonths", nearestMonth, localizeOptions);

      // 1 year up to max Date
    } else {
      const monthsSinceStartOfYear = months % 12;
      const years = Math.floor(months / 12);

      // N years up to 1 years 3 months
      if (monthsSinceStartOfYear < 3) {
        return locale.formatDistance("aboutXYears", years, localizeOptions);

        // N years 3 months up to N years 9 months
      } else if (monthsSinceStartOfYear < 9) {
        return locale.formatDistance("overXYears", years, localizeOptions);

        // N years 9 months up to N year 12 months
      } else {
        return locale.formatDistance("almostXYears", years + 1, localizeOptions);
      }
    }
  }

  /**
   * The {@link formatDistanceStrict} function options.
   */

  /**
   * The unit used to format the distance in {@link formatDistanceStrict}.
   */

  /**
   * @name formatDistanceStrict
   * @category Common Helpers
   * @summary Return the distance between the given dates in words.
   *
   * @description
   * Return the distance between the given dates in words, using strict units.
   * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
   * 'less than' and the like.
   *
   * | Distance between dates | Result              |
   * |------------------------|---------------------|
   * | 0 ... 59 secs          | [0..59] seconds     |
   * | 1 ... 59 mins          | [1..59] minutes     |
   * | 1 ... 23 hrs           | [1..23] hours       |
   * | 1 ... 29 days          | [1..29] days        |
   * | 1 ... 11 months        | [1..11] months      |
   * | 1 ... N years          | [1..N]  years       |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date
   * @param baseDate - The date to compare with
   * @param options - An object with options
   *
   * @returns The distance in words
   *
   * @throws `date` must not be Invalid Date
   * @throws `baseDate` must not be Invalid Date
   * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
   * @throws `options.locale` must contain `formatDistance` property
   *
   * @example
   * // What is the distance between 2 July 2014 and 1 January 2015?
   * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
   * //=> '6 months'
   *
   * @example
   * // What is the distance between 1 January 2015 00:00:15
   * // and 1 January 2015 00:00:00?
   * const result = formatDistanceStrict(
   *   new Date(2015, 0, 1, 0, 0, 15),
   *   new Date(2015, 0, 1, 0, 0, 0)
   * )
   * //=> '15 seconds'
   *
   * @example
   * // What is the distance from 1 January 2016
   * // to 1 January 2015, with a suffix?
   * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
   *   addSuffix: true
   * })
   * //=> '1 year ago'
   *
   * @example
   * // What is the distance from 1 January 2016
   * // to 1 January 2015, in minutes?
   * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
   *   unit: 'minute'
   * })
   * //=> '525600 minutes'
   *
   * @example
   * // What is the distance from 1 January 2015
   * // to 28 January 2015, in months, rounded up?
   * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
   *   unit: 'month',
   *   roundingMethod: 'ceil'
   * })
   * //=> '1 month'
   *
   * @example
   * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
   * import { eoLocale } from 'date-fns/locale/eo'
   * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
   *   locale: eoLocale
   * })
   * //=> '1 jaro'
   */

  function formatDistanceStrict(date, baseDate, options) {
    const defaultOptions = getDefaultOptions$1();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;

    const comparison = compareAsc(date, baseDate);

    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }

    const localizeOptions = Object.assign({}, options, {
      addSuffix: options?.addSuffix,
      comparison: comparison,
    });

    let dateLeft;
    let dateRight;
    if (comparison > 0) {
      dateLeft = toDate(baseDate);
      dateRight = toDate(date);
    } else {
      dateLeft = toDate(date);
      dateRight = toDate(baseDate);
    }

    const roundingMethod = getRoundingMethod(options?.roundingMethod ?? "round");

    const milliseconds = dateRight.getTime() - dateLeft.getTime();
    const minutes = milliseconds / millisecondsInMinute;

    const timezoneOffset =
      getTimezoneOffsetInMilliseconds(dateRight) -
      getTimezoneOffsetInMilliseconds(dateLeft);

    // Use DST-normalized difference in minutes for years, months and days;
    // use regular difference in minutes for hours, minutes and seconds.
    const dstNormalizedMinutes =
      (milliseconds - timezoneOffset) / millisecondsInMinute;

    const defaultUnit = options?.unit;
    let unit;
    if (!defaultUnit) {
      if (minutes < 1) {
        unit = "second";
      } else if (minutes < 60) {
        unit = "minute";
      } else if (minutes < minutesInDay) {
        unit = "hour";
      } else if (dstNormalizedMinutes < minutesInMonth) {
        unit = "day";
      } else if (dstNormalizedMinutes < minutesInYear) {
        unit = "month";
      } else {
        unit = "year";
      }
    } else {
      unit = defaultUnit;
    }

    // 0 up to 60 seconds
    if (unit === "second") {
      const seconds = roundingMethod(milliseconds / 1000);
      return locale.formatDistance("xSeconds", seconds, localizeOptions);

      // 1 up to 60 mins
    } else if (unit === "minute") {
      const roundedMinutes = roundingMethod(minutes);
      return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);

      // 1 up to 24 hours
    } else if (unit === "hour") {
      const hours = roundingMethod(minutes / 60);
      return locale.formatDistance("xHours", hours, localizeOptions);

      // 1 up to 30 days
    } else if (unit === "day") {
      const days = roundingMethod(dstNormalizedMinutes / minutesInDay);
      return locale.formatDistance("xDays", days, localizeOptions);

      // 1 up to 12 months
    } else if (unit === "month") {
      const months = roundingMethod(dstNormalizedMinutes / minutesInMonth);
      return months === 12 && defaultUnit !== "month"
        ? locale.formatDistance("xYears", 1, localizeOptions)
        : locale.formatDistance("xMonths", months, localizeOptions);

      // 1 year up to max Date
    } else {
      const years = roundingMethod(dstNormalizedMinutes / minutesInYear);
      return locale.formatDistance("xYears", years, localizeOptions);
    }
  }

  /**
   * The {@link formatDistanceToNow} function options.
   */

  /**
   * @name formatDistanceToNow
   * @category Common Helpers
   * @summary Return the distance between the given date and now in words.
   * @pure false
   *
   * @description
   * Return the distance between the given date and now in words.
   *
   * | Distance to now                                                   | Result              |
   * |-------------------------------------------------------------------|---------------------|
   * | 0 ... 30 secs                                                     | less than a minute  |
   * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
   * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
   * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
   * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
   * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
   * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
   * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
   * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
   * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
   * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
   * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
   * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
   * | N yrs ... N yrs 3 months                                          | about N years       |
   * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
   * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
   *
   * With `options.includeSeconds == true`:
   * | Distance to now     | Result               |
   * |---------------------|----------------------|
   * | 0 secs ... 5 secs   | less than 5 seconds  |
   * | 5 secs ... 10 secs  | less than 10 seconds |
   * | 10 secs ... 20 secs | less than 20 seconds |
   * | 20 secs ... 40 secs | half a minute        |
   * | 40 secs ... 60 secs | less than a minute   |
   * | 60 secs ... 90 secs | 1 minute             |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - The object with options
   *
   * @returns The distance in words
   *
   * @throws `date` must not be Invalid Date
   * @throws `options.locale` must contain `formatDistance` property
   *
   * @example
   * // If today is 1 January 2015, what is the distance to 2 July 2014?
   * const result = formatDistanceToNow(
   *   new Date(2014, 6, 2)
   * )
   * //=> '6 months'
   *
   * @example
   * // If now is 1 January 2015 00:00:00,
   * // what is the distance to 1 January 2015 00:00:15, including seconds?
   * const result = formatDistanceToNow(
   *   new Date(2015, 0, 1, 0, 0, 15),
   *   {includeSeconds: true}
   * )
   * //=> 'less than 20 seconds'
   *
   * @example
   * // If today is 1 January 2015,
   * // what is the distance to 1 January 2016, with a suffix?
   * const result = formatDistanceToNow(
   *   new Date(2016, 0, 1),
   *   {addSuffix: true}
   * )
   * //=> 'in about 1 year'
   *
   * @example
   * // If today is 1 January 2015,
   * // what is the distance to 1 August 2016 in Esperanto?
   * const eoLocale = require('date-fns/locale/eo')
   * const result = formatDistanceToNow(
   *   new Date(2016, 7, 1),
   *   {locale: eoLocale}
   * )
   * //=> 'pli ol 1 jaro'
   */
  function formatDistanceToNow(date, options) {
    return formatDistance(date, Date.now(), options);
  }

  /**
   * The {@link formatDistanceToNowStrict} function options.
   */

  /**
   * @name formatDistanceToNowStrict
   * @category Common Helpers
   * @summary Return the distance between the given date and now in words.
   * @pure false
   *
   * @description
   * Return the distance between the given dates in words, using strict units.
   * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
   * 'less than' and the like.
   *
   * | Distance between dates | Result              |
   * |------------------------|---------------------|
   * | 0 ... 59 secs          | [0..59] seconds     |
   * | 1 ... 59 mins          | [1..59] minutes     |
   * | 1 ... 23 hrs           | [1..23] hours       |
   * | 1 ... 29 days          | [1..29] days        |
   * | 1 ... 11 months        | [1..11] months      |
   * | 1 ... N years          | [1..N]  years       |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - An object with options.
   *
   * @returns The distance in words
   *
   * @throws `date` must not be Invalid Date
   * @throws `options.locale` must contain `formatDistance` property
   *
   * @example
   * // If today is 1 January 2015, what is the distance to 2 July 2014?
   * const result = formatDistanceToNowStrict(
   *   new Date(2014, 6, 2)
   * )
   * //=> '6 months'
   *
   * @example
   * // If now is 1 January 2015 00:00:00,
   * // what is the distance to 1 January 2015 00:00:15, including seconds?
   * const result = formatDistanceToNowStrict(
   *   new Date(2015, 0, 1, 0, 0, 15)
   * )
   * //=> '15 seconds'
   *
   * @example
   * // If today is 1 January 2015,
   * // what is the distance to 1 January 2016, with a suffix?
   * const result = formatDistanceToNowStrict(
   *   new Date(2016, 0, 1),
   *   {addSuffix: true}
   * )
   * //=> 'in 1 year'
   *
   * @example
   * // If today is 28 January 2015,
   * // what is the distance to 1 January 2015, in months, rounded up??
   * const result = formatDistanceToNowStrict(new Date(2015, 0, 1), {
   *   unit: 'month',
   *   roundingMethod: 'ceil'
   * })
   * //=> '1 month'
   *
   * @example
   * // If today is 1 January 2015,
   * // what is the distance to 1 January 2016 in Esperanto?
   * const eoLocale = require('date-fns/locale/eo')
   * const result = formatDistanceToNowStrict(
   *   new Date(2016, 0, 1),
   *   {locale: eoLocale}
   * )
   * //=> '1 jaro'
   */
  function formatDistanceToNowStrict(date, options) {
    return formatDistanceStrict(date, Date.now(), options);
  }

  /**
   * The {@link formatDuration} function options.
   */

  const defaultFormat = [
    "years",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
  ];

  /**
   * @name formatDuration
   * @category Common Helpers
   * @summary Formats a duration in human-readable format
   *
   * @description
   * Return human-readable duration string i.e. "9 months 2 days"
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param duration - The duration to format
   * @param options - An object with options.
   *
   * @returns The formatted date string
   *
   * @example
   * // Format full duration
   * formatDuration({
   *   years: 2,
   *   months: 9,
   *   weeks: 1,
   *   days: 7,
   *   hours: 5,
   *   minutes: 9,
   *   seconds: 30
   * })
   * //=> '2 years 9 months 1 week 7 days 5 hours 9 minutes 30 seconds'
   *
   * @example
   * // Format partial duration
   * formatDuration({ months: 9, days: 2 })
   * //=> '9 months 2 days'
   *
   * @example
   * // Customize the format
   * formatDuration(
   *   {
   *     years: 2,
   *     months: 9,
   *     weeks: 1,
   *     days: 7,
   *     hours: 5,
   *     minutes: 9,
   *     seconds: 30
   *   },
   *   { format: ['months', 'weeks'] }
   * ) === '9 months 1 week'
   *
   * @example
   * // Customize the zeros presence
   * formatDuration({ years: 0, months: 9 })
   * //=> '9 months'
   * formatDuration({ years: 0, months: 9 }, { zero: true })
   * //=> '0 years 9 months'
   *
   * @example
   * // Customize the delimiter
   * formatDuration({ years: 2, months: 9, weeks: 3 }, { delimiter: ', ' })
   * //=> '2 years, 9 months, 3 weeks'
   */
  function formatDuration(duration, options) {
    const defaultOptions = getDefaultOptions$1();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;
    const format = options?.format ?? defaultFormat;
    const zero = options?.zero ?? false;
    const delimiter = options?.delimiter ?? " ";

    if (!locale.formatDistance) {
      return "";
    }

    const result = format
      .reduce((acc, unit) => {
        const token = `x${unit.replace(/(^.)/, (m) => m.toUpperCase())}`;
        const value = duration[unit];
        if (value !== undefined && (zero || duration[unit])) {
          return acc.concat(locale.formatDistance(token, value));
        }
        return acc;
      }, [])
      .join(delimiter);

    return result;
  }

  /**
   * The {@link formatISO} function options.
   */

  /**
   * @name formatISO
   * @category Common Helpers
   * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
   *
   * @description
   * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options.
   *
   * @returns The formatted date string (in loca.l time zone)
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
   * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
   * //=> '2019-09-18T19:00:52Z'
   *
   * @example
   * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
   * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
   * //=> '20190918T190052'
   *
   * @example
   * // Represent 18 September 2019 in ISO 8601 format, date only:
   * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
   * //=> '2019-09-18'
   *
   * @example
   * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
   * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
   * //=> '19:00:52Z'
   */
  function formatISO(date, options) {
    const _date = toDate(date);

    if (isNaN(_date.getTime())) {
      throw new RangeError("Invalid time value");
    }

    const format = options?.format ?? "extended";
    const representation = options?.representation ?? "complete";

    let result = "";
    let tzOffset = "";

    const dateDelimiter = format === "extended" ? "-" : "";
    const timeDelimiter = format === "extended" ? ":" : "";

    // Representation is either 'date' or 'complete'
    if (representation !== "time") {
      const day = addLeadingZeros(_date.getDate(), 2);
      const month = addLeadingZeros(_date.getMonth() + 1, 2);
      const year = addLeadingZeros(_date.getFullYear(), 4);

      // yyyyMMdd or yyyy-MM-dd.
      result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
    }

    // Representation is either 'time' or 'complete'
    if (representation !== "date") {
      // Add the timezone.
      const offset = _date.getTimezoneOffset();

      if (offset !== 0) {
        const absoluteOffset = Math.abs(offset);
        const hourOffset = addLeadingZeros(Math.floor(absoluteOffset / 60), 2);
        const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
        // If less than 0, the sign is +, because it is ahead of time.
        const sign = offset < 0 ? "+" : "-";

        tzOffset = `${sign}${hourOffset}:${minuteOffset}`;
      } else {
        tzOffset = "Z";
      }

      const hour = addLeadingZeros(_date.getHours(), 2);
      const minute = addLeadingZeros(_date.getMinutes(), 2);
      const second = addLeadingZeros(_date.getSeconds(), 2);

      // If there's also date, separate it with time with 'T'
      const separator = result === "" ? "" : "T";

      // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
      const time = [hour, minute, second].join(timeDelimiter);

      // HHmmss or HH:mm:ss.
      result = `${result}${separator}${time}${tzOffset}`;
    }

    return result;
  }

  /**
   * The {@link formatISO9075} function options.
   */

  /**
   * @name formatISO9075
   * @category Common Helpers
   * @summary Format the date according to the ISO 9075 standard (https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_get-format).
   *
   * @description
   * Return the formatted date string in ISO 9075 format. Options may be passed to control the parts and notations of the date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options.
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 18 September 2019 in ISO 9075 format:
   * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52))
   * //=> '2019-09-18 19:00:52'
   *
   * @example
   * // Represent 18 September 2019 in ISO 9075, short format:
   * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
   * //=> '20190918 190052'
   *
   * @example
   * // Represent 18 September 2019 in ISO 9075 format, date only:
   * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
   * //=> '2019-09-18'
   *
   * @example
   * // Represent 18 September 2019 in ISO 9075 format, time only:
   * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
   * //=> '19:00:52'
   */
  function formatISO9075(date, options) {
    const _date = toDate(date);

    if (!isValid(_date)) {
      throw new RangeError("Invalid time value");
    }

    const format = options?.format ?? "extended";
    const representation = options?.representation ?? "complete";

    let result = "";

    const dateDelimiter = format === "extended" ? "-" : "";
    const timeDelimiter = format === "extended" ? ":" : "";

    // Representation is either 'date' or 'complete'
    if (representation !== "time") {
      const day = addLeadingZeros(_date.getDate(), 2);
      const month = addLeadingZeros(_date.getMonth() + 1, 2);
      const year = addLeadingZeros(_date.getFullYear(), 4);

      // yyyyMMdd or yyyy-MM-dd.
      result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
    }

    // Representation is either 'time' or 'complete'
    if (representation !== "date") {
      const hour = addLeadingZeros(_date.getHours(), 2);
      const minute = addLeadingZeros(_date.getMinutes(), 2);
      const second = addLeadingZeros(_date.getSeconds(), 2);

      // If there's also date, separate it with time with a space
      const separator = result === "" ? "" : " ";

      // HHmmss or HH:mm:ss.
      result = `${result}${separator}${hour}${timeDelimiter}${minute}${timeDelimiter}${second}`;
    }

    return result;
  }

  /**
   * @name formatISODuration
   * @category Common Helpers
   * @summary Format a duration object according as ISO 8601 duration string
   *
   * @description
   * Format a duration object according to the ISO 8601 duration standard (https://www.digi.com/resources/documentation/digidocs//90001488-13/reference/r_iso_8601_duration_format.htm)
   *
   * @param duration - The duration to format
   *
   * @returns The ISO 8601 duration string
   *
   * @example
   * // Format the given duration as ISO 8601 string
   * const result = formatISODuration({
   *   years: 39,
   *   months: 2,
   *   days: 20,
   *   hours: 7,
   *   minutes: 5,
   *   seconds: 0
   * })
   * //=> 'P39Y2M20DT0H0M0S'
   */
  function formatISODuration(duration) {
    const {
      years = 0,
      months = 0,
      days = 0,
      hours = 0,
      minutes = 0,
      seconds = 0,
    } = duration;

    return `P${years}Y${months}M${days}DT${hours}H${minutes}M${seconds}S`;
  }

  /**
   * The {@link formatRFC3339} function options.
   */

  /**
   * @name formatRFC3339
   * @category Common Helpers
   * @summary Format the date according to the RFC 3339 standard (https://tools.ietf.org/html/rfc3339#section-5.6).
   *
   * @description
   * Return the formatted date string in RFC 3339 format. Options may be passed to control the parts and notations of the date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options.
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 18 September 2019 in RFC 3339 format:
   * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52))
   * //=> '2019-09-18T19:00:52Z'
   *
   * @example
   * // Represent 18 September 2019 in RFC 3339 format, 3 digits of second fraction
   * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), {
   *   fractionDigits: 3
   * })
   * //=> '2019-09-18T19:00:52.234Z'
   */
  function formatRFC3339(date, options) {
    const _date = toDate(date);

    if (!isValid(_date)) {
      throw new RangeError("Invalid time value");
    }

    const fractionDigits = options?.fractionDigits ?? 0;

    const day = addLeadingZeros(_date.getDate(), 2);
    const month = addLeadingZeros(_date.getMonth() + 1, 2);
    const year = _date.getFullYear();

    const hour = addLeadingZeros(_date.getHours(), 2);
    const minute = addLeadingZeros(_date.getMinutes(), 2);
    const second = addLeadingZeros(_date.getSeconds(), 2);

    let fractionalSecond = "";
    if (fractionDigits > 0) {
      const milliseconds = _date.getMilliseconds();
      const fractionalSeconds = Math.floor(
        milliseconds * Math.pow(10, fractionDigits - 3),
      );
      fractionalSecond = "." + addLeadingZeros(fractionalSeconds, fractionDigits);
    }

    let offset = "";
    const tzOffset = _date.getTimezoneOffset();

    if (tzOffset !== 0) {
      const absoluteOffset = Math.abs(tzOffset);
      const hourOffset = addLeadingZeros(Math.trunc(absoluteOffset / 60), 2);
      const minuteOffset = addLeadingZeros(absoluteOffset % 60, 2);
      // If less than 0, the sign is +, because it is ahead of time.
      const sign = tzOffset < 0 ? "+" : "-";

      offset = `${sign}${hourOffset}:${minuteOffset}`;
    } else {
      offset = "Z";
    }

    return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}${offset}`;
  }

  const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

  const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];

  /**
   * @name formatRFC7231
   * @category Common Helpers
   * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).
   *
   * @description
   * Return the formatted date string in RFC 7231 format.
   * The result will always be in UTC timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 18 September 2019 in RFC 7231 format:
   * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))
   * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'
   */
  function formatRFC7231(date) {
    const _date = toDate(date);

    if (!isValid(_date)) {
      throw new RangeError("Invalid time value");
    }

    const dayName = days[_date.getUTCDay()];
    const dayOfMonth = addLeadingZeros(_date.getUTCDate(), 2);
    const monthName = months[_date.getUTCMonth()];
    const year = _date.getUTCFullYear();

    const hour = addLeadingZeros(_date.getUTCHours(), 2);
    const minute = addLeadingZeros(_date.getUTCMinutes(), 2);
    const second = addLeadingZeros(_date.getUTCSeconds(), 2);

    // Result variables.
    return `${dayName}, ${dayOfMonth} ${monthName} ${year} ${hour}:${minute}:${second} GMT`;
  }

  /**
   * The {@link formatRelative} function options.
   */

  /**
   * @name formatRelative
   * @category Common Helpers
   * @summary Represent the date in words relative to the given base date.
   *
   * @description
   * Represent the date in words relative to the given base date.
   *
   * | Distance to the base date | Result                    |
   * |---------------------------|---------------------------|
   * | Previous 6 days           | last Sunday at 04:30 AM   |
   * | Last day                  | yesterday at 04:30 AM     |
   * | Same day                  | today at 04:30 AM         |
   * | Next day                  | tomorrow at 04:30 AM      |
   * | Next 6 days               | Sunday at 04:30 AM        |
   * | Other                     | 12/31/2017                |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to format
   * @param baseDate - The date to compare with
   * @param options - An object with options
   *
   * @returns The date in words
   *
   * @throws `date` must not be Invalid Date
   * @throws `baseDate` must not be Invalid Date
   * @throws `options.locale` must contain `localize` property
   * @throws `options.locale` must contain `formatLong` property
   * @throws `options.locale` must contain `formatRelative` property
   *
   * @example
   * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
   * const result = formatRelative(subDays(new Date(), 6), new Date())
   * //=> "last Thursday at 12:45 AM"
   */
  function formatRelative(date, baseDate, options) {
    const _date = toDate(date);
    const _baseDate = toDate(baseDate);

    const defaultOptions = getDefaultOptions$1();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const diff = differenceInCalendarDays(_date, _baseDate);

    if (isNaN(diff)) {
      throw new RangeError("Invalid time value");
    }

    let token;
    if (diff < -6) {
      token = "other";
    } else if (diff < -1) {
      token = "lastWeek";
    } else if (diff < 0) {
      token = "yesterday";
    } else if (diff < 1) {
      token = "today";
    } else if (diff < 2) {
      token = "tomorrow";
    } else if (diff < 7) {
      token = "nextWeek";
    } else {
      token = "other";
    }

    const formatStr = locale.formatRelative(token, _date, _baseDate, {
      locale,
      weekStartsOn,
    });
    return format(_date, formatStr, { locale, weekStartsOn });
  }

  /**
   * @name fromUnixTime
   * @category Timestamp Helpers
   * @summary Create a date from a Unix timestamp.
   *
   * @description
   * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
   *
   * @param unixTime - The given Unix timestamp (in seconds)
   *
   * @returns The date
   *
   * @example
   * // Create the date 29 February 2012 11:45:05:
   * const result = fromUnixTime(1330515905)
   * //=> Wed Feb 29 2012 11:45:05
   */
  function fromUnixTime(unixTime) {
    return toDate(unixTime * 1000);
  }

  /**
   * @name getDate
   * @category Day Helpers
   * @summary Get the day of the month of the given date.
   *
   * @description
   * Get the day of the month of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The day of month
   *
   * @example
   * // Which day of the month is 29 February 2012?
   * const result = getDate(new Date(2012, 1, 29))
   * //=> 29
   */
  function getDate(date) {
    const _date = toDate(date);
    const dayOfMonth = _date.getDate();
    return dayOfMonth;
  }

  /**
   * @name getDay
   * @category Weekday Helpers
   * @summary Get the day of the week of the given date.
   *
   * @description
   * Get the day of the week of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The day of week, 0 represents Sunday
   *
   * @example
   * // Which day of the week is 29 February 2012?
   * const result = getDay(new Date(2012, 1, 29))
   * //=> 3
   */
  function getDay(date) {
    const _date = toDate(date);
    const day = _date.getDay();
    return day;
  }

  /**
   * @name getDaysInMonth
   * @category Month Helpers
   * @summary Get the number of days in a month of the given date.
   *
   * @description
   * Get the number of days in a month of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The number of days in a month
   *
   * @example
   * // How many days are in February 2000?
   * const result = getDaysInMonth(new Date(2000, 1))
   * //=> 29
   */
  function getDaysInMonth(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const monthIndex = _date.getMonth();
    const lastDayOfMonth = constructFrom(date, 0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }

  /**
   * @name isLeapYear
   * @category Year Helpers
   * @summary Is the given date in the leap year?
   *
   * @description
   * Is the given date in the leap year?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in the leap year
   *
   * @example
   * // Is 1 September 2012 in the leap year?
   * const result = isLeapYear(new Date(2012, 8, 1))
   * //=> true
   */
  function isLeapYear(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
  }

  /**
   * @name getDaysInYear
   * @category Year Helpers
   * @summary Get the number of days in a year of the given date.
   *
   * @description
   * Get the number of days in a year of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The number of days in a year
   *
   * @example
   * // How many days are in 2012?
   * const result = getDaysInYear(new Date(2012, 0, 1))
   * //=> 366
   */
  function getDaysInYear(date) {
    const _date = toDate(date);

    if (String(new Date(_date)) === "Invalid Date") {
      return NaN;
    }

    return isLeapYear(_date) ? 366 : 365;
  }

  /**
   * @name getDecade
   * @category Decade Helpers
   * @summary Get the decade of the given date.
   *
   * @description
   * Get the decade of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The year of decade
   *
   * @example
   * // Which decade belongs 27 November 1942?
   * const result = getDecade(new Date(1942, 10, 27))
   * //=> 1940
   */
  function getDecade(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const decade = Math.floor(year / 10) * 10;
    return decade;
  }

  /**
   * @name getDefaultOptions
   * @category Common Helpers
   * @summary Get default options.
   * @pure false
   *
   * @description
   * Returns an object that contains defaults for
   * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
   * arguments for all functions.
   *
   * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
   *
   * @returns The default options
   *
   * @example
   * const result = getDefaultOptions()
   * //=> {}
   *
   * @example
   * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
   * const result = getDefaultOptions()
   * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
   */
  function getDefaultOptions() {
    return Object.assign({}, getDefaultOptions$1());
  }

  /**
   * @name getHours
   * @category Hour Helpers
   * @summary Get the hours of the given date.
   *
   * @description
   * Get the hours of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The hours
   *
   * @example
   * // Get the hours of 29 February 2012 11:45:00:
   * const result = getHours(new Date(2012, 1, 29, 11, 45))
   * //=> 11
   */
  function getHours(date) {
    const _date = toDate(date);
    const hours = _date.getHours();
    return hours;
  }

  /**
   * @name getISODay
   * @category Weekday Helpers
   * @summary Get the day of the ISO week of the given date.
   *
   * @description
   * Get the day of the ISO week of the given date,
   * which is 7 for Sunday, 1 for Monday etc.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The day of ISO week
   *
   * @example
   * // Which day of the ISO week is 26 February 2012?
   * const result = getISODay(new Date(2012, 1, 26))
   * //=> 7
   */
  function getISODay(date) {
    const _date = toDate(date);
    let day = _date.getDay();

    if (day === 0) {
      day = 7;
    }

    return day;
  }

  /**
   * @name getISOWeeksInYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Get the number of weeks in an ISO week-numbering year of the given date.
   *
   * @description
   * Get the number of weeks in an ISO week-numbering year of the given date.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The number of ISO weeks in a year
   *
   * @example
   * // How many weeks are in ISO week-numbering year 2015?
   * const result = getISOWeeksInYear(new Date(2015, 1, 11))
   * //=> 53
   */
  function getISOWeeksInYear(date) {
    const thisYear = startOfISOWeekYear(date);
    const nextYear = startOfISOWeekYear(addWeeks(thisYear, 60));
    const diff = nextYear.valueOf() - thisYear.valueOf();
    // Round the number of weeks to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / millisecondsInWeek);
  }

  /**
   * @name getMilliseconds
   * @category Millisecond Helpers
   * @summary Get the milliseconds of the given date.
   *
   * @description
   * Get the milliseconds of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The milliseconds
   *
   * @example
   * // Get the milliseconds of 29 February 2012 11:45:05.123:
   * const result = getMilliseconds(new Date(2012, 1, 29, 11, 45, 5, 123))
   * //=> 123
   */
  function getMilliseconds(date) {
    const _date = toDate(date);
    const milliseconds = _date.getMilliseconds();
    return milliseconds;
  }

  /**
   * @name getMinutes
   * @category Minute Helpers
   * @summary Get the minutes of the given date.
   *
   * @description
   * Get the minutes of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The minutes
   *
   * @example
   * // Get the minutes of 29 February 2012 11:45:05:
   * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
   * //=> 45
   */
  function getMinutes(date) {
    const _date = toDate(date);
    const minutes = _date.getMinutes();
    return minutes;
  }

  /**
   * @name getMonth
   * @category Month Helpers
   * @summary Get the month of the given date.
   *
   * @description
   * Get the month of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The month
   *
   * @example
   * // Which month is 29 February 2012?
   * const result = getMonth(new Date(2012, 1, 29))
   * //=> 1
   */
  function getMonth(date) {
    const _date = toDate(date);
    const month = _date.getMonth();
    return month;
  }

  /**
   * @name getOverlappingDaysInIntervals
   * @category Interval Helpers
   * @summary Get the number of days that overlap in two time intervals
   *
   * @description
   * Get the number of days that overlap in two time intervals
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param intervalLeft - The first interval to compare.
   * @param intervalRight - The second interval to compare.
   *
   * @returns The number of days that overlap in two time intervals
   *
   * @example
   * // For overlapping time intervals adds 1 for each started overlapping day:
   * getOverlappingDaysInIntervals(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
   * )
   * //=> 3
   *
   * @example
   * // For non-overlapping time intervals returns 0:
   * getOverlappingDaysInIntervals(
   *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
   *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
   * )
   * //=> 0
   */

  function getOverlappingDaysInIntervals(intervalLeft, intervalRight) {
    const [leftStartTime, leftEndTime] = [
      +toDate(intervalLeft.start),
      +toDate(intervalLeft.end),
    ].sort();
    const [rightStartTime, rightEndTime] = [
      +toDate(intervalRight.start),
      +toDate(intervalRight.end),
    ].sort();

    const isOverlapping =
      leftStartTime < rightEndTime && rightStartTime < leftEndTime;

    if (!isOverlapping) {
      return 0;
    }

    const overlapStartDate =
      rightStartTime < leftStartTime ? leftStartTime : rightStartTime;

    const overlapEndDate =
      rightEndTime > leftEndTime ? leftEndTime : rightEndTime;

    const differenceInMs = overlapEndDate - overlapStartDate;

    return Math.ceil(differenceInMs / millisecondsInDay);
  }

  /**
   * @name getSeconds
   * @category Second Helpers
   * @summary Get the seconds of the given date.
   *
   * @description
   * Get the seconds of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The seconds
   *
   * @example
   * // Get the seconds of 29 February 2012 11:45:05.123:
   * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
   * //=> 5
   */
  function getSeconds(date) {
    const _date = toDate(date);
    const seconds = _date.getSeconds();
    return seconds;
  }

  /**
   * @name getTime
   * @category Timestamp Helpers
   * @summary Get the milliseconds timestamp of the given date.
   *
   * @description
   * Get the milliseconds timestamp of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The timestamp
   *
   * @example
   * // Get the timestamp of 29 February 2012 11:45:05.123:
   * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
   * //=> 1330515905123
   */
  function getTime(date) {
    const _date = toDate(date);
    const timestamp = _date.getTime();
    return timestamp;
  }

  /**
   * @name getUnixTime
   * @category Timestamp Helpers
   * @summary Get the seconds timestamp of the given date.
   *
   * @description
   * Get the seconds timestamp of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The timestamp
   *
   * @example
   * // Get the timestamp of 29 February 2012 11:45:05 CET:
   * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
   * //=> 1330512305
   */
  function getUnixTime(date) {
    return Math.floor(getTime(date) / 1000);
  }

  /**
   * The {@link getWeekOfMonth} function options.
   */

  /**
   * @name getWeekOfMonth
   * @category Week Helpers
   * @summary Get the week of the month of the given date.
   *
   * @description
   * Get the week of the month of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - An object with options.
   *
   * @returns The week of month
   *
   * @example
   * // Which week of the month is 9 November 2017?
   * const result = getWeekOfMonth(new Date(2017, 10, 9))
   * //=> 2
   */
  function getWeekOfMonth(date, options) {
    const defaultOptions = getDefaultOptions$1();
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const currentDayOfMonth = getDate(date);
    if (isNaN(currentDayOfMonth)) return NaN;

    const startWeekDay = getDay(startOfMonth(date));

    let lastDayOfFirstWeek = weekStartsOn - startWeekDay;
    if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;

    const remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
    return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
  }

  /**
   * @name lastDayOfMonth
   * @category Month Helpers
   * @summary Return the last day of a month for the given date.
   *
   * @description
   * Return the last day of a month for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The last day of a month
   *
   * @example
   * // The last day of a month for 2 September 2014 11:55:00:
   * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 30 2014 00:00:00
   */
  function lastDayOfMonth(date) {
    const _date = toDate(date);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * The {@link getWeeksInMonth} function options.
   */

  /**
   * @name getWeeksInMonth
   * @category Week Helpers
   * @summary Get the number of calendar weeks a month spans.
   *
   * @description
   * Get the number of calendar weeks the month in the given date spans.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   * @param options - An object with options.
   *
   * @returns The number of calendar weeks
   *
   * @example
   * // How many calendar weeks does February 2015 span?
   * const result = getWeeksInMonth(new Date(2015, 1, 8))
   * //=> 4
   *
   * @example
   * // If the week starts on Monday,
   * // how many calendar weeks does July 2017 span?
   * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
   * //=> 6
   */
  function getWeeksInMonth(date, options) {
    return (
      differenceInCalendarWeeks(
        lastDayOfMonth(date),
        startOfMonth(date),
        options,
      ) + 1
    );
  }

  /**
   * @name getYear
   * @category Year Helpers
   * @summary Get the year of the given date.
   *
   * @description
   * Get the year of the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The given date
   *
   * @returns The year
   *
   * @example
   * // Which year is 2 July 2014?
   * const result = getYear(new Date(2014, 6, 2))
   * //=> 2014
   */
  function getYear(date) {
    return toDate(date).getFullYear();
  }

  /**
   * @name hoursToMilliseconds
   * @category  Conversion Helpers
   * @summary Convert hours to milliseconds.
   *
   * @description
   * Convert a number of hours to a full number of milliseconds.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param hours - number of hours to be converted
   *
   * @returns The number of hours converted to milliseconds
   *
   * @example
   * // Convert 2 hours to milliseconds:
   * const result = hoursToMilliseconds(2)
   * //=> 7200000
   */
  function hoursToMilliseconds(hours) {
    return Math.floor(hours * millisecondsInHour);
  }

  /**
   * @name hoursToMinutes
   * @category Conversion Helpers
   * @summary Convert hours to minutes.
   *
   * @description
   * Convert a number of hours to a full number of minutes.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param hours - number of hours to be converted
   *
   * @returns The number of hours converted in minutes
   *
   * @example
   * // Convert 2 hours to minutes:
   * const result = hoursToMinutes(2)
   * //=> 120
   */
  function hoursToMinutes(hours) {
    return Math.floor(hours * minutesInHour);
  }

  /**
   * @name hoursToSeconds
   * @category Conversion Helpers
   * @summary Convert hours to seconds.
   *
   * @description
   * Convert a number of hours to a full number of seconds.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param hours - The number of hours to be converted
   *
   * @returns The number of hours converted in seconds
   *
   * @example
   * // Convert 2 hours to seconds:
   * const result = hoursToSeconds(2)
   * //=> 7200
   */
  function hoursToSeconds(hours) {
    return Math.floor(hours * secondsInHour);
  }

  /**
   * The {@link interval} function options.
   */

  /**
   * @name interval
   * @category Interval Helpers
   * @summary Creates an interval object and validates its values.
   *
   * @description
   * Creates a normalized interval object and validates its values. If the interval is invalid, an exception is thrown.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param start - The start of the interval.
   * @param end - The end of the interval.
   * @param options - The options object.
   *
   * @throws `Start date is invalid` when `start` is invalid.
   * @throws `End date is invalid` when `end` is invalid.
   * @throws `End date must be after start date` when end is before `start` and `options.assertPositive` is true.
   *
   * @returns The normalized and validated interval object.
   */
  function interval(start, end, options) {
    const _start = toDate(start);
    if (isNaN(+_start)) throw new TypeError("Start date is invalid");

    const _end = toDate(end);
    if (isNaN(+_end)) throw new TypeError("End date is invalid");

    if (options?.assertPositive && +_start > +_end)
      throw new TypeError("End date must be after start date");

    return { start: _start, end: _end };
  }

  /**
   * @name intervalToDuration
   * @category Common Helpers
   * @summary Convert interval to duration
   *
   * @description
   * Convert a interval object to a duration object.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param interval - The interval to convert to duration
   *
   * @returns The duration object
   *
   * @example
   * // Get the duration between January 15, 1929 and April 4, 1968.
   * intervalToDuration({
   *   start: new Date(1929, 0, 15, 12, 0, 0),
   *   end: new Date(1968, 3, 4, 19, 5, 0)
   * })
   * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }
   */
  function intervalToDuration(interval) {
    const start = toDate(interval.start);
    const end = toDate(interval.end);

    const duration = {};

    const years = differenceInYears(end, start);
    if (years) duration.years = years;

    const remainingMonths = add$2(start, { years: duration.years });

    const months = differenceInMonths(end, remainingMonths);
    if (months) duration.months = months;

    const remainingDays = add$2(remainingMonths, { months: duration.months });

    const days = differenceInDays(end, remainingDays);
    if (days) duration.days = days;

    const remainingHours = add$2(remainingDays, { days: duration.days });

    const hours = differenceInHours(end, remainingHours);
    if (hours) duration.hours = hours;

    const remainingMinutes = add$2(remainingHours, { hours: duration.hours });

    const minutes = differenceInMinutes(end, remainingMinutes);
    if (minutes) duration.minutes = minutes;

    const remainingSeconds = add$2(remainingMinutes, { minutes: duration.minutes });

    const seconds = differenceInSeconds(end, remainingSeconds);
    if (seconds) duration.seconds = seconds;

    return duration;
  }

  /**
   * The locale string (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).
   */

  /**
   * The format options (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#options)
   */

  /**
   * The locale options.
   */

  /**
   * @name intlFormat
   * @category Common Helpers
   * @summary Format the date with Intl.DateTimeFormat (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
   *
   * @description
   * Return the formatted date string in the given format.
   * The method uses [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) inside.
   * formatOptions are the same as [`Intl.DateTimeFormat` options](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options)
   *
   * >  Please note that before Node version 13.0.0, only the locale data for en-US is available by default.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to format
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 10 October 2019 in middle-endian format:
   * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456))
   * //=> 10/4/2019
   */

  /**
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to format
   * @param localeOptions - An object with locale
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 10 October 2019 in Korean.
   * // Convert the date with locale's options.
   * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
   *   locale: 'ko-KR',
   * })
   * //=> 2019. 10. 4.
   */

  /**
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to format
   * @param formatOptions - The format options
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 10 October 2019.
   * // Convert the date with format's options.
   * const result = intlFormat.default(new Date(2019, 9, 4, 12, 30, 13, 456), {
   *   year: 'numeric',
   *   month: 'numeric',
   *   day: 'numeric',
   *   hour: 'numeric',
   * })
   * //=> 10/4/2019, 12 PM
   */

  /**
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to format
   * @param formatOptions - The format options
   * @param localeOptions - An object with locale
   *
   * @returns The formatted date string
   *
   * @throws `date` must not be Invalid Date
   *
   * @example
   * // Represent 10 October 2019 in German.
   * // Convert the date with format's options and locale's options.
   * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
   *   weekday: 'long',
   *   year: 'numeric',
   *   month: 'long',
   *   day: 'numeric',
   * }, {
   *   locale: 'de-DE',
   * })
   * //=> Freitag, 4. Oktober 2019
   */

  function intlFormat(date, formatOrLocale, localeOptions) {
    let formatOptions;

    if (isFormatOptions(formatOrLocale)) {
      formatOptions = formatOrLocale;
    } else {
      localeOptions = formatOrLocale;
    }

    return new Intl.DateTimeFormat(localeOptions?.locale, formatOptions).format(
      toDate(date),
    );
  }

  function isFormatOptions(opts) {
    return opts !== undefined && !("locale" in opts);
  }

  /**
   * The {@link intlFormatDistance} function options.
   */

  /**
   * The unit used to format the distance in {@link intlFormatDistance}.
   */

  /**
   * @name intlFormatDistance
   * @category Common Helpers
   * @summary Formats distance between two dates in a human-readable format
   * @description
   * The function calculates the difference between two dates and formats it as a human-readable string.
   *
   * The function will pick the most appropriate unit depending on the distance between dates. For example, if the distance is a few hours, it might return `x hours`. If the distance is a few months, it might return `x months`.
   *
   * You can also specify a unit to force using it regardless of the distance to get a result like `123456 hours`.
   *
   * See the table below for the unit picking logic:
   *
   * | Distance between dates | Result (past)  | Result (future) |
   * | ---------------------- | -------------- | --------------- |
   * | 0 seconds              | now            | now             |
   * | 1-59 seconds           | X seconds ago  | in X seconds    |
   * | 1-59 minutes           | X minutes ago  | in X minutes    |
   * | 1-23 hours             | X hours ago    | in X hours      |
   * | 1 day                  | yesterday      | tomorrow        |
   * | 2-6 days               | X days ago     | in X days       |
   * | 7 days                 | last week      | next week       |
   * | 8 days-1 month         | X weeks ago    | in X weeks      |
   * | 1 month                | last month     | next month      |
   * | 2-3 months             | X months ago   | in X months     |
   * | 1 quarter              | last quarter   | next quarter    |
   * | 2-3 quarters           | X quarters ago | in X quarters   |
   * | 1 year                 | last year      | next year       |
   * | 2+ years               | X years ago    | in X years      |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date
   * @param baseDate - The date to compare with.
   * @param options - An object with options.
   * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)
   * The narrow one could be similar to the short one for some locales.
   *
   * @returns The distance in words according to language-sensitive relative time formatting.
   *
   * @throws `date` must not be Invalid Date
   * @throws `baseDate` must not be Invalid Date
   * @throws `options.unit` must not be invalid Unit
   * @throws `options.locale` must not be invalid locale
   * @throws `options.localeMatcher` must not be invalid localeMatcher
   * @throws `options.numeric` must not be invalid numeric
   * @throws `options.style` must not be invalid style
   *
   * @example
   * // What is the distance between the dates when the fist date is after the second?
   * intlFormatDistance(
   *   new Date(1986, 3, 4, 11, 30, 0),
   *   new Date(1986, 3, 4, 10, 30, 0)
   * )
   * //=> 'in 1 hour'
   *
   * // What is the distance between the dates when the fist date is before the second?
   * intlFormatDistance(
   *   new Date(1986, 3, 4, 10, 30, 0),
   *   new Date(1986, 3, 4, 11, 30, 0)
   * )
   * //=> '1 hour ago'
   *
   * @example
   * // Use the unit option to force the function to output the result in quarters. Without setting it, the example would return "next year"
   * intlFormatDistance(
   *   new Date(1987, 6, 4, 10, 30, 0),
   *   new Date(1986, 3, 4, 10, 30, 0),
   *   { unit: 'quarter' }
   * )
   * //=> 'in 5 quarters'
   *
   * @example
   * // Use the locale option to get the result in Spanish. Without setting it, the example would return "in 1 hour".
   * intlFormatDistance(
   *   new Date(1986, 3, 4, 11, 30, 0),
   *   new Date(1986, 3, 4, 10, 30, 0),
   *   { locale: 'es' }
   * )
   * //=> 'dentro de 1 hora'
   *
   * @example
   * // Use the numeric option to force the function to use numeric values. Without setting it, the example would return "tomorrow".
   * intlFormatDistance(
   *   new Date(1986, 3, 5, 11, 30, 0),
   *   new Date(1986, 3, 4, 11, 30, 0),
   *   { numeric: 'always' }
   * )
   * //=> 'in 1 day'
   *
   * @example
   * // Use the style option to force the function to use short values. Without setting it, the example would return "in 2 years".
   * intlFormatDistance(
   *   new Date(1988, 3, 4, 11, 30, 0),
   *   new Date(1986, 3, 4, 11, 30, 0),
   *   { style: 'short' }
   * )
   * //=> 'in 2 yr'
   */
  function intlFormatDistance(date, baseDate, options) {
    let value = 0;
    let unit;
    const dateLeft = toDate(date);
    const dateRight = toDate(baseDate);

    if (!options?.unit) {
      // Get the unit based on diffInSeconds calculations if no unit is specified
      const diffInSeconds = differenceInSeconds(dateLeft, dateRight); // The smallest unit

      if (Math.abs(diffInSeconds) < secondsInMinute) {
        value = differenceInSeconds(dateLeft, dateRight);
        unit = "second";
      } else if (Math.abs(diffInSeconds) < secondsInHour) {
        value = differenceInMinutes(dateLeft, dateRight);
        unit = "minute";
      } else if (
        Math.abs(diffInSeconds) < secondsInDay &&
        Math.abs(differenceInCalendarDays(dateLeft, dateRight)) < 1
      ) {
        value = differenceInHours(dateLeft, dateRight);
        unit = "hour";
      } else if (
        Math.abs(diffInSeconds) < secondsInWeek &&
        (value = differenceInCalendarDays(dateLeft, dateRight)) &&
        Math.abs(value) < 7
      ) {
        unit = "day";
      } else if (Math.abs(diffInSeconds) < secondsInMonth) {
        value = differenceInCalendarWeeks(dateLeft, dateRight);
        unit = "week";
      } else if (Math.abs(diffInSeconds) < secondsInQuarter) {
        value = differenceInCalendarMonths(dateLeft, dateRight);
        unit = "month";
      } else if (Math.abs(diffInSeconds) < secondsInYear) {
        if (differenceInCalendarQuarters(dateLeft, dateRight) < 4) {
          // To filter out cases that are less than a year but match 4 quarters
          value = differenceInCalendarQuarters(dateLeft, dateRight);
          unit = "quarter";
        } else {
          value = differenceInCalendarYears(dateLeft, dateRight);
          unit = "year";
        }
      } else {
        value = differenceInCalendarYears(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      // Get the value if unit is specified
      unit = options?.unit;
      if (unit === "second") {
        value = differenceInSeconds(dateLeft, dateRight);
      } else if (unit === "minute") {
        value = differenceInMinutes(dateLeft, dateRight);
      } else if (unit === "hour") {
        value = differenceInHours(dateLeft, dateRight);
      } else if (unit === "day") {
        value = differenceInCalendarDays(dateLeft, dateRight);
      } else if (unit === "week") {
        value = differenceInCalendarWeeks(dateLeft, dateRight);
      } else if (unit === "month") {
        value = differenceInCalendarMonths(dateLeft, dateRight);
      } else if (unit === "quarter") {
        value = differenceInCalendarQuarters(dateLeft, dateRight);
      } else if (unit === "year") {
        value = differenceInCalendarYears(dateLeft, dateRight);
      }
    }

    const rtf = new Intl.RelativeTimeFormat(options?.locale, {
      localeMatcher: options?.localeMatcher,
      numeric: options?.numeric || "auto",
      style: options?.style,
    });

    return rtf.format(value, unit);
  }

  /**
   * @name isAfter
   * @category Common Helpers
   * @summary Is the first date after the second one?
   *
   * @description
   * Is the first date after the second one?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date that should be after the other one to return true
   * @param dateToCompare - The date to compare with
   *
   * @returns The first date is after the second date
   *
   * @example
   * // Is 10 July 1989 after 11 February 1987?
   * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> true
   */
  function isAfter(date, dateToCompare) {
    const _date = toDate(date);
    const _dateToCompare = toDate(dateToCompare);
    return _date.getTime() > _dateToCompare.getTime();
  }

  /**
   * @name isBefore
   * @category Common Helpers
   * @summary Is the first date before the second one?
   *
   * @description
   * Is the first date before the second one?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date that should be before the other one to return true
   * @param dateToCompare - The date to compare with
   *
   * @returns The first date is before the second date
   *
   * @example
   * // Is 10 July 1989 before 11 February 1987?
   * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
   * //=> false
   */
  function isBefore(date, dateToCompare) {
    const _date = toDate(date);
    const _dateToCompare = toDate(dateToCompare);
    return +_date < +_dateToCompare;
  }

  /**
   * @name isEqual
   * @category Common Helpers
   * @summary Are the given dates equal?
   *
   * @description
   * Are the given dates equal?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to compare
   * @param dateRight - The second date to compare
   *
   * @returns The dates are equal
   *
   * @example
   * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
   * const result = isEqual(
   *   new Date(2014, 6, 2, 6, 30, 45, 0),
   *   new Date(2014, 6, 2, 6, 30, 45, 500)
   * )
   * //=> false
   */
  function isEqual(leftDate, rightDate) {
    const _dateLeft = toDate(leftDate);
    const _dateRight = toDate(rightDate);
    return +_dateLeft === +_dateRight;
  }

  /**
   * @name isExists
   * @category Common Helpers
   * @summary Is the given date exists?
   *
   * @description
   * Checks if the given arguments convert to an existing date.
   *
   * @param year - The year of the date to check
   * @param month - The month of the date to check
   * @param day - The day of the date to check
   *
   * @returns `true` if the date exists
   *
   * @example
   * // For the valid date:
   * const result = isExists(2018, 0, 31)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * const result = isExists(2018, 1, 31)
   * //=> false
   */
  function isExists(year, month, day) {
    const date = new Date(year, month, day);
    return (
      date.getFullYear() === year &&
      date.getMonth() === month &&
      date.getDate() === day
    );
  }

  /**
   * @name isFirstDayOfMonth
   * @category Month Helpers
   * @summary Is the given date the first day of a month?
   *
   * @description
   * Is the given date the first day of a month?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check

   * @returns The date is the first day of a month
   *
   * @example
   * // Is 1 September 2014 the first day of a month?
   * const result = isFirstDayOfMonth(new Date(2014, 8, 1))
   * //=> true
   */
  function isFirstDayOfMonth(date) {
    return toDate(date).getDate() === 1;
  }

  /**
   * @name isFriday
   * @category Weekday Helpers
   * @summary Is the given date Friday?
   *
   * @description
   * Is the given date Friday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Friday
   *
   * @example
   * // Is 26 September 2014 Friday?
   * const result = isFriday(new Date(2014, 8, 26))
   * //=> true
   */
  function isFriday(date) {
    return toDate(date).getDay() === 5;
  }

  /**
   * @name isFuture
   * @category Common Helpers
   * @summary Is the given date in the future?
   * @pure false
   *
   * @description
   * Is the given date in the future?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in the future
   *
   * @example
   * // If today is 6 October 2014, is 31 December 2014 in the future?
   * const result = isFuture(new Date(2014, 11, 31))
   * //=> true
   */
  function isFuture(date) {
    return +toDate(date) > Date.now();
  }

  /**
   * @name transpose
   * @category Generic Helpers
   * @summary Transpose the date to the given constructor.
   *
   * @description
   * The function transposes the date to the given constructor. It helps you
   * to transpose the date in the system time zone to say `UTCDate` or any other
   * date extension.
   *
   * @typeParam DateInputType - The input `Date` type derived from the passed argument.
   * @typeParam DateOutputType - The output `Date` type derived from the passed constructor.
   *
   * @param fromDate - The date to use values from
   * @param constructor - The date constructor to use
   *
   * @returns Date transposed to the given constructor
   *
   * @example
   * // Create July 10, 2022 00:00 in locale time zone
   * const date = new Date(2022, 6, 10)
   * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
   *
   * @example
   * // Transpose the date to July 10, 2022 00:00 in UTC
   * transpose(date, UTCDate)
   * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
   */
  function transpose$1(fromDate, constructor) {
    const date =
      constructor instanceof Date
        ? constructFrom(constructor, 0)
        : new constructor(0);
    date.setFullYear(
      fromDate.getFullYear(),
      fromDate.getMonth(),
      fromDate.getDate(),
    );
    date.setHours(
      fromDate.getHours(),
      fromDate.getMinutes(),
      fromDate.getSeconds(),
      fromDate.getMilliseconds(),
    );
    return date;
  }

  const TIMEZONE_UNIT_PRIORITY = 10;

  class Setter {
    subPriority = 0;

    validate(_utcDate, _options) {
      return true;
    }
  }

  class ValueSetter extends Setter {
    constructor(
      value,

      validateValue,

      setValue,

      priority,
      subPriority,
    ) {
      super();
      this.value = value;
      this.validateValue = validateValue;
      this.setValue = setValue;
      this.priority = priority;
      if (subPriority) {
        this.subPriority = subPriority;
      }
    }

    validate(date, options) {
      return this.validateValue(date, this.value, options);
    }

    set(date, flags, options) {
      return this.setValue(date, flags, this.value, options);
    }
  }

  class DateToSystemTimezoneSetter extends Setter {
    priority = TIMEZONE_UNIT_PRIORITY;
    subPriority = -1;
    set(date, flags) {
      if (flags.timestampIsSet) return date;
      return constructFrom(date, transpose$1(date, Date));
    }
  }

  class Parser {
    run(dateString, token, match, options) {
      const result = this.parse(dateString, token, match, options);
      if (!result) {
        return null;
      }

      return {
        setter: new ValueSetter(
          result.value,
          this.validate,
          this.set,
          this.priority,
          this.subPriority,
        ),
        rest: result.rest,
      };
    }

    validate(_utcDate, _value, _options) {
      return true;
    }
  }

  class EraParser extends Parser {
    priority = 140;

    parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return (
            match.era(dateString, { width: "abbreviated" }) ||
            match.era(dateString, { width: "narrow" })
          );

        // A, B
        case "GGGGG":
          return match.era(dateString, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return (
            match.era(dateString, { width: "wide" }) ||
            match.era(dateString, { width: "abbreviated" }) ||
            match.era(dateString, { width: "narrow" })
          );
      }
    }

    set(date, flags, value) {
      flags.era = value;
      date.setFullYear(value, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["R", "u", "t", "T"];
  }

  const numericPatterns = {
    month: /^(1[0-2]|0?\d)/, // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/, // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/, // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/, // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/, // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/, // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/, // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/, // 0 to 12
    minute: /^[0-5]?\d/, // 0 to 59
    second: /^[0-5]?\d/, // 0 to 59

    singleDigit: /^\d/, // 0 to 9
    twoDigits: /^\d{1,2}/, // 0 to 99
    threeDigits: /^\d{1,3}/, // 0 to 999
    fourDigits: /^\d{1,4}/, // 0 to 9999

    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/, // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/, // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/, // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/, // 0 to 9999, -0 to -9999
  };

  const timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/,
  };

  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }

    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest,
    };
  }

  function parseNumericPattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);

    if (!matchResult) {
      return null;
    }

    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length),
    };
  }

  function parseTimezonePattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);

    if (!matchResult) {
      return null;
    }

    // Input is 'Z'
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1),
      };
    }

    const sign = matchResult[1] === "+" ? 1 : -1;
    const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

    return {
      value:
        sign *
        (hours * millisecondsInHour +
          minutes * millisecondsInMinute +
          seconds * millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length),
    };
  }

  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
  }

  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
  }

  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
  }

  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }

  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    const isCommonEra = currentYear > 0;
    // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC
    const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

    let result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      const rangeEnd = absCurrentYear + 50;
      const rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }

    return isCommonEra ? result : 1 - result;
  }

  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
  }

  // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
  // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
  // |----------|-------|----|-------|-------|-------|
  // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
  // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
  // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
  // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
  // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
  class YearParser extends Parser {
    priority = 130;
    incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

    parse(dateString, token, match) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "yy",
      });

      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "yo":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "year",
            }),
            valueCallback,
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }

    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }

    set(date, flags, value) {
      const currentYear = date.getFullYear();

      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear,
        );
        date.setFullYear(normalizedTwoDigitYear, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      }

      const year =
        !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setFullYear(year, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }

  // Local week-numbering year
  class LocalWeekYearParser extends Parser {
    priority = 130;

    parse(dateString, token, match) {
      const valueCallback = (year) => ({
        year,
        isTwoDigitYear: token === "YY",
      });

      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback);
        case "Yo":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "year",
            }),
            valueCallback,
          );
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }

    validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }

    set(date, flags, value, options) {
      const currentYear = getWeekYear(date, options);

      if (value.isTwoDigitYear) {
        const normalizedTwoDigitYear = normalizeTwoDigitYear(
          value.year,
          currentYear,
        );
        date.setFullYear(
          normalizedTwoDigitYear,
          0,
          options.firstWeekContainsDate,
        );
        date.setHours(0, 0, 0, 0);
        return startOfWeek(date, options);
      }

      const year =
        !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setFullYear(year, 0, options.firstWeekContainsDate);
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }

    incompatibleTokens = [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T",
    ];
  }

  // ISO week-numbering year
  class ISOWeekYearParser extends Parser {
    priority = 130;

    parse(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }

    set(date, _flags, value) {
      const firstWeekOfYear = constructFrom(date, 0);
      firstWeekOfYear.setFullYear(value, 0, 4);
      firstWeekOfYear.setHours(0, 0, 0, 0);
      return startOfISOWeek(firstWeekOfYear);
    }

    incompatibleTokens = [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  class ExtendedYearParser extends Parser {
    priority = 130;

    parse(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }

    set(date, _flags, value) {
      date.setFullYear(value, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
  }

  class QuarterParser extends Parser {
    priority = 120;

    parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
        case "QQ": // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return match.ordinalNumber(dateString, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return (
            match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.quarter(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );

        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return match.quarter(dateString, {
            width: "narrow",
            context: "formatting",
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return (
            match.quarter(dateString, {
              width: "wide",
              context: "formatting",
            }) ||
            match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.quarter(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 4;
    }

    set(date, _flags, value) {
      date.setMonth((value - 1) * 3, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  class StandAloneQuarterParser extends Parser {
    priority = 120;

    parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case "q":
        case "qq": // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return match.ordinalNumber(dateString, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return (
            match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.quarter(dateString, {
              width: "narrow",
              context: "standalone",
            })
          );

        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return (
            match.quarter(dateString, {
              width: "wide",
              context: "standalone",
            }) ||
            match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.quarter(dateString, {
              width: "narrow",
              context: "standalone",
            })
          );
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 4;
    }

    set(date, _flags, value) {
      date.setMonth((value - 1) * 3, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  class MonthParser extends Parser {
    incompatibleTokens = [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];

    priority = 110;

    parse(dateString, token, match) {
      const valueCallback = (value) => value - 1;

      switch (token) {
        // 1, 2, ..., 12
        case "M":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback,
          );
        // 01, 02, ..., 12
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "month",
            }),
            valueCallback,
          );
        // Jan, Feb, ..., Dec
        case "MMM":
          return (
            match.month(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.month(dateString, { width: "narrow", context: "formatting" })
          );

        // J, F, ..., D
        case "MMMMM":
          return match.month(dateString, {
            width: "narrow",
            context: "formatting",
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return (
            match.month(dateString, { width: "wide", context: "formatting" }) ||
            match.month(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.month(dateString, { width: "narrow", context: "formatting" })
          );
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 11;
    }

    set(date, _flags, value) {
      date.setMonth(value, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
  }

  class StandAloneMonthParser extends Parser {
    priority = 110;

    parse(dateString, token, match) {
      const valueCallback = (value) => value - 1;

      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return mapValue(
            parseNumericPattern(numericPatterns.month, dateString),
            valueCallback,
          );
        // 01, 02, ..., 12
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "month",
            }),
            valueCallback,
          );
        // Jan, Feb, ..., Dec
        case "LLL":
          return (
            match.month(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.month(dateString, { width: "narrow", context: "standalone" })
          );

        // J, F, ..., D
        case "LLLLL":
          return match.month(dateString, {
            width: "narrow",
            context: "standalone",
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return (
            match.month(dateString, { width: "wide", context: "standalone" }) ||
            match.month(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.month(dateString, { width: "narrow", context: "standalone" })
          );
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 11;
    }

    set(date, _flags, value) {
      date.setMonth(value, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  /**
   * The {@link setWeek} function options.
   */

  /**
   * @name setWeek
   * @category Week Helpers
   * @summary Set the local week to the given date.
   *
   * @description
   * Set the local week to the given date, saving the weekday number.
   * The exact calculation depends on the values of
   * `options.weekStartsOn` (which is the index of the first day of the week)
   * and `options.firstWeekContainsDate` (which is the day of January, which is always in
   * the first week of the week-numbering year)
   *
   * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param week - The week of the new date
   * @param options - An object with options
   *
   * @returns The new date with the local week set
   *
   * @example
   * // Set the 1st week to 2 January 2005 with default options:
   * const result = setWeek(new Date(2005, 0, 2), 1)
   * //=> Sun Dec 26 2004 00:00:00
   *
   * @example
   * // Set the 1st week to 2 January 2005,
   * // if Monday is the first day of the week,
   * // and the first week of the year always contains 4 January:
   * const result = setWeek(new Date(2005, 0, 2), 1, {
   *   weekStartsOn: 1,
   *   firstWeekContainsDate: 4
   * })
   * //=> Sun Jan 4 2004 00:00:00
   */
  function setWeek(date, week, options) {
    const _date = toDate(date);
    const diff = getWeek(_date, options) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
  }

  // Local week of year
  class LocalWeekParser extends Parser {
    priority = 100;

    parse(dateString, token, match) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 53;
    }

    set(date, _flags, value, options) {
      return startOfWeek(setWeek(date, value, options), options);
    }

    incompatibleTokens = [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T",
    ];
  }

  /**
   * @name setISOWeek
   * @category ISO Week Helpers
   * @summary Set the ISO week to the given date.
   *
   * @description
   * Set the ISO week to the given date, saving the weekday number.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param week - The ISO week of the new date
   *
   * @returns The new date with the ISO week set
   *
   * @example
   * // Set the 53rd ISO week to 7 August 2004:
   * const result = setISOWeek(new Date(2004, 7, 7), 53)
   * //=> Sat Jan 01 2005 00:00:00
   */
  function setISOWeek(date, week) {
    const _date = toDate(date);
    const diff = getISOWeek(_date) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
  }

  // ISO week of year
  class ISOWeekParser extends Parser {
    priority = 100;

    parse(dateString, token, match) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match.ordinalNumber(dateString, { unit: "week" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 53;
    }

    set(date, _flags, value) {
      return startOfISOWeek(setISOWeek(date, value));
    }

    incompatibleTokens = [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  const DAYS_IN_MONTH_LEAP_YEAR = [
    31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31,
  ];

  // Day of the month
  class DateParser extends Parser {
    priority = 90;
    subPriority = 1;

    parse(dateString, token, match) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(date, value) {
      const year = date.getFullYear();
      const isLeapYear = isLeapYearIndex$1(year);
      const month = date.getMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }

    set(date, _flags, value) {
      date.setDate(value);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  class DayOfYearParser extends Parser {
    priority = 90;

    subpriority = 1;

    parse(dateString, token, match) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match.ordinalNumber(dateString, { unit: "date" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(date, value) {
      const year = date.getFullYear();
      const isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }

    set(date, _flags, value) {
      date.setMonth(0, value);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  /**
   * The {@link setDay} function options.
   */

  /**
   * @name setDay
   * @category Weekday Helpers
   * @summary Set the day of the week to the given date.
   *
   * @description
   * Set the day of the week to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param day - The day of the week of the new date
   * @param options - An object with options.
   *
   * @returns The new date with the day of the week set
   *
   * @example
   * // Set week day to Sunday, with the default weekStartsOn of Sunday:
   * const result = setDay(new Date(2014, 8, 1), 0)
   * //=> Sun Aug 31 2014 00:00:00
   *
   * @example
   * // Set week day to Sunday, with a weekStartsOn of Monday:
   * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
   * //=> Sun Sep 07 2014 00:00:00
   */
  function setDay(date, day, options) {
    const defaultOptions = getDefaultOptions$1();
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const _date = toDate(date);
    const currentDay = _date.getDay();

    const remainder = day % 7;
    const dayIndex = (remainder + 7) % 7;

    const delta = 7 - weekStartsOn;
    const diff =
      day < 0 || day > 6
        ? day - ((currentDay + delta) % 7)
        : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
    return addDays(_date, diff);
  }

  // Day of week
  class DayParser extends Parser {
    priority = 90;

    parse(dateString, token, match) {
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return (
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );

        // T
        case "EEEEE":
          return match.day(dateString, {
            width: "narrow",
            context: "formatting",
          });
        // Tu
        case "EEEEEE":
          return (
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );

        // Tuesday
        case "EEEE":
        default:
          return (
            match.day(dateString, { width: "wide", context: "formatting" }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 6;
    }

    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
  }

  // Local day of week
  class LocalDayParser extends Parser {
    priority = 90;
    parse(dateString, token, match, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
      };

      switch (token) {
        // 3
        case "e":
        case "ee": // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case "eo":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "day",
            }),
            valueCallback,
          );
        // Tue
        case "eee":
          return (
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );

        // T
        case "eeeee":
          return match.day(dateString, {
            width: "narrow",
            context: "formatting",
          });
        // Tu
        case "eeeeee":
          return (
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );

        // Tuesday
        case "eeee":
        default:
          return (
            match.day(dateString, { width: "wide", context: "formatting" }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.day(dateString, { width: "short", context: "formatting" }) ||
            match.day(dateString, { width: "narrow", context: "formatting" })
          );
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 6;
    }

    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T",
    ];
  }

  // Stand-alone local day of week
  class StandAloneLocalDayParser extends Parser {
    priority = 90;

    parse(dateString, token, match, options) {
      const valueCallback = (value) => {
        const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return ((value + options.weekStartsOn + 6) % 7) + wholeWeekDays;
      };

      switch (token) {
        // 3
        case "c":
        case "cc": // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd
        case "co":
          return mapValue(
            match.ordinalNumber(dateString, {
              unit: "day",
            }),
            valueCallback,
          );
        // Tue
        case "ccc":
          return (
            match.day(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.day(dateString, { width: "short", context: "standalone" }) ||
            match.day(dateString, { width: "narrow", context: "standalone" })
          );

        // T
        case "ccccc":
          return match.day(dateString, {
            width: "narrow",
            context: "standalone",
          });
        // Tu
        case "cccccc":
          return (
            match.day(dateString, { width: "short", context: "standalone" }) ||
            match.day(dateString, { width: "narrow", context: "standalone" })
          );

        // Tuesday
        case "cccc":
        default:
          return (
            match.day(dateString, { width: "wide", context: "standalone" }) ||
            match.day(dateString, {
              width: "abbreviated",
              context: "standalone",
            }) ||
            match.day(dateString, { width: "short", context: "standalone" }) ||
            match.day(dateString, { width: "narrow", context: "standalone" })
          );
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 6;
    }

    set(date, _flags, value, options) {
      date = setDay(date, value, options);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T",
    ];
  }

  /**
   * @name setISODay
   * @category Weekday Helpers
   * @summary Set the day of the ISO week to the given date.
   *
   * @description
   * Set the day of the ISO week to the given date.
   * ISO week starts with Monday.
   * 7 is the index of Sunday, 1 is the index of Monday etc.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param day - The day of the ISO week of the new date
   *
   * @returns The new date with the day of the ISO week set
   *
   * @example
   * // Set Sunday to 1 September 2014:
   * const result = setISODay(new Date(2014, 8, 1), 7)
   * //=> Sun Sep 07 2014 00:00:00
   */
  function setISODay(date, day) {
    const _date = toDate(date);
    const currentDay = getISODay(_date);
    const diff = day - currentDay;
    return addDays(_date, diff);
  }

  // ISO day of week
  class ISODayParser extends Parser {
    priority = 90;

    parse(dateString, token, match) {
      const valueCallback = (value) => {
        if (value === 0) {
          return 7;
        }
        return value;
      };

      switch (token) {
        // 2
        case "i":
        case "ii": // 02
          return parseNDigits(token.length, dateString);
        // 2nd
        case "io":
          return match.ordinalNumber(dateString, { unit: "day" });
        // Tue
        case "iii":
          return mapValue(
            match.day(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
              match.day(dateString, {
                width: "short",
                context: "formatting",
              }) ||
              match.day(dateString, {
                width: "narrow",
                context: "formatting",
              }),
            valueCallback,
          );
        // T
        case "iiiii":
          return mapValue(
            match.day(dateString, {
              width: "narrow",
              context: "formatting",
            }),
            valueCallback,
          );
        // Tu
        case "iiiiii":
          return mapValue(
            match.day(dateString, {
              width: "short",
              context: "formatting",
            }) ||
              match.day(dateString, {
                width: "narrow",
                context: "formatting",
              }),
            valueCallback,
          );
        // Tuesday
        case "iiii":
        default:
          return mapValue(
            match.day(dateString, {
              width: "wide",
              context: "formatting",
            }) ||
              match.day(dateString, {
                width: "abbreviated",
                context: "formatting",
              }) ||
              match.day(dateString, {
                width: "short",
                context: "formatting",
              }) ||
              match.day(dateString, {
                width: "narrow",
                context: "formatting",
              }),
            valueCallback,
          );
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 7;
    }

    set(date, _flags, value) {
      date = setISODay(date, value);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    incompatibleTokens = [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T",
    ];
  }

  class AMPMParser extends Parser {
    priority = 80;

    parse(dateString, token, match) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return (
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );

        case "aaaaa":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          });
        case "aaaa":
        default:
          return (
            match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );
      }
    }

    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
  }

  class AMPMMidnightParser extends Parser {
    priority = 80;

    parse(dateString, token, match) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return (
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );

        case "bbbbb":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          });
        case "bbbb":
        default:
          return (
            match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );
      }
    }

    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
  }

  // in the morning, in the afternoon, in the evening, at night
  class DayPeriodParser extends Parser {
    priority = 80;

    parse(dateString, token, match) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return (
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );

        case "BBBBB":
          return match.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting",
          });
        case "BBBB":
        default:
          return (
            match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting",
            }) ||
            match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting",
            })
          );
      }
    }

    set(date, _flags, value) {
      date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["a", "b", "t", "T"];
  }

  class Hour1to12Parser extends Parser {
    priority = 70;

    parse(dateString, token, match) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 12;
    }

    set(date, _flags, value) {
      const isPM = date.getHours() >= 12;
      if (isPM && value < 12) {
        date.setHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setHours(0, 0, 0, 0);
      } else {
        date.setHours(value, 0, 0, 0);
      }
      return date;
    }

    incompatibleTokens = ["H", "K", "k", "t", "T"];
  }

  class Hour0to23Parser extends Parser {
    priority = 70;

    parse(dateString, token, match) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 23;
    }

    set(date, _flags, value) {
      date.setHours(value, 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
  }

  class Hour0To11Parser extends Parser {
    priority = 70;

    parse(dateString, token, match) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 11;
    }

    set(date, _flags, value) {
      const isPM = date.getHours() >= 12;
      if (isPM && value < 12) {
        date.setHours(value + 12, 0, 0, 0);
      } else {
        date.setHours(value, 0, 0, 0);
      }
      return date;
    }

    incompatibleTokens = ["h", "H", "k", "t", "T"];
  }

  class Hour1To24Parser extends Parser {
    priority = 70;

    parse(dateString, token, match) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match.ordinalNumber(dateString, { unit: "hour" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 1 && value <= 24;
    }

    set(date, _flags, value) {
      const hours = value <= 24 ? value % 24 : value;
      date.setHours(hours, 0, 0, 0);
      return date;
    }

    incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
  }

  class MinuteParser extends Parser {
    priority = 60;

    parse(dateString, token, match) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match.ordinalNumber(dateString, { unit: "minute" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 59;
    }

    set(date, _flags, value) {
      date.setMinutes(value, 0, 0);
      return date;
    }

    incompatibleTokens = ["t", "T"];
  }

  class SecondParser extends Parser {
    priority = 50;

    parse(dateString, token, match) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match.ordinalNumber(dateString, { unit: "second" });
        default:
          return parseNDigits(token.length, dateString);
      }
    }

    validate(_date, value) {
      return value >= 0 && value <= 59;
    }

    set(date, _flags, value) {
      date.setSeconds(value, 0);
      return date;
    }

    incompatibleTokens = ["t", "T"];
  }

  class FractionOfSecondParser extends Parser {
    priority = 30;

    parse(dateString, token) {
      const valueCallback = (value) =>
        Math.floor(value * Math.pow(10, -token.length + 3));
      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }

    set(date, _flags, value) {
      date.setMilliseconds(value);
      return date;
    }

    incompatibleTokens = ["t", "T"];
  }

  // Timezone (ISO-8601. +00:00 is `'Z'`)
  class ISOTimezoneWithZParser extends Parser {
    priority = 10;

    parse(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString,
          );
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString,
          );
        case "XXXXX":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString,
          );
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }

    set(date, flags, value) {
      if (flags.timestampIsSet) return date;
      return constructFrom(
        date,
        date.getTime() - getTimezoneOffsetInMilliseconds(date) - value,
      );
    }

    incompatibleTokens = ["t", "T", "x"];
  }

  // Timezone (ISO-8601)
  class ISOTimezoneParser extends Parser {
    priority = 10;

    parse(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalMinutes,
            dateString,
          );
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(
            timezonePatterns.basicOptionalSeconds,
            dateString,
          );
        case "xxxxx":
          return parseTimezonePattern(
            timezonePatterns.extendedOptionalSeconds,
            dateString,
          );
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }

    set(date, flags, value) {
      if (flags.timestampIsSet) return date;
      return constructFrom(
        date,
        date.getTime() - getTimezoneOffsetInMilliseconds(date) - value,
      );
    }

    incompatibleTokens = ["t", "T", "X"];
  }

  class TimestampSecondsParser extends Parser {
    priority = 40;

    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }

    set(date, _flags, value) {
      return [constructFrom(date, value * 1000), { timestampIsSet: true }];
    }

    incompatibleTokens = "*";
  }

  class TimestampMillisecondsParser extends Parser {
    priority = 20;

    parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }

    set(date, _flags, value) {
      return [constructFrom(date, value), { timestampIsSet: true }];
    }

    incompatibleTokens = "*";
  }

  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
   * |  p  |                                |  P  |                                |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- It's ok, we want any here
  const parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser(),
  };

  /**
   * The {@link parse} function options.
   */

  // This RegExp consists of three parts separated by `|`:
  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps
  const formattingTokensRegExp$1 =
    /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

  // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
  const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;

  const escapedStringRegExp$1 = /^'([^]*?)'?$/;
  const doubleQuoteRegExp$1 = /''/g;

  const notWhitespaceRegExp = /\S/;
  const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format string.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * parse('23 AM', 'HH a', new Date())
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 001, ..., 999                |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `parse` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
   *
   *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
   *
   *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
   *
   *    while `uu` will just assign the year as is:
   *
   *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
   *
   *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
   *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be assigned to the date in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
   *
   * `referenceDate` must be passed for correct work of the function.
   * If you're not sure which `referenceDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateStr - The string to parse
   * @param formatStr - The string of tokens
   * @param referenceDate - defines values missing from the parsed dateString
   * @param options - An object with options.
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * @returns The parsed date
   *
   * @throws `options.locale` must contain `match` property
   * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws format string contains an unescaped latin alphabet character
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
   *   locale: eo
   * })
   * //=> Sun Feb 28 2010 00:00:00
   */
  function parse(dateStr, formatStr, referenceDate, options) {
    const defaultOptions = getDefaultOptions();
    const locale = options?.locale ?? defaultOptions.locale ?? enUS;

    const firstWeekContainsDate =
      options?.firstWeekContainsDate ??
      options?.locale?.options?.firstWeekContainsDate ??
      defaultOptions.firstWeekContainsDate ??
      defaultOptions.locale?.options?.firstWeekContainsDate ??
      1;

    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    if (formatStr === "") {
      if (dateStr === "") {
        return toDate(referenceDate);
      } else {
        return constructFrom(referenceDate, NaN);
      }
    }

    const subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale,
    };

    // If timezone isn't specified, it will be set to the system timezone
    const setters = [new DateToSystemTimezoneSetter()];

    const tokens = formatStr
      .match(longFormattingTokensRegExp)
      .map((substring) => {
        const firstCharacter = substring[0];
        if (firstCharacter in longFormatters) {
          const longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale.formatLong);
        }
        return substring;
      })
      .join("")
      .match(formattingTokensRegExp$1);

    const usedTokens = [];

    for (let token of tokens) {
      if (
        !options?.useAdditionalWeekYearTokens &&
        isProtectedWeekYearToken(token)
      ) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }
      if (
        !options?.useAdditionalDayOfYearTokens &&
        isProtectedDayOfYearToken(token)
      ) {
        warnOrThrowProtectedError(token, formatStr, dateStr);
      }

      const firstCharacter = token[0];
      const parser = parsers[firstCharacter];
      if (parser) {
        const { incompatibleTokens } = parser;
        if (Array.isArray(incompatibleTokens)) {
          const incompatibleToken = usedTokens.find(
            (usedToken) =>
              incompatibleTokens.includes(usedToken.token) ||
              usedToken.token === firstCharacter,
          );
          if (incompatibleToken) {
            throw new RangeError(
              `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`,
            );
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError(
            `The format string mustn't contain \`${token}\` and any other token at the same time`,
          );
        }

        usedTokens.push({ token: firstCharacter, fullToken: token });

        const parseResult = parser.run(
          dateStr,
          token,
          locale.match,
          subFnOptions,
        );

        if (!parseResult) {
          return constructFrom(referenceDate, NaN);
        }

        setters.push(parseResult.setter);

        dateStr = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" +
              firstCharacter +
              "`",
          );
        }

        // Replace two single quote characters with one single quote character
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString$1(token);
        }

        // Cut token from string, or, if string doesn't match the token, return Invalid Date
        if (dateStr.indexOf(token) === 0) {
          dateStr = dateStr.slice(token.length);
        } else {
          return constructFrom(referenceDate, NaN);
        }
      }
    }

    // Check if the remaining input contains something other than whitespace
    if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
      return constructFrom(referenceDate, NaN);
    }

    const uniquePrioritySetters = setters
      .map((setter) => setter.priority)
      .sort((a, b) => b - a)
      .filter((priority, index, array) => array.indexOf(priority) === index)
      .map((priority) =>
        setters
          .filter((setter) => setter.priority === priority)
          .sort((a, b) => b.subPriority - a.subPriority),
      )
      .map((setterArray) => setterArray[0]);

    let date = toDate(referenceDate);

    if (isNaN(date.getTime())) {
      return constructFrom(referenceDate, NaN);
    }

    const flags = {};
    for (const setter of uniquePrioritySetters) {
      if (!setter.validate(date, subFnOptions)) {
        return constructFrom(referenceDate, NaN);
      }

      const result = setter.set(date, flags, subFnOptions);
      // Result is tuple (date, flags)
      if (Array.isArray(result)) {
        date = result[0];
        Object.assign(flags, result[1]);
        // Result is date
      } else {
        date = result;
      }
    }

    return constructFrom(referenceDate, date);
  }

  function cleanEscapedString$1(input) {
    return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
  }

  /**
   * The {@link isMatch} function options.
   */

  /**
   * @name isMatch
   * @category Common Helpers
   * @summary validates the date string against given formats
   *
   * @description
   * Return the true if given date is string correct against the given format else
   * will return false.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * isMatch('23 AM', 'HH a')
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 001, ..., 999                |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `isMatch` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
   *
   *    `isMatch('50', 'yy') //=> true`
   *
   *    `isMatch('75', 'yy') //=> true`
   *
   *    while `uu` will use the year as is:
   *
   *    `isMatch('50', 'uu') //=> true`
   *
   *    `isMatch('75', 'uu') //=> true`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
   *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be checked in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
   * the values will be taken from today's using `new Date()` date which works as a context of parsing.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateStr - The date string to verify
   * @param format - The string of tokens
   * @param options - An object with options.
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * @returns Is format string a match for date string?
   *
   * @throws `options.locale` must contain `match` property
   * @throws use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws format string contains an unescaped latin alphabet character
   *
   * @example
   * // Match 11 February 2014 from middle-endian format:
   * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
   * //=> true
   *
   * @example
   * // Match 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
   *   locale: eo
   * })
   * //=> true
   */
  function isMatch(dateStr, formatStr, options) {
    return isValid(parse(dateStr, formatStr, new Date(), options));
  }

  /**
   * @name isMonday
   * @category Weekday Helpers
   * @summary Is the given date Monday?
   *
   * @description
   * Is the given date Monday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Monday
   *
   * @example
   * // Is 22 September 2014 Monday?
   * const result = isMonday(new Date(2014, 8, 22))
   * //=> true
   */
  function isMonday(date) {
    return toDate(date).getDay() === 1;
  }

  /**
   * @name isPast
   * @category Common Helpers
   * @summary Is the given date in the past?
   * @pure false
   *
   * @description
   * Is the given date in the past?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in the past
   *
   * @example
   * // If today is 6 October 2014, is 2 July 2014 in the past?
   * const result = isPast(new Date(2014, 6, 2))
   * //=> true
   */
  function isPast(date) {
    return +toDate(date) < Date.now();
  }

  /**
   * @name startOfHour
   * @category Hour Helpers
   * @summary Return the start of an hour for the given date.
   *
   * @description
   * Return the start of an hour for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of an hour
   *
   * @example
   * // The start of an hour for 2 September 2014 11:55:00:
   * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
   * //=> Tue Sep 02 2014 11:00:00
   */
  function startOfHour(date) {
    const _date = toDate(date);
    _date.setMinutes(0, 0, 0);
    return _date;
  }

  /**
   * @name isSameHour
   * @category Hour Helpers
   * @summary Are the given dates in the same hour (and same day)?
   *
   * @description
   * Are the given dates in the same hour (and same day)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same hour (and same day)
   *
   * @example
   * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
   * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
   * //=> true
   *
   * @example
   * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
   * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
   * //=> false
   */
  function isSameHour(dateLeft, dateRight) {
    const dateLeftStartOfHour = startOfHour(dateLeft);
    const dateRightStartOfHour = startOfHour(dateRight);

    return +dateLeftStartOfHour === +dateRightStartOfHour;
  }

  /**
   * The {@link isSameWeek} function options.
   */

  /**
   * @name isSameWeek
   * @category Week Helpers
   * @summary Are the given dates in the same week (and month and year)?
   *
   * @description
   * Are the given dates in the same week (and month and year)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   * @param options - An object with options
   *
   * @returns The dates are in the same week (and month and year)
   *
   * @example
   * // Are 31 August 2014 and 4 September 2014 in the same week?
   * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
   * //=> true
   *
   * @example
   * // If week starts with Monday,
   * // are 31 August 2014 and 4 September 2014 in the same week?
   * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
   *   weekStartsOn: 1
   * })
   * //=> false
   *
   * @example
   * // Are 1 January 2014 and 1 January 2015 in the same week?
   * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
   * //=> false
   */
  function isSameWeek(dateLeft, dateRight, options) {
    const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
    const dateRightStartOfWeek = startOfWeek(dateRight, options);

    return +dateLeftStartOfWeek === +dateRightStartOfWeek;
  }

  /**
   * @name isSameISOWeek
   * @category ISO Week Helpers
   * @summary Are the given dates in the same ISO week (and year)?
   *
   * @description
   * Are the given dates in the same ISO week (and year)?
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same ISO week (and year)
   *
   * @example
   * // Are 1 September 2014 and 7 September 2014 in the same ISO week?
   * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2014, 8, 7))
   * //=> true
   *
   * @example
   * // Are 1 September 2014 and 1 September 2015 in the same ISO week?
   * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))
   * //=> false
   */
  function isSameISOWeek(dateLeft, dateRight) {
    return isSameWeek(dateLeft, dateRight, { weekStartsOn: 1 });
  }

  /**
   * @name isSameISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Are the given dates in the same ISO week-numbering year?
   *
   * @description
   * Are the given dates in the same ISO week-numbering year?
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same ISO week-numbering year
   *
   * @example
   * // Are 29 December 2003 and 2 January 2005 in the same ISO week-numbering year?
   * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))
   * //=> true
   */
  function isSameISOWeekYear(dateLeft, dateRight) {
    const dateLeftStartOfYear = startOfISOWeekYear(dateLeft);
    const dateRightStartOfYear = startOfISOWeekYear(dateRight);

    return +dateLeftStartOfYear === +dateRightStartOfYear;
  }

  /**
   * @name isSameMinute
   * @category Minute Helpers
   * @summary Are the given dates in the same minute (and hour and day)?
   *
   * @description
   * Are the given dates in the same minute (and hour and day)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same minute (and hour and day)
   *
   * @example
   * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
   * const result = isSameMinute(
   *   new Date(2014, 8, 4, 6, 30),
   *   new Date(2014, 8, 4, 6, 30, 15)
   * )
   * //=> true
   *
   * @example
   * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
   * const result = isSameMinute(
   *   new Date(2014, 8, 4, 6, 30),
   *   new Date(2014, 8, 5, 6, 30)
   * )
   * //=> false
   */
  function isSameMinute(dateLeft, dateRight) {
    const dateLeftStartOfMinute = startOfMinute(dateLeft);
    const dateRightStartOfMinute = startOfMinute(dateRight);

    return +dateLeftStartOfMinute === +dateRightStartOfMinute;
  }

  /**
   * @name isSameMonth
   * @category Month Helpers
   * @summary Are the given dates in the same month (and year)?
   *
   * @description
   * Are the given dates in the same month (and year)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same month (and year)
   *
   * @example
   * // Are 2 September 2014 and 25 September 2014 in the same month?
   * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
   * //=> true
   *
   * @example
   * // Are 2 September 2014 and 25 September 2015 in the same month?
   * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
   * //=> false
   */
  function isSameMonth(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);
    return (
      _dateLeft.getFullYear() === _dateRight.getFullYear() &&
      _dateLeft.getMonth() === _dateRight.getMonth()
    );
  }

  /**
   * @name isSameQuarter
   * @category Quarter Helpers
   * @summary Are the given dates in the same quarter (and year)?
   *
   * @description
   * Are the given dates in the same quarter (and year)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check

   * @returns The dates are in the same quarter (and year)
   *
   * @example
   * // Are 1 January 2014 and 8 March 2014 in the same quarter?
   * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
   * //=> true
   *
   * @example
   * // Are 1 January 2014 and 1 January 2015 in the same quarter?
   * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
   * //=> false
   */
  function isSameQuarter(dateLeft, dateRight) {
    const dateLeftStartOfQuarter = startOfQuarter(dateLeft);
    const dateRightStartOfQuarter = startOfQuarter(dateRight);

    return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
  }

  /**
   * @name startOfSecond
   * @category Second Helpers
   * @summary Return the start of a second for the given date.
   *
   * @description
   * Return the start of a second for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a second
   *
   * @example
   * // The start of a second for 1 December 2014 22:15:45.400:
   * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:45.000
   */
  function startOfSecond(date) {
    const _date = toDate(date);
    _date.setMilliseconds(0);
    return _date;
  }

  /**
   * @name isSameSecond
   * @category Second Helpers
   * @summary Are the given dates in the same second (and hour and day)?
   *
   * @description
   * Are the given dates in the same second (and hour and day)?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same second (and hour and day)
   *
   * @example
   * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
   * const result = isSameSecond(
   *   new Date(2014, 8, 4, 6, 30, 15),
   *   new Date(2014, 8, 4, 6, 30, 15, 500)
   * )
   * //=> true
   *
   * @example
   * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
   * const result = isSameSecond(
   *   new Date(2014, 8, 4, 6, 0, 15),
   *   new Date(2014, 8, 4, 6, 1, 15)
   * )
   * //=> false
   *
   * @example
   * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
   * const result = isSameSecond(
   *   new Date(2014, 8, 4, 6, 0, 15),
   *   new Date(2014, 8, 5, 6, 0, 15)
   * )
   * //=> false
   */
  function isSameSecond(dateLeft, dateRight) {
    const dateLeftStartOfSecond = startOfSecond(dateLeft);
    const dateRightStartOfSecond = startOfSecond(dateRight);

    return +dateLeftStartOfSecond === +dateRightStartOfSecond;
  }

  /**
   * @name isSameYear
   * @category Year Helpers
   * @summary Are the given dates in the same year?
   *
   * @description
   * Are the given dates in the same year?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param dateLeft - The first date to check
   * @param dateRight - The second date to check
   *
   * @returns The dates are in the same year
   *
   * @example
   * // Are 2 September 2014 and 25 September 2014 in the same year?
   * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
   * //=> true
   */
  function isSameYear(dateLeft, dateRight) {
    const _dateLeft = toDate(dateLeft);
    const _dateRight = toDate(dateRight);
    return _dateLeft.getFullYear() === _dateRight.getFullYear();
  }

  /**
   * @name isThisHour
   * @category Hour Helpers
   * @summary Is the given date in the same hour as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same hour as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this hour
   *
   * @example
   * // If now is 25 September 2014 18:30:15.500,
   * // is 25 September 2014 18:00:00 in this hour?
   * const result = isThisHour(new Date(2014, 8, 25, 18))
   * //=> true
   */
  function isThisHour(date) {
    return isSameHour(Date.now(), date);
  }

  /**
   * @name isThisISOWeek
   * @category ISO Week Helpers
   * @summary Is the given date in the same ISO week as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same ISO week as the current date?
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this ISO week
   *
   * @example
   * // If today is 25 September 2014, is 22 September 2014 in this ISO week?
   * const result = isThisISOWeek(new Date(2014, 8, 22))
   * //=> true
   */

  function isThisISOWeek(date) {
    return isSameISOWeek(date, Date.now());
  }

  /**
   * @name isThisMinute
   * @category Minute Helpers
   * @summary Is the given date in the same minute as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same minute as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this minute
   *
   * @example
   * // If now is 25 September 2014 18:30:15.500,
   * // is 25 September 2014 18:30:00 in this minute?
   * const result = isThisMinute(new Date(2014, 8, 25, 18, 30))
   * //=> true
   */

  function isThisMinute(date) {
    return isSameMinute(Date.now(), date);
  }

  /**
   * @name isThisMonth
   * @category Month Helpers
   * @summary Is the given date in the same month as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same month as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this month
   *
   * @example
   * // If today is 25 September 2014, is 15 September 2014 in this month?
   * const result = isThisMonth(new Date(2014, 8, 15))
   * //=> true
   */

  function isThisMonth(date) {
    return isSameMonth(Date.now(), date);
  }

  /**
   * @name isThisQuarter
   * @category Quarter Helpers
   * @summary Is the given date in the same quarter as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same quarter as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this quarter
   *
   * @example
   * // If today is 25 September 2014, is 2 July 2014 in this quarter?
   * const result = isThisQuarter(new Date(2014, 6, 2))
   * //=> true
   */
  function isThisQuarter(date) {
    return isSameQuarter(Date.now(), date);
  }

  /**
   * @name isThisSecond
   * @category Second Helpers
   * @summary Is the given date in the same second as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same second as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this second
   *
   * @example
   * // If now is 25 September 2014 18:30:15.500,
   * // is 25 September 2014 18:30:15.000 in this second?
   * const result = isThisSecond(new Date(2014, 8, 25, 18, 30, 15))
   * //=> true
   */
  function isThisSecond(date) {
    return isSameSecond(Date.now(), date);
  }

  /**
   * The {@link isThisWeek} function options.
   */

  /**
   * @name isThisWeek
   * @category Week Helpers
   * @summary Is the given date in the same week as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same week as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   * @param options - The object with options
   *
   * @returns The date is in this week
   *
   * @example
   * // If today is 25 September 2014, is 21 September 2014 in this week?
   * const result = isThisWeek(new Date(2014, 8, 21))
   * //=> true
   *
   * @example
   * // If today is 25 September 2014 and week starts with Monday
   * // is 21 September 2014 in this week?
   * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
   * //=> false
   */
  function isThisWeek(date, options) {
    return isSameWeek(date, Date.now(), options);
  }

  /**
   * @name isThisYear
   * @category Year Helpers
   * @summary Is the given date in the same year as the current date?
   * @pure false
   *
   * @description
   * Is the given date in the same year as the current date?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is in this year
   *
   * @example
   * // If today is 25 September 2014, is 2 July 2014 in this year?
   * const result = isThisYear(new Date(2014, 6, 2))
   * //=> true
   */
  function isThisYear(date) {
    return isSameYear(date, Date.now());
  }

  /**
   * @name isThursday
   * @category Weekday Helpers
   * @summary Is the given date Thursday?
   *
   * @description
   * Is the given date Thursday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Thursday
   *
   * @example
   * // Is 25 September 2014 Thursday?
   * const result = isThursday(new Date(2014, 8, 25))
   * //=> true
   */
  function isThursday(date) {
    return toDate(date).getDay() === 4;
  }

  /**
   * @name isToday
   * @category Day Helpers
   * @summary Is the given date today?
   * @pure false
   *
   * @description
   * Is the given date today?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is today
   *
   * @example
   * // If today is 6 October 2014, is 6 October 14:00:00 today?
   * const result = isToday(new Date(2014, 9, 6, 14, 0))
   * //=> true
   */
  function isToday(date) {
    return isSameDay(date, Date.now());
  }

  /**
   * @name isTomorrow
   * @category Day Helpers
   * @summary Is the given date tomorrow?
   * @pure false
   *
   * @description
   * Is the given date tomorrow?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is tomorrow
   *
   * @example
   * // If today is 6 October 2014, is 7 October 14:00:00 tomorrow?
   * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))
   * //=> true
   */
  function isTomorrow(date) {
    return isSameDay(date, addDays(Date.now(), 1));
  }

  /**
   * @name isTuesday
   * @category Weekday Helpers
   * @summary Is the given date Tuesday?
   *
   * @description
   * Is the given date Tuesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Tuesday
   *
   * @example
   * // Is 23 September 2014 Tuesday?
   * const result = isTuesday(new Date(2014, 8, 23))
   * //=> true
   */
  function isTuesday(date) {
    return toDate(date).getDay() === 2;
  }

  /**
   * @name isWednesday
   * @category Weekday Helpers
   * @summary Is the given date Wednesday?
   *
   * @description
   * Is the given date Wednesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is Wednesday
   *
   * @example
   * // Is 24 September 2014 Wednesday?
   * const result = isWednesday(new Date(2014, 8, 24))
   * //=> true
   */
  function isWednesday(date) {
    return toDate(date).getDay() === 3;
  }

  /**
   * @name isWithinInterval
   * @category Interval Helpers
   * @summary Is the given date within the interval?
   *
   * @description
   * Is the given date within the interval? (Including start and end.)
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   * @param interval - The interval to check
   *
   * @returns The date is within the interval
   *
   * @example
   * // For the date within the interval:
   * isWithinInterval(new Date(2014, 0, 3), {
   *   start: new Date(2014, 0, 1),
   *   end: new Date(2014, 0, 7)
   * })
   * //=> true
   *
   * @example
   * // For the date outside of the interval:
   * isWithinInterval(new Date(2014, 0, 10), {
   *   start: new Date(2014, 0, 1),
   *   end: new Date(2014, 0, 7)
   * })
   * //=> false
   *
   * @example
   * // For date equal to interval start:
   * isWithinInterval(date, { start, end: date })
   * // => true
   *
   * @example
   * // For date equal to interval end:
   * isWithinInterval(date, { start: date, end })
   * // => true
   */
  function isWithinInterval(date, interval) {
    const time = +toDate(date);
    const [startTime, endTime] = [
      +toDate(interval.start),
      +toDate(interval.end),
    ].sort((a, b) => a - b);

    return time >= startTime && time <= endTime;
  }

  /**
   * @name subDays
   * @category Day Helpers
   * @summary Subtract the specified number of days from the given date.
   *
   * @description
   * Subtract the specified number of days from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of days to be subtracted.
   *
   * @returns The new date with the days subtracted
   *
   * @example
   * // Subtract 10 days from 1 September 2014:
   * const result = subDays(new Date(2014, 8, 1), 10)
   * //=> Fri Aug 22 2014 00:00:00
   */
  function subDays(date, amount) {
    return addDays(date, -amount);
  }

  /**
   * @name isYesterday
   * @category Day Helpers
   * @summary Is the given date yesterday?
   * @pure false
   *
   * @description
   * Is the given date yesterday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   *
   * @returns The date is yesterday
   *
   * @example
   * // If today is 6 October 2014, is 5 October 14:00:00 yesterday?
   * const result = isYesterday(new Date(2014, 9, 5, 14, 0))
   * //=> true
   */
  function isYesterday(date) {
    return isSameDay(date, subDays(Date.now(), 1));
  }

  /**
   * @name lastDayOfDecade
   * @category Decade Helpers
   * @summary Return the last day of a decade for the given date.
   *
   * @description
   * Return the last day of a decade for the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The last day of a decade
   *
   * @example
   * // The last day of a decade for 21 December 2012 21:12:00:
   * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))
   * //=> Wed Dec 31 2019 00:00:00
   */
  function lastDayOfDecade(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const decade = 9 + Math.floor(year / 10) * 10;
    _date.setFullYear(decade + 1, 0, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * The {@link lastDayOfWeek} function options.
   */

  /**
   * @name lastDayOfWeek
   * @category Week Helpers
   * @summary Return the last day of a week for the given date.
   *
   * @description
   * Return the last day of a week for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param options - An object with options
   *
   * @returns The last day of a week
   *
   * @example
   * // The last day of a week for 2 September 2014 11:55:00:
   * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Sat Sep 06 2014 00:00:00
   *
   * @example
   * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:
   * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
   * //=> Sun Sep 07 2014 00:00:00
   */
  function lastDayOfWeek(date, options) {
    const defaultOptions = getDefaultOptions$1();
    const weekStartsOn =
      options?.weekStartsOn ??
      options?.locale?.options?.weekStartsOn ??
      defaultOptions.weekStartsOn ??
      defaultOptions.locale?.options?.weekStartsOn ??
      0;

    const _date = toDate(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);

    _date.setHours(0, 0, 0, 0);
    _date.setDate(_date.getDate() + diff);
    return _date;
  }

  /**
   * @name lastDayOfISOWeek
   * @category ISO Week Helpers
   * @summary Return the last day of an ISO week for the given date.
   *
   * @description
   * Return the last day of an ISO week for the given date.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The last day of an ISO week
   *
   * @example
   * // The last day of an ISO week for 2 September 2014 11:55:00:
   * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Sun Sep 07 2014 00:00:00
   */
  function lastDayOfISOWeek(date) {
    return lastDayOfWeek(date, { weekStartsOn: 1 });
  }

  /**
   * @name lastDayOfISOWeekYear
   * @category ISO Week-Numbering Year Helpers
   * @summary Return the last day of an ISO week-numbering year for the given date.
   *
   * @description
   * Return the last day of an ISO week-numbering year,
   * which always starts 3 days before the year's first Thursday.
   * The result will be in the local timezone.
   *
   * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The end of an ISO week-numbering year
   *
   * @example
   * // The last day of an ISO week-numbering year for 2 July 2005:
   * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))
   * //=> Sun Jan 01 2006 00:00:00
   */
  function lastDayOfISOWeekYear(date) {
    const year = getISOWeekYear(date);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year + 1, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    const _date = startOfISOWeek(fourthOfJanuary);
    _date.setDate(_date.getDate() - 1);
    return _date;
  }

  /**
   * @name lastDayOfQuarter
   * @category Quarter Helpers
   * @summary Return the last day of a year quarter for the given date.
   *
   * @description
   * Return the last day of a year quarter for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The last day of a quarter
   *
   * @example
   * // The last day of a quarter for 2 September 2014 11:55:00:
   * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 30 2014 00:00:00
   */
  function lastDayOfQuarter(date) {
    const _date = toDate(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - (currentMonth % 3) + 3;
    _date.setMonth(month, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * @name lastDayOfYear
   * @category Year Helpers
   * @summary Return the last day of a year for the given date.
   *
   * @description
   * Return the last day of a year for the given date.
   * The result will be in the local timezone.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The last day of a year
   *
   * @example
   * // The last day of a year for 2 September 2014 11:55:00:
   * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
   * //=> Wed Dec 31 2014 00:00:00
   */
  function lastDayOfYear(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  // This RegExp consists of three parts separated by `|`:
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps
  const formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;

  const escapedStringRegExp = /^'([^]*?)'?$/;
  const doubleQuoteRegExp = /''/g;
  const unescapedLatinCharacterRegExp = /[a-zA-Z]/;

  /**
   * @private
   */

  /**
   * @name lightFormat
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. Unlike `format`,
   * `lightFormat` doesn't use locales and outputs date using the most popular tokens.
   *
   * >  Please note that the `lightFormat` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   |
   * |---------------------------------|---------|-----------------------------------|
   * | AM, PM                          | a..aaa  | AM, PM                            |
   * |                                 | aaaa    | a.m., p.m.                        |
   * |                                 | aaaaa   | a, p                              |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 |
   * |                                 | yy      | 44, 01, 00, 17                    |
   * |                                 | yyy     | 044, 001, 000, 017                |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |
   * |                                 | MM      | 01, 02, ..., 12                   |
   * | Day of month                    | d       | 1, 2, ..., 31                     |
   * |                                 | dd      | 01, 02, ..., 31                   |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |
   * |                                 | hh      | 01, 02, ..., 11, 12               |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |
   * |                                 | HH      | 00, 01, 02, ..., 23               |
   * | Minute                          | m       | 0, 1, ..., 59                     |
   * |                                 | mm      | 00, 01, ..., 59                   |
   * | Second                          | s       | 0, 1, ..., 59                     |
   * |                                 | ss      | 00, 01, ..., 59                   |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |
   * |                                 | SS      | 00, 01, ..., 99                   |
   * |                                 | SSS     | 000, 001, ..., 999                |
   * |                                 | SSSS    | ...                               |
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   * @param format - The string of tokens
   *
   * @returns The formatted date string
   *
   * @throws `Invalid time value` if the date is invalid
   * @throws format string contains an unescaped latin alphabet character
   *
   * @example
   * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')
   * //=> '2014-02-11'
   */
  function lightFormat(date, formatStr) {
    const _date = toDate(date);

    if (!isValid(_date)) {
      throw new RangeError("Invalid time value");
    }

    const tokens = formatStr.match(formattingTokensRegExp);

    // The only case when formattingTokensRegExp doesn't match the string is when it's empty
    if (!tokens) return "";

    const result = tokens
      .map((substring) => {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        const firstCharacter = substring[0];
        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }

        const formatter = lightFormatters[firstCharacter];
        if (formatter) {
          return formatter(_date, substring);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" +
              firstCharacter +
              "`",
          );
        }

        return substring;
      })
      .join("");

    return result;
  }

  function cleanEscapedString(input) {
    const matches = input.match(escapedStringRegExp);

    if (!matches) {
      return input;
    }

    return matches[1].replace(doubleQuoteRegExp, "'");
  }

  /**
   * @name milliseconds
   * @category Millisecond Helpers
   * @summary
   * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
   *
   * @description
   * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
   *
   * One years equals 365.2425 days according to the formula:
   *
   * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
   * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
   *
   * One month is a year divided by 12.
   *
   * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
   *
   * @returns The milliseconds
   *
   * @example
   * // 1 year in milliseconds
   * milliseconds({ years: 1 })
   * //=> 31556952000
   *
   * // 3 months in milliseconds
   * milliseconds({ months: 3 })
   * //=> 7889238000
   */
  function milliseconds({
    years,
    months,
    weeks,
    days,
    hours,
    minutes,
    seconds,
  }) {
    let totalDays = 0;

    if (years) totalDays += years * daysInYear;
    if (months) totalDays += months * (daysInYear / 12);
    if (weeks) totalDays += weeks * 7;
    if (days) totalDays += days;

    let totalSeconds = totalDays * 24 * 60 * 60;

    if (hours) totalSeconds += hours * 60 * 60;
    if (minutes) totalSeconds += minutes * 60;
    if (seconds) totalSeconds += seconds;

    return Math.round(totalSeconds * 1000);
  }

  /**
   * @name millisecondsToHours
   * @category Conversion Helpers
   * @summary Convert milliseconds to hours.
   *
   * @description
   * Convert a number of milliseconds to a full number of hours.
   *
   * @param milliseconds - The number of milliseconds to be converted
   *
   * @returns The number of milliseconds converted in hours
   *
   * @example
   * // Convert 7200000 milliseconds to hours:
   * const result = millisecondsToHours(7200000)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = millisecondsToHours(7199999)
   * //=> 1
   */
  function millisecondsToHours(milliseconds) {
    const hours = milliseconds / millisecondsInHour;
    return Math.floor(hours);
  }

  /**
   * @name millisecondsToMinutes
   * @category Conversion Helpers
   * @summary Convert milliseconds to minutes.
   *
   * @description
   * Convert a number of milliseconds to a full number of minutes.
   *
   * @param milliseconds - The number of milliseconds to be converted
   *
   * @returns The number of milliseconds converted in minutes
   *
   * @example
   * // Convert 60000 milliseconds to minutes:
   * const result = millisecondsToMinutes(60000)
   * //=> 1
   *
   * @example
   * // It uses floor rounding:
   * const result = millisecondsToMinutes(119999)
   * //=> 1
   */
  function millisecondsToMinutes(milliseconds) {
    const minutes = milliseconds / millisecondsInMinute;
    return Math.floor(minutes);
  }

  /**
   * @name millisecondsToSeconds
   * @category Conversion Helpers
   * @summary Convert milliseconds to seconds.
   *
   * @description
   * Convert a number of milliseconds to a full number of seconds.
   *
   * @param milliseconds - The number of milliseconds to be converted
   *
   * @returns The number of milliseconds converted in seconds
   *
   * @example
   * // Convert 1000 miliseconds to seconds:
   * const result = millisecondsToSeconds(1000)
   * //=> 1
   *
   * @example
   * // It uses floor rounding:
   * const result = millisecondsToSeconds(1999)
   * //=> 1
   */
  function millisecondsToSeconds(milliseconds) {
    const seconds = milliseconds / millisecondsInSecond;
    return Math.floor(seconds);
  }

  /**
   * @name minutesToHours
   * @category Conversion Helpers
   * @summary Convert minutes to hours.
   *
   * @description
   * Convert a number of minutes to a full number of hours.
   *
   * @param minutes - The number of minutes to be converted
   *
   * @returns The number of minutes converted in hours
   *
   * @example
   * // Convert 140 minutes to hours:
   * const result = minutesToHours(120)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = minutesToHours(179)
   * //=> 2
   */
  function minutesToHours(minutes) {
    const hours = minutes / minutesInHour;
    return Math.floor(hours);
  }

  /**
   * @name minutesToMilliseconds
   * @category Conversion Helpers
   * @summary Convert minutes to milliseconds.
   *
   * @description
   * Convert a number of minutes to a full number of milliseconds.
   *
   * @param minutes - The number of minutes to be converted
   *
   * @returns The number of minutes converted in milliseconds
   *
   * @example
   * // Convert 2 minutes to milliseconds
   * const result = minutesToMilliseconds(2)
   * //=> 120000
   */
  function minutesToMilliseconds(minutes) {
    return Math.floor(minutes * millisecondsInMinute);
  }

  /**
   * @name minutesToSeconds
   * @category Conversion Helpers
   * @summary Convert minutes to seconds.
   *
   * @description
   * Convert a number of minutes to a full number of seconds.
   *
   * @param minutes - The number of minutes to be converted
   *
   * @returns The number of minutes converted in seconds
   *
   * @example
   * // Convert 2 minutes to seconds
   * const result = minutesToSeconds(2)
   * //=> 120
   */
  function minutesToSeconds(minutes) {
    return Math.floor(minutes * secondsInMinute);
  }

  /**
   * @name monthsToQuarters
   * @category Conversion Helpers
   * @summary Convert number of months to quarters.
   *
   * @description
   * Convert a number of months to a full number of quarters.
   *
   * @param months - The number of months to be converted.
   *
   * @returns The number of months converted in quarters
   *
   * @example
   * // Convert 6 months to quarters:
   * const result = monthsToQuarters(6)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = monthsToQuarters(7)
   * //=> 2
   */
  function monthsToQuarters(months) {
    const quarters = months / monthsInQuarter;
    return Math.floor(quarters);
  }

  /**
   * @name monthsToYears
   * @category Conversion Helpers
   * @summary Convert number of months to years.
   *
   * @description
   * Convert a number of months to a full number of years.
   *
   * @param months - The number of months to be converted
   *
   * @returns The number of months converted in years
   *
   * @example
   * // Convert 36 months to years:
   * const result = monthsToYears(36)
   * //=> 3
   *
   * // It uses floor rounding:
   * const result = monthsToYears(40)
   * //=> 3
   */
  function monthsToYears(months) {
    const years = months / monthsInYear;
    return Math.floor(years);
  }

  /**
   * @name nextDay
   * @category Weekday Helpers
   * @summary When is the next day of the week?
   *
   * @description
   * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   * @param day - day of the week
   *
   * @returns The date is the next day of week
   *
   * @example
   * // When is the next Monday after Mar, 20, 2020?
   * const result = nextDay(new Date(2020, 2, 20), 1)
   * //=> Mon Mar 23 2020 00:00:00
   *
   * @example
   * // When is the next Tuesday after Mar, 21, 2020?
   * const result = nextDay(new Date(2020, 2, 21), 2)
   * //=> Tue Mar 24 2020 00:00:00
   */
  function nextDay(date, day) {
    let delta = day - getDay(date);
    if (delta <= 0) delta += 7;

    return addDays(date, delta);
  }

  /**
   * @name nextFriday
   * @category Weekday Helpers
   * @summary When is the next Friday?
   *
   * @description
   * When is the next Friday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Friday
   *
   * @example
   * // When is the next Friday after Mar, 22, 2020?
   * const result = nextFriday(new Date(2020, 2, 22))
   * //=> Fri Mar 27 2020 00:00:00
   */
  function nextFriday(date) {
    return nextDay(date, 5);
  }

  /**
   * @name nextMonday
   * @category Weekday Helpers
   * @summary When is the next Monday?
   *
   * @description
   * When is the next Monday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Monday
   *
   * @example
   * // When is the next Monday after Mar, 22, 2020?
   * const result = nextMonday(new Date(2020, 2, 22))
   * //=> Mon Mar 23 2020 00:00:00
   */
  function nextMonday(date) {
    return nextDay(date, 1);
  }

  /**
   * @name nextSaturday
   * @category Weekday Helpers
   * @summary When is the next Saturday?
   *
   * @description
   * When is the next Saturday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Saturday
   *
   * @example
   * // When is the next Saturday after Mar, 22, 2020?
   * const result = nextSaturday(new Date(2020, 2, 22))
   * //=> Sat Mar 28 2020 00:00:00
   */
  function nextSaturday(date) {
    return nextDay(date, 6);
  }

  /**
   * @name nextSunday
   * @category Weekday Helpers
   * @summary When is the next Sunday?
   *
   * @description
   * When is the next Sunday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Sunday
   *
   * @example
   * // When is the next Sunday after Mar, 22, 2020?
   * const result = nextSunday(new Date(2020, 2, 22))
   * //=> Sun Mar 29 2020 00:00:00
   */
  function nextSunday(date) {
    return nextDay(date, 0);
  }

  /**
   * @name nextThursday
   * @category Weekday Helpers
   * @summary When is the next Thursday?
   *
   * @description
   * When is the next Thursday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Thursday
   *
   * @example
   * // When is the next Thursday after Mar, 22, 2020?
   * const result = nextThursday(new Date(2020, 2, 22))
   * //=> Thur Mar 26 2020 00:00:00
   */
  function nextThursday(date) {
    return nextDay(date, 4);
  }

  /**
   * @name nextTuesday
   * @category Weekday Helpers
   * @summary When is the next Tuesday?
   *
   * @description
   * When is the next Tuesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Tuesday
   *
   * @example
   * // When is the next Tuesday after Mar, 22, 2020?
   * const result = nextTuesday(new Date(2020, 2, 22))
   * //=> Tue Mar 24 2020 00:00:00
   */
  function nextTuesday(date) {
    return nextDay(date, 2);
  }

  /**
   * @name nextWednesday
   * @category Weekday Helpers
   * @summary When is the next Wednesday?
   *
   * @description
   * When is the next Wednesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The next Wednesday
   *
   * @example
   * // When is the next Wednesday after Mar, 22, 2020?
   * const result = nextWednesday(new Date(2020, 2, 22))
   * //=> Wed Mar 25 2020 00:00:00
   */
  function nextWednesday(date) {
    return nextDay(date, 3);
  }

  /**
   * The {@link parseISO} function options.
   */

  /**
   * @name parseISO
   * @category Common Helpers
   * @summary Parse ISO string
   *
   * @description
   * Parse the given string in ISO 8601 format and return an instance of Date.
   *
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   *
   * If the argument isn't a string, the function cannot parse the string or
   * the values are invalid, it returns Invalid Date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param argument - The value to convert
   * @param options - An object with options
   *
   * @returns The parsed date in the local time zone
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * const result = parseISO('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * const result = parseISO('+02014101', { additionalDigits: 1 })
   * //=> Fri Apr 11 2014 00:00:00
   */
  function parseISO(argument, options) {
    const additionalDigits = options?.additionalDigits ?? 2;
    const dateStrings = splitDateString(argument);

    let date;
    if (dateStrings.date) {
      const parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }

    if (!date || isNaN(date.getTime())) {
      return new Date(NaN);
    }

    const timestamp = date.getTime();
    let time = 0;
    let offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return new Date(NaN);
      }
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      const dirtyDate = new Date(timestamp + time);
      // JS parsed string assuming it's in UTC timezone
      // but we need it to be parsed in our timezone
      // so we use utc values to build date in our timezone.
      // Year values from 0 to 99 map to the years 1900 to 1999
      // so set year explicitly with setFullYear.
      const result = new Date(0);
      result.setFullYear(
        dirtyDate.getUTCFullYear(),
        dirtyDate.getUTCMonth(),
        dirtyDate.getUTCDate(),
      );
      result.setHours(
        dirtyDate.getUTCHours(),
        dirtyDate.getUTCMinutes(),
        dirtyDate.getUTCSeconds(),
        dirtyDate.getUTCMilliseconds(),
      );
      return result;
    }

    return new Date(timestamp + time + offset);
  }

  const patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/,
  };

  const dateRegex =
    /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  const timeRegex =
    /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

  function splitDateString(dateString) {
    const dateStrings = {};
    const array = dateString.split(patterns.dateTimeDelimiter);
    let timeString;

    // The regex match should only return at maximum two array elements.
    // [date], [time], or [date, time].
    if (array.length > 2) {
      return dateStrings;
    }

    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(
          dateStrings.date.length,
          dateString.length,
        );
      }
    }

    if (timeString) {
      const token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings;
  }

  function parseYear(dateString, additionalDigits) {
    const regex = new RegExp(
      "^(?:(\\d{4}|[+-]\\d{" +
        (4 + additionalDigits) +
        "})|(\\d{2}|[+-]\\d{" +
        (2 + additionalDigits) +
        "})$)",
    );

    const captures = dateString.match(regex);
    // Invalid ISO-formatted year
    if (!captures) return { year: NaN, restDateString: "" };

    const year = captures[1] ? parseInt(captures[1]) : null;
    const century = captures[2] ? parseInt(captures[2]) : null;

    // either year or century is null, not both
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length),
    };
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return new Date(NaN);

    const captures = dateString.match(dateRegex);
    // Invalid ISO-formatted string
    if (!captures) return new Date(NaN);

    const isWeekDate = !!captures[4];
    const dayOfYear = parseDateUnit(captures[1]);
    const month = parseDateUnit(captures[2]) - 1;
    const day = parseDateUnit(captures[3]);
    const week = parseDateUnit(captures[4]);
    const dayOfWeek = parseDateUnit(captures[5]) - 1;

    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      const date = new Date(0);
      if (
        !validateDate(year, month, day) ||
        !validateDayOfYearDate(year, dayOfYear)
      ) {
        return new Date(NaN);
      }
      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }

  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }

  function parseTime(timeString) {
    const captures = timeString.match(timeRegex);
    if (!captures) return NaN; // Invalid ISO-formatted time

    const hours = parseTimeUnit(captures[1]);
    const minutes = parseTimeUnit(captures[2]);
    const seconds = parseTimeUnit(captures[3]);

    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }

    return (
      hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000
    );
  }

  function parseTimeUnit(value) {
    return (value && parseFloat(value.replace(",", "."))) || 0;
  }

  function parseTimezone(timezoneString) {
    if (timezoneString === "Z") return 0;

    const captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;

    const sign = captures[1] === "+" ? -1 : 1;
    const hours = parseInt(captures[2]);
    const minutes = (captures[3] && parseInt(captures[3])) || 0;

    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }

    return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    const date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }

  // Validation functions

  // February is null to handle the leap year (using ||)
  const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex(year) {
    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
  }

  function validateDate(year, month, date) {
    return (
      month >= 0 &&
      month <= 11 &&
      date >= 1 &&
      date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
    );
  }

  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }

  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }

  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }

    return (
      seconds >= 0 &&
      seconds < 60 &&
      minutes >= 0 &&
      minutes < 60 &&
      hours >= 0 &&
      hours < 25
    );
  }

  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }

  /**
   * @name parseJSON
   * @category Common Helpers
   * @summary Parse a JSON date string
   *
   * @description
   * Converts a complete ISO date string in UTC time, the typical format for transmitting
   * a date in JSON, to a JavaScript `Date` instance.
   *
   * This is a minimal implementation for converting dates retrieved from a JSON API to
   * a `Date` instance which can be used with other functions in the `date-fns` library.
   * The following formats are supported:
   *
   * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
   * - `2000-03-15T05:20:10Z`: Without milliseconds
   * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
   * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
   * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
   * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
   * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
   * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
   *
   * For convenience and ease of use these other input types are also supported
   * via [toDate](https://date-fns.org/docs/toDate):
   *
   * - A `Date` instance will be cloned
   * - A `number` will be treated as a timestamp
   *
   * Any other input type or invalid date strings will return an `Invalid Date`.
   *
   * @param dateStr - A fully formed ISO8601 date string to convert
   *
   * @returns The parsed date in the local time zone
   */
  function parseJSON(dateStr) {
    const parts = dateStr.match(
      /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
    );
    if (parts) {
      // Group 8 matches the sign
      return new Date(
        Date.UTC(
          +parts[1],
          +parts[2] - 1,
          +parts[3],
          +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
          +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
          +parts[6],
          +((parts[7] || "0") + "00").substring(0, 3),
        ),
      );
    }
    return new Date(NaN);
  }

  /**
   * @name previousDay
   * @category Weekday Helpers
   * @summary When is the previous day of the week?
   *
   * @description
   * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to check
   * @param day - The day of the week
   *
   * @returns The date is the previous day of week
   *
   * @example
   * // When is the previous Monday before Mar, 20, 2020?
   * const result = previousDay(new Date(2020, 2, 20), 1)
   * //=> Mon Mar 16 2020 00:00:00
   *
   * @example
   * // When is the previous Tuesday before Mar, 21, 2020?
   * const result = previousDay(new Date(2020, 2, 21), 2)
   * //=> Tue Mar 17 2020 00:00:00
   */
  function previousDay(date, day) {
    let delta = getDay(date) - day;
    if (delta <= 0) delta += 7;

    return subDays(date, delta);
  }

  /**
   * @name previousFriday
   * @category Weekday Helpers
   * @summary When is the previous Friday?
   *
   * @description
   * When is the previous Friday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Friday
   *
   * @example
   * // When is the previous Friday before Jun, 19, 2021?
   * const result = previousFriday(new Date(2021, 5, 19))
   * //=> Fri June 18 2021 00:00:00
   */
  function previousFriday(date) {
    return previousDay(date, 5);
  }

  /**
   * @name previousMonday
   * @category Weekday Helpers
   * @summary When is the previous Monday?
   *
   * @description
   * When is the previous Monday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Monday
   *
   * @example
   * // When is the previous Monday before Jun, 18, 2021?
   * const result = previousMonday(new Date(2021, 5, 18))
   * //=> Mon June 14 2021 00:00:00
   */
  function previousMonday(date) {
    return previousDay(date, 1);
  }

  /**
   * @name previousSaturday
   * @category Weekday Helpers
   * @summary When is the previous Saturday?
   *
   * @description
   * When is the previous Saturday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Saturday
   *
   * @example
   * // When is the previous Saturday before Jun, 20, 2021?
   * const result = previousSaturday(new Date(2021, 5, 20))
   * //=> Sat June 19 2021 00:00:00
   */
  function previousSaturday(date) {
    return previousDay(date, 6);
  }

  /**
   * @name previousSunday
   * @category Weekday Helpers
   * @summary When is the previous Sunday?
   *
   * @description
   * When is the previous Sunday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Sunday
   *
   * @example
   * // When is the previous Sunday before Jun, 21, 2021?
   * const result = previousSunday(new Date(2021, 5, 21))
   * //=> Sun June 20 2021 00:00:00
   */
  function previousSunday(date) {
    return previousDay(date, 0);
  }

  /**
   * @name previousThursday
   * @category Weekday Helpers
   * @summary When is the previous Thursday?
   *
   * @description
   * When is the previous Thursday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Thursday
   *
   * @example
   * // When is the previous Thursday before Jun, 18, 2021?
   * const result = previousThursday(new Date(2021, 5, 18))
   * //=> Thu June 17 2021 00:00:00
   */
  function previousThursday(date) {
    return previousDay(date, 4);
  }

  /**
   * @name previousTuesday
   * @category Weekday Helpers
   * @summary When is the previous Tuesday?
   *
   * @description
   * When is the previous Tuesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Tuesday
   *
   * @example
   * // When is the previous Tuesday before Jun, 18, 2021?
   * const result = previousTuesday(new Date(2021, 5, 18))
   * //=> Tue June 15 2021 00:00:00
   */
  function previousTuesday(date) {
    return previousDay(date, 2);
  }

  /**
   * @name previousWednesday
   * @category Weekday Helpers
   * @summary When is the previous Wednesday?
   *
   * @description
   * When is the previous Wednesday?
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to start counting from
   *
   * @returns The previous Wednesday
   *
   * @example
   * // When is the previous Wednesday before Jun, 18, 2021?
   * const result = previousWednesday(new Date(2021, 5, 18))
   * //=> Wed June 16 2021 00:00:00
   */
  function previousWednesday(date) {
    return previousDay(date, 3);
  }

  /**
   * @name quartersToMonths
   * @category Conversion Helpers
   * @summary Convert number of quarters to months.
   *
   * @description
   * Convert a number of quarters to a full number of months.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param quarters - The number of quarters to be converted
   *
   * @returns The number of quarters converted in months
   *
   * @example
   * // Convert 2 quarters to months
   * const result = quartersToMonths(2)
   * //=> 6
   */
  function quartersToMonths(quarters) {
    return Math.floor(quarters * monthsInQuarter);
  }

  /**
   * @name quartersToYears
   * @category Conversion Helpers
   * @summary Convert number of quarters to years.
   *
   * @description
   * Convert a number of quarters to a full number of years.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param quarters - The number of quarters to be converted
   *
   * @returns The number of quarters converted in years
   *
   * @example
   * // Convert 8 quarters to years
   * const result = quartersToYears(8)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = quartersToYears(11)
   * //=> 2
   */
  function quartersToYears(quarters) {
    const years = quarters / quartersInYear;
    return Math.floor(years);
  }

  /**
   * The {@link roundToNearestMinutes} function options.
   */

  /**
   * @name roundToNearestMinutes
   * @category Minute Helpers
   * @summary Rounds the given date to the nearest minute
   *
   * @description
   * Rounds the given date to the nearest minute (or number of minutes).
   * Rounds up when the given date is exactly between the nearest round minutes.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to round
   * @param options - An object with options.
   *
   * @returns The new date rounded to the closest minute
   *
   * @example
   * // Round 10 July 2014 12:12:34 to nearest minute:
   * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
   * //=> Thu Jul 10 2014 12:13:00
   *
   * @example
   * // Round 10 July 2014 12:12:34 to nearest quarter hour:
   * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
   * //=> Thu Jul 10 2014 12:15:00
   *
   * @example
   * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
   * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
   * //=> Thu Jul 10 2014 12:12:00
   *
   * @example
   * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
   * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
   * //=> Thu Jul 10 2014 12:30:00
   */
  function roundToNearestMinutes(date, options) {
    const nearestTo = options?.nearestTo ?? 1;

    if (nearestTo < 1 || nearestTo > 30) return constructFrom(date, NaN);

    const _date = toDate(date);
    const fractionalSeconds = _date.getSeconds() / 60;
    const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60;
    const minutes =
      _date.getMinutes() + fractionalSeconds + fractionalMilliseconds;

    // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
    const method = options?.roundingMethod ?? "round";
    const roundingMethod = getRoundingMethod(method);

    const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;

    const result = constructFrom(date, _date);
    result.setMinutes(roundedMinutes, 0, 0);
    return result;
  }

  /**
   * @name secondsToHours
   * @category Conversion Helpers
   * @summary Convert seconds to hours.
   *
   * @description
   * Convert a number of seconds to a full number of hours.
   *
   * @param seconds - The number of seconds to be converted
   *
   * @returns The number of seconds converted in hours
   *
   * @example
   * // Convert 7200 seconds into hours
   * const result = secondsToHours(7200)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = secondsToHours(7199)
   * //=> 1
   */
  function secondsToHours(seconds) {
    const hours = seconds / secondsInHour;
    return Math.floor(hours);
  }

  /**
   * @name secondsToMilliseconds
   * @category Conversion Helpers
   * @summary Convert seconds to milliseconds.
   *
   * @description
   * Convert a number of seconds to a full number of milliseconds.
   *
   * @param seconds - The number of seconds to be converted
   *
   * @returns The number of seconds converted in milliseconds
   *
   * @example
   * // Convert 2 seconds into milliseconds
   * const result = secondsToMilliseconds(2)
   * //=> 2000
   */
  function secondsToMilliseconds(seconds) {
    return seconds * millisecondsInSecond;
  }

  /**
   * @name secondsToMinutes
   * @category Conversion Helpers
   * @summary Convert seconds to minutes.
   *
   * @description
   * Convert a number of seconds to a full number of minutes.
   *
   * @param seconds - The number of seconds to be converted
   *
   * @returns The number of seconds converted in minutes
   *
   * @example
   * // Convert 120 seconds into minutes
   * const result = secondsToMinutes(120)
   * //=> 2
   *
   * @example
   * // It uses floor rounding:
   * const result = secondsToMinutes(119)
   * //=> 1
   */
  function secondsToMinutes(seconds) {
    const minutes = seconds / secondsInMinute;
    return Math.floor(minutes);
  }

  /**
   * @name setMonth
   * @category Month Helpers
   * @summary Set the month to the given date.
   *
   * @description
   * Set the month to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param month - The month of the new date
   *
   * @returns The new date with the month set
   *
   * @example
   * // Set February to 1 September 2014:
   * const result = setMonth(new Date(2014, 8, 1), 1)
   * //=> Sat Feb 01 2014 00:00:00
   */
  function setMonth(date, month) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const day = _date.getDate();

    const dateWithDesiredMonth = constructFrom(date, 0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    const daysInMonth = getDaysInMonth(dateWithDesiredMonth);
    // Set the last day of the new month
    // if the original date was the last day of the longer month
    _date.setMonth(month, Math.min(day, daysInMonth));
    return _date;
  }

  /**
   * @name set
   * @category Common Helpers
   * @summary Set date values to a given date.
   *
   * @description
   * Set date values to a given date.
   *
   * Sets time values to date from object `values`.
   * A value is not set if it is undefined or null or doesn't exist in `values`.
   *
   * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
   * to use native `Date#setX` methods. If you use this function, you may not want to include the
   * other `setX` functions that date-fns provides if you are concerned about the bundle size.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param values - The date values to be set
   *
   * @returns The new date with options set
   *
   * @example
   * // Transform 1 September 2014 into 20 October 2015 in a single line:
   * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
   * //=> Tue Oct 20 2015 00:00:00
   *
   * @example
   * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
   * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
   * //=> Mon Sep 01 2014 12:23:45
   */

  function set$1(date, values) {
    let _date = toDate(date);

    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(+_date)) {
      return constructFrom(date, NaN);
    }

    if (values.year != null) {
      _date.setFullYear(values.year);
    }

    if (values.month != null) {
      _date = setMonth(_date, values.month);
    }

    if (values.date != null) {
      _date.setDate(values.date);
    }

    if (values.hours != null) {
      _date.setHours(values.hours);
    }

    if (values.minutes != null) {
      _date.setMinutes(values.minutes);
    }

    if (values.seconds != null) {
      _date.setSeconds(values.seconds);
    }

    if (values.milliseconds != null) {
      _date.setMilliseconds(values.milliseconds);
    }

    return _date;
  }

  /**
   * @name setDate
   * @category Day Helpers
   * @summary Set the day of the month to the given date.
   *
   * @description
   * Set the day of the month to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param dayOfMonth - The day of the month of the new date
   *
   * @returns The new date with the day of the month set
   *
   * @example
   * // Set the 30th day of the month to 1 September 2014:
   * const result = setDate(new Date(2014, 8, 1), 30)
   * //=> Tue Sep 30 2014 00:00:00
   */
  function setDate(date, dayOfMonth) {
    const _date = toDate(date);
    _date.setDate(dayOfMonth);
    return _date;
  }

  /**
   * @name setDayOfYear
   * @category Day Helpers
   * @summary Set the day of the year to the given date.
   *
   * @description
   * Set the day of the year to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param dayOfYear - The day of the year of the new date
   *
   * @returns The new date with the day of the year set
   *
   * @example
   * // Set the 2nd day of the year to 2 July 2014:
   * const result = setDayOfYear(new Date(2014, 6, 2), 2)
   * //=> Thu Jan 02 2014 00:00:00
   */
  function setDayOfYear(date, dayOfYear) {
    const _date = toDate(date);
    _date.setMonth(0);
    _date.setDate(dayOfYear);
    return _date;
  }

  /**
   * @name setDefaultOptions
   * @category Common Helpers
   * @summary Set default options including locale.
   * @pure false
   *
   * @description
   * Sets the defaults for
   * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
   * arguments for all functions.
   *
   * @param options - An object with options
   *
   * @example
   * // Set global locale:
   * import { es } from 'date-fns/locale'
   * setDefaultOptions({ locale: es })
   * const result = format(new Date(2014, 8, 2), 'PPPP')
   * //=> 'martes, 2 de septiembre de 2014'
   *
   * @example
   * // Start of the week for 2 September 2014:
   * const result = startOfWeek(new Date(2014, 8, 2))
   * //=> Sun Aug 31 2014 00:00:00
   *
   * @example
   * // Start of the week for 2 September 2014,
   * // when we set that week starts on Monday by default:
   * setDefaultOptions({ weekStartsOn: 1 })
   * const result = startOfWeek(new Date(2014, 8, 2))
   * //=> Mon Sep 01 2014 00:00:00
   *
   * @example
   * // Manually set options take priority over default options:
   * setDefaultOptions({ weekStartsOn: 1 })
   * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
   * //=> Sun Aug 31 2014 00:00:00
   *
   * @example
   * // Remove the option by setting it to `undefined`:
   * setDefaultOptions({ weekStartsOn: 1 })
   * setDefaultOptions({ weekStartsOn: undefined })
   * const result = startOfWeek(new Date(2014, 8, 2))
   * //=> Sun Aug 31 2014 00:00:00
   */
  function setDefaultOptions(options) {
    const result = {};
    const defaultOptions = getDefaultOptions$1();

    for (const property in defaultOptions) {
      if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        result[property] = defaultOptions[property];
      }
    }

    for (const property in options) {
      if (Object.prototype.hasOwnProperty.call(options, property)) {
        if (options[property] === undefined) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          delete result[property];
        } else {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          result[property] = options[property];
        }
      }
    }

    setDefaultOptions$1(result);
  }

  /**
   * @name setHours
   * @category Hour Helpers
   * @summary Set the hours to the given date.
   *
   * @description
   * Set the hours to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param hours - The hours of the new date
   *
   * @returns The new date with the hours set
   *
   * @example
   * // Set 4 hours to 1 September 2014 11:30:00:
   * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
   * //=> Mon Sep 01 2014 04:30:00
   */
  function setHours(date, hours) {
    const _date = toDate(date);
    _date.setHours(hours);
    return _date;
  }

  /**
   * @name setMilliseconds
   * @category Millisecond Helpers
   * @summary Set the milliseconds to the given date.
   *
   * @description
   * Set the milliseconds to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param milliseconds - The milliseconds of the new date
   *
   * @returns The new date with the milliseconds set
   *
   * @example
   * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
   * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
   * //=> Mon Sep 01 2014 11:30:40.300
   */
  function setMilliseconds(date, milliseconds) {
    const _date = toDate(date);
    _date.setMilliseconds(milliseconds);
    return _date;
  }

  /**
   * @name setMinutes
   * @category Minute Helpers
   * @summary Set the minutes to the given date.
   *
   * @description
   * Set the minutes to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param minutes - The minutes of the new date
   *
   * @returns The new date with the minutes set
   *
   * @example
   * // Set 45 minutes to 1 September 2014 11:30:40:
   * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
   * //=> Mon Sep 01 2014 11:45:40
   */
  function setMinutes(date, minutes) {
    const _date = toDate(date);
    _date.setMinutes(minutes);
    return _date;
  }

  /**
   * @name setQuarter
   * @category Quarter Helpers
   * @summary Set the year quarter to the given date.
   *
   * @description
   * Set the year quarter to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param quarter - The quarter of the new date
   *
   * @returns The new date with the quarter set
   *
   * @example
   * // Set the 2nd quarter to 2 July 2014:
   * const result = setQuarter(new Date(2014, 6, 2), 2)
   * //=> Wed Apr 02 2014 00:00:00
   */
  function setQuarter(date, quarter) {
    const _date = toDate(date);
    const oldQuarter = Math.floor(_date.getMonth() / 3) + 1;
    const diff = quarter - oldQuarter;
    return setMonth(_date, _date.getMonth() + diff * 3);
  }

  /**
   * @name setSeconds
   * @category Second Helpers
   * @summary Set the seconds to the given date.
   *
   * @description
   * Set the seconds to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param seconds - The seconds of the new date
   *
   * @returns The new date with the seconds set
   *
   * @example
   * // Set 45 seconds to 1 September 2014 11:30:40:
   * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
   * //=> Mon Sep 01 2014 11:30:45
   */
  function setSeconds(date, seconds) {
    const _date = toDate(date);
    _date.setSeconds(seconds);
    return _date;
  }

  /**
   * The {@link setWeekYear} function options.
   */

  /**
   * @name setWeekYear
   * @category Week-Numbering Year Helpers
   * @summary Set the local week-numbering year to the given date.
   *
   * @description
   * Set the local week-numbering year to the given date,
   * saving the week number and the weekday number.
   * The exact calculation depends on the values of
   * `options.weekStartsOn` (which is the index of the first day of the week)
   * and `options.firstWeekContainsDate` (which is the day of January, which is always in
   * the first week of the week-numbering year)
   *
   * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param weekYear - The local week-numbering year of the new date
   * @param options - An object with options
   *
   * @returns The new date with the local week-numbering year set
   *
   * @example
   * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
   * const result = setWeekYear(new Date(2010, 0, 2), 2004)
   * //=> Sat Jan 03 2004 00:00:00
   *
   * @example
   * // Set the local week-numbering year 2004 to 2 January 2010,
   * // if Monday is the first day of week
   * // and 4 January is always in the first week of the year:
   * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
   *   weekStartsOn: 1,
   *   firstWeekContainsDate: 4
   * })
   * //=> Sat Jan 01 2005 00:00:00
   */
  function setWeekYear(date, weekYear, options) {
    const defaultOptions = getDefaultOptions$1();
    const firstWeekContainsDate =
      options?.firstWeekContainsDate ??
      options?.locale?.options?.firstWeekContainsDate ??
      defaultOptions.firstWeekContainsDate ??
      defaultOptions.locale?.options?.firstWeekContainsDate ??
      1;

    let _date = toDate(date);
    const diff = differenceInCalendarDays(_date, startOfWeekYear(_date, options));
    const firstWeek = constructFrom(date, 0);
    firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    _date = startOfWeekYear(firstWeek, options);
    _date.setDate(_date.getDate() + diff);
    return _date;
  }

  /**
   * @name setYear
   * @category Year Helpers
   * @summary Set the year to the given date.
   *
   * @description
   * Set the year to the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param year - The year of the new date
   *
   * @returns The new date with the year set
   *
   * @example
   * // Set year 2013 to 1 September 2014:
   * const result = setYear(new Date(2014, 8, 1), 2013)
   * //=> Sun Sep 01 2013 00:00:00
   */
  function setYear(date, year) {
    const _date = toDate(date);

    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(+_date)) {
      return constructFrom(date, NaN);
    }

    _date.setFullYear(year);
    return _date;
  }

  /**
   * @name startOfDecade
   * @category Decade Helpers
   * @summary Return the start of a decade for the given date.
   *
   * @description
   * Return the start of a decade for the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The original date
   *
   * @returns The start of a decade
   *
   * @example
   * // The start of a decade for 21 October 2015 00:00:00:
   * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
   * //=> Jan 01 2010 00:00:00
   */
  function startOfDecade(date) {
    const _date = toDate(date);
    const year = _date.getFullYear();
    const decade = Math.floor(year / 10) * 10;
    _date.setFullYear(decade, 0, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }

  /**
   * @name startOfToday
   * @category Day Helpers
   * @summary Return the start of today.
   * @pure false
   *
   * @description
   * Return the start of today.
   *
   * @returns The start of today
   *
   * @example
   * // If today is 6 October 2014:
   * const result = startOfToday()
   * //=> Mon Oct 6 2014 00:00:00
   */
  function startOfToday() {
    return startOfDay(Date.now());
  }

  /**
   * @name startOfTomorrow
   * @category Day Helpers
   * @summary Return the start of tomorrow.
   * @pure false
   *
   * @description
   * Return the start of tomorrow.
   *
   * @returns The start of tomorrow
   *
   * @example
   * // If today is 6 October 2014:
   * const result = startOfTomorrow()
   * //=> Tue Oct 7 2014 00:00:00
   */
  function startOfTomorrow() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();

    const date = new Date(0);
    date.setFullYear(year, month, day + 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name startOfYesterday
   * @category Day Helpers
   * @summary Return the start of yesterday.
   * @pure false
   *
   * @description
   * Return the start of yesterday.
   *
   * @returns The start of yesterday
   *
   * @example
   * // If today is 6 October 2014:
   * const result = startOfYesterday()
   * //=> Sun Oct 5 2014 00:00:00
   */
  function startOfYesterday() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();

    const date = new Date(0);
    date.setFullYear(year, month, day - 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name subMonths
   * @category Month Helpers
   * @summary Subtract the specified number of months from the given date.
   *
   * @description
   * Subtract the specified number of months from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of months to be subtracted.
   *
   * @returns The new date with the months subtracted
   *
   * @example
   * // Subtract 5 months from 1 February 2015:
   * const result = subMonths(new Date(2015, 1, 1), 5)
   * //=> Mon Sep 01 2014 00:00:00
   */
  function subMonths(date, amount) {
    return addMonths(date, -amount);
  }

  /**
   * @name sub
   * @category Common Helpers
   * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
   *
   * @description
   * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
   *
   * | Key     | Description                        |
   * |---------|------------------------------------|
   * | years   | Amount of years to be subtracted   |
   * | months  | Amount of months to be subtracted  |
   * | weeks   | Amount of weeks to be subtracted   |
   * | days    | Amount of days to be subtracted    |
   * | hours   | Amount of hours to be subtracted   |
   * | minutes | Amount of minutes to be subtracted |
   * | seconds | Amount of seconds to be subtracted |
   *
   * All values default to 0
   *
   * @returns The new date with the seconds subtracted
   *
   * @example
   * // Subtract the following duration from 15 June 2017 15:29:20
   * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
   *   years: 2,
   *   months: 9,
   *   weeks: 1,
   *   days: 7,
   *   hours: 5,
   *   minutes: 9,
   *   seconds: 30
   * })
   * //=> Mon Sep 1 2014 10:19:50
   */
  function sub$1(date, duration) {
    const {
      years = 0,
      months = 0,
      weeks = 0,
      days = 0,
      hours = 0,
      minutes = 0,
      seconds = 0,
    } = duration;

    // Subtract years and months
    const dateWithoutMonths = subMonths(date, months + years * 12);

    // Subtract weeks and days
    const dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);

    // Subtract hours, minutes and seconds
    const minutestoSub = minutes + hours * 60;
    const secondstoSub = seconds + minutestoSub * 60;
    const mstoSub = secondstoSub * 1000;
    const finalDate = constructFrom(date, dateWithoutDays.getTime() - mstoSub);

    return finalDate;
  }

  /**
   * @name subBusinessDays
   * @category Day Helpers
   * @summary Substract the specified number of business days (mon - fri) to the given date.
   *
   * @description
   * Substract the specified number of business days (mon - fri) to the given date, ignoring weekends.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of business days to be subtracted.
   *
   * @returns The new date with the business days subtracted
   *
   * @example
   * // Substract 10 business days from 1 September 2014:
   * const result = subBusinessDays(new Date(2014, 8, 1), 10)
   * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
   */
  function subBusinessDays(date, amount) {
    return addBusinessDays(date, -amount);
  }

  /**
   * @name subHours
   * @category Hour Helpers
   * @summary Subtract the specified number of hours from the given date.
   *
   * @description
   * Subtract the specified number of hours from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of hours to be subtracted.
   *
   * @returns The new date with the hours subtracted
   *
   * @example
   * // Subtract 2 hours from 11 July 2014 01:00:00:
   * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
   * //=> Thu Jul 10 2014 23:00:00
   */
  function subHours(date, amount) {
    return addHours(date, -amount);
  }

  /**
   * @name subMilliseconds
   * @category Millisecond Helpers
   * @summary Subtract the specified number of milliseconds from the given date.
   *
   * @description
   * Subtract the specified number of milliseconds from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of milliseconds to be subtracted.
   *
   * @returns The new date with the milliseconds subtracted
   *
   * @example
   * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
   * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:29.250
   */
  function subMilliseconds(date, amount) {
    return addMilliseconds(date, -amount);
  }

  /**
   * @name subMinutes
   * @category Minute Helpers
   * @summary Subtract the specified number of minutes from the given date.
   *
   * @description
   * Subtract the specified number of minutes from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of minutes to be subtracted.
   *
   * @returns The new date with the minutes subtracted
   *
   * @example
   * // Subtract 30 minutes from 10 July 2014 12:00:00:
   * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
   * //=> Thu Jul 10 2014 11:30:00
   */
  function subMinutes(date, amount) {
    return addMinutes(date, -amount);
  }

  /**
   * @name subQuarters
   * @category Quarter Helpers
   * @summary Subtract the specified number of year quarters from the given date.
   *
   * @description
   * Subtract the specified number of year quarters from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of quarters to be subtracted.
   *
   * @returns The new date with the quarters subtracted
   *
   * @example
   * // Subtract 3 quarters from 1 September 2014:
   * const result = subQuarters(new Date(2014, 8, 1), 3)
   * //=> Sun Dec 01 2013 00:00:00
   */
  function subQuarters(date, amount) {
    return addQuarters(date, -amount);
  }

  /**
   * @name subSeconds
   * @category Second Helpers
   * @summary Subtract the specified number of seconds from the given date.
   *
   * @description
   * Subtract the specified number of seconds from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of seconds to be subtracted.
   *
   * @returns The new date with the seconds subtracted
   *
   * @example
   * // Subtract 30 seconds from 10 July 2014 12:45:00:
   * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
   * //=> Thu Jul 10 2014 12:44:30
   */
  function subSeconds(date, amount) {
    return addSeconds(date, -amount);
  }

  /**
   * @name subWeeks
   * @category Week Helpers
   * @summary Subtract the specified number of weeks from the given date.
   *
   * @description
   * Subtract the specified number of weeks from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of weeks to be subtracted.
   *
   * @returns The new date with the weeks subtracted
   *
   * @example
   * // Subtract 4 weeks from 1 September 2014:
   * const result = subWeeks(new Date(2014, 8, 1), 4)
   * //=> Mon Aug 04 2014 00:00:00
   */
  function subWeeks(date, amount) {
    return addWeeks(date, -amount);
  }

  /**
   * @name subYears
   * @category Year Helpers
   * @summary Subtract the specified number of years from the given date.
   *
   * @description
   * Subtract the specified number of years from the given date.
   *
   * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
   *
   * @param date - The date to be changed
   * @param amount - The amount of years to be subtracted.
   *
   * @returns The new date with the years subtracted
   *
   * @example
   * // Subtract 5 years from 1 September 2014:
   * const result = subYears(new Date(2014, 8, 1), 5)
   * //=> Tue Sep 01 2009 00:00:00
   */
  function subYears(date, amount) {
    return addYears(date, -amount);
  }

  /**
   * @name weeksToDays
   * @category Conversion Helpers
   * @summary Convert weeks to days.
   *
   * @description
   * Convert a number of weeks to a full number of days.
   *
   * @param weeks - The number of weeks to be converted
   *
   * @returns The number of weeks converted in days
   *
   * @example
   * // Convert 2 weeks into days
   * const result = weeksToDays(2)
   * //=> 14
   */
  function weeksToDays(weeks) {
    return Math.floor(weeks * daysInWeek);
  }

  /**
   * @name yearsToDays
   * @category Conversion Helpers
   * @summary Convert years to days.
   *
   * @description
   * Convert a number of years to a full number of days.
   *
   * @param years - The number of years to be converted
   *
   * @returns The number of years converted in days
   *
   * @example
   * // Convert 2 years into days
   * const result = yearsToDays(2)
   * //=> 24
   */
  function yearsToDays(years) {
    return Math.floor(years * daysInYear);
  }

  /**
   * @name yearsToMonths
   * @category Conversion Helpers
   * @summary Convert years to months.
   *
   * @description
   * Convert a number of years to a full number of months.
   *
   * @param years - The number of years to be converted
   *
   * @returns The number of years converted in months
   *
   * @example
   * // Convert 2 years into months
   * const result = yearsToMonths(2)
   * //=> 24
   */
  function yearsToMonths(years) {
    return Math.floor(years * monthsInYear);
  }

  /**
   * @name yearsToQuarters
   * @category Conversion Helpers
   * @summary Convert years to quarters.
   *
   * @description
   * Convert a number of years to a full number of quarters.
   *
   * @param years - The number of years to be converted
   *
   * @returns The number of years converted in quarters
   *
   * @example
   * // Convert 2 years to quarters
   * const result = yearsToQuarters(2)
   * //=> 8
   */
  function yearsToQuarters(years) {
    return Math.floor(years * quartersInYear);
  }

  // This file is generated automatically by `scripts/build/indices.ts`. Please, don't change it.

  var datefns = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$2,
    addBusinessDays: addBusinessDays,
    addDays: addDays,
    addHours: addHours,
    addISOWeekYears: addISOWeekYears,
    addMilliseconds: addMilliseconds,
    addMinutes: addMinutes,
    addMonths: addMonths,
    addQuarters: addQuarters,
    addSeconds: addSeconds,
    addWeeks: addWeeks,
    addYears: addYears,
    areIntervalsOverlapping: areIntervalsOverlapping,
    clamp: clamp$2,
    closestIndexTo: closestIndexTo,
    closestTo: closestTo,
    compareAsc: compareAsc,
    compareDesc: compareDesc,
    constructFrom: constructFrom,
    daysToWeeks: daysToWeeks,
    differenceInBusinessDays: differenceInBusinessDays,
    differenceInCalendarDays: differenceInCalendarDays,
    differenceInCalendarISOWeekYears: differenceInCalendarISOWeekYears,
    differenceInCalendarISOWeeks: differenceInCalendarISOWeeks,
    differenceInCalendarMonths: differenceInCalendarMonths,
    differenceInCalendarQuarters: differenceInCalendarQuarters,
    differenceInCalendarWeeks: differenceInCalendarWeeks,
    differenceInCalendarYears: differenceInCalendarYears,
    differenceInDays: differenceInDays,
    differenceInHours: differenceInHours,
    differenceInISOWeekYears: differenceInISOWeekYears,
    differenceInMilliseconds: differenceInMilliseconds,
    differenceInMinutes: differenceInMinutes,
    differenceInMonths: differenceInMonths,
    differenceInQuarters: differenceInQuarters,
    differenceInSeconds: differenceInSeconds,
    differenceInWeeks: differenceInWeeks,
    differenceInYears: differenceInYears,
    eachDayOfInterval: eachDayOfInterval,
    eachHourOfInterval: eachHourOfInterval,
    eachMinuteOfInterval: eachMinuteOfInterval,
    eachMonthOfInterval: eachMonthOfInterval,
    eachQuarterOfInterval: eachQuarterOfInterval,
    eachWeekOfInterval: eachWeekOfInterval,
    eachWeekendOfInterval: eachWeekendOfInterval,
    eachWeekendOfMonth: eachWeekendOfMonth,
    eachWeekendOfYear: eachWeekendOfYear,
    eachYearOfInterval: eachYearOfInterval,
    endOfDay: endOfDay,
    endOfDecade: endOfDecade,
    endOfHour: endOfHour,
    endOfISOWeek: endOfISOWeek,
    endOfISOWeekYear: endOfISOWeekYear,
    endOfMinute: endOfMinute,
    endOfMonth: endOfMonth,
    endOfQuarter: endOfQuarter,
    endOfSecond: endOfSecond,
    endOfToday: endOfToday,
    endOfTomorrow: endOfTomorrow,
    endOfWeek: endOfWeek,
    endOfYear: endOfYear,
    endOfYesterday: endOfYesterday,
    format: format,
    formatDistance: formatDistance,
    formatDistanceStrict: formatDistanceStrict,
    formatDistanceToNow: formatDistanceToNow,
    formatDistanceToNowStrict: formatDistanceToNowStrict,
    formatDuration: formatDuration,
    formatISO: formatISO,
    formatISO9075: formatISO9075,
    formatISODuration: formatISODuration,
    formatRFC3339: formatRFC3339,
    formatRFC7231: formatRFC7231,
    formatRelative: formatRelative,
    formatters: formatters,
    fromUnixTime: fromUnixTime,
    getDate: getDate,
    getDay: getDay,
    getDayOfYear: getDayOfYear,
    getDaysInMonth: getDaysInMonth,
    getDaysInYear: getDaysInYear,
    getDecade: getDecade,
    getDefaultOptions: getDefaultOptions,
    getHours: getHours,
    getISODay: getISODay,
    getISOWeek: getISOWeek,
    getISOWeekYear: getISOWeekYear,
    getISOWeeksInYear: getISOWeeksInYear,
    getMilliseconds: getMilliseconds,
    getMinutes: getMinutes,
    getMonth: getMonth,
    getOverlappingDaysInIntervals: getOverlappingDaysInIntervals,
    getQuarter: getQuarter,
    getSeconds: getSeconds,
    getTime: getTime,
    getUnixTime: getUnixTime,
    getWeek: getWeek,
    getWeekOfMonth: getWeekOfMonth,
    getWeekYear: getWeekYear,
    getWeeksInMonth: getWeeksInMonth,
    getYear: getYear,
    hoursToMilliseconds: hoursToMilliseconds,
    hoursToMinutes: hoursToMinutes,
    hoursToSeconds: hoursToSeconds,
    interval: interval,
    intervalToDuration: intervalToDuration,
    intlFormat: intlFormat,
    intlFormatDistance: intlFormatDistance,
    isAfter: isAfter,
    isBefore: isBefore,
    isDate: isDate,
    isEqual: isEqual,
    isExists: isExists,
    isFirstDayOfMonth: isFirstDayOfMonth,
    isFriday: isFriday,
    isFuture: isFuture,
    isLastDayOfMonth: isLastDayOfMonth,
    isLeapYear: isLeapYear,
    isMatch: isMatch,
    isMonday: isMonday,
    isPast: isPast,
    isSameDay: isSameDay,
    isSameHour: isSameHour,
    isSameISOWeek: isSameISOWeek,
    isSameISOWeekYear: isSameISOWeekYear,
    isSameMinute: isSameMinute,
    isSameMonth: isSameMonth,
    isSameQuarter: isSameQuarter,
    isSameSecond: isSameSecond,
    isSameWeek: isSameWeek,
    isSameYear: isSameYear,
    isSaturday: isSaturday,
    isSunday: isSunday,
    isThisHour: isThisHour,
    isThisISOWeek: isThisISOWeek,
    isThisMinute: isThisMinute,
    isThisMonth: isThisMonth,
    isThisQuarter: isThisQuarter,
    isThisSecond: isThisSecond,
    isThisWeek: isThisWeek,
    isThisYear: isThisYear,
    isThursday: isThursday,
    isToday: isToday,
    isTomorrow: isTomorrow,
    isTuesday: isTuesday,
    isValid: isValid,
    isWednesday: isWednesday,
    isWeekend: isWeekend,
    isWithinInterval: isWithinInterval,
    isYesterday: isYesterday,
    lastDayOfDecade: lastDayOfDecade,
    lastDayOfISOWeek: lastDayOfISOWeek,
    lastDayOfISOWeekYear: lastDayOfISOWeekYear,
    lastDayOfMonth: lastDayOfMonth,
    lastDayOfQuarter: lastDayOfQuarter,
    lastDayOfWeek: lastDayOfWeek,
    lastDayOfYear: lastDayOfYear,
    lightFormat: lightFormat,
    lightFormatters: lightFormatters,
    longFormatters: longFormatters,
    max: max$2,
    milliseconds: milliseconds,
    millisecondsToHours: millisecondsToHours,
    millisecondsToMinutes: millisecondsToMinutes,
    millisecondsToSeconds: millisecondsToSeconds,
    min: min$2,
    minutesToHours: minutesToHours,
    minutesToMilliseconds: minutesToMilliseconds,
    minutesToSeconds: minutesToSeconds,
    monthsToQuarters: monthsToQuarters,
    monthsToYears: monthsToYears,
    nextDay: nextDay,
    nextFriday: nextFriday,
    nextMonday: nextMonday,
    nextSaturday: nextSaturday,
    nextSunday: nextSunday,
    nextThursday: nextThursday,
    nextTuesday: nextTuesday,
    nextWednesday: nextWednesday,
    parse: parse,
    parseISO: parseISO,
    parseJSON: parseJSON,
    parsers: parsers,
    previousDay: previousDay,
    previousFriday: previousFriday,
    previousMonday: previousMonday,
    previousSaturday: previousSaturday,
    previousSunday: previousSunday,
    previousThursday: previousThursday,
    previousTuesday: previousTuesday,
    previousWednesday: previousWednesday,
    quartersToMonths: quartersToMonths,
    quartersToYears: quartersToYears,
    roundToNearestMinutes: roundToNearestMinutes,
    secondsToHours: secondsToHours,
    secondsToMilliseconds: secondsToMilliseconds,
    secondsToMinutes: secondsToMinutes,
    set: set$1,
    setDate: setDate,
    setDay: setDay,
    setDayOfYear: setDayOfYear,
    setDefaultOptions: setDefaultOptions,
    setHours: setHours,
    setISODay: setISODay,
    setISOWeek: setISOWeek,
    setISOWeekYear: setISOWeekYear,
    setMilliseconds: setMilliseconds,
    setMinutes: setMinutes,
    setMonth: setMonth,
    setQuarter: setQuarter,
    setSeconds: setSeconds,
    setWeek: setWeek,
    setWeekYear: setWeekYear,
    setYear: setYear,
    startOfDay: startOfDay,
    startOfDecade: startOfDecade,
    startOfHour: startOfHour,
    startOfISOWeek: startOfISOWeek,
    startOfISOWeekYear: startOfISOWeekYear,
    startOfMinute: startOfMinute,
    startOfMonth: startOfMonth,
    startOfQuarter: startOfQuarter,
    startOfSecond: startOfSecond,
    startOfToday: startOfToday,
    startOfTomorrow: startOfTomorrow,
    startOfWeek: startOfWeek,
    startOfWeekYear: startOfWeekYear,
    startOfYear: startOfYear,
    startOfYesterday: startOfYesterday,
    sub: sub$1,
    subBusinessDays: subBusinessDays,
    subDays: subDays,
    subHours: subHours,
    subISOWeekYears: subISOWeekYears,
    subMilliseconds: subMilliseconds,
    subMinutes: subMinutes,
    subMonths: subMonths,
    subQuarters: subQuarters,
    subSeconds: subSeconds,
    subWeeks: subWeeks,
    subYears: subYears,
    toDate: toDate,
    transpose: transpose$1,
    weeksToDays: weeksToDays,
    yearsToDays: yearsToDays,
    yearsToMonths: yearsToMonths,
    yearsToQuarters: yearsToQuarters
  });

  /*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */


  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


    // The maximum exponent magnitude.
    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,                      // 0 to 9e15

    // The limit on the value of `precision`, and on the value of the first argument to
    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
    MAX_DIGITS = 1e9,                        // 0 to 1e9

    // Base conversion alphabet.
    NUMERALS = '0123456789abcdef',

    // The natural logarithm of 10 (1025 digits).
    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

    // Pi (1025 digits).
    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


    // The initial configuration properties of the Decimal constructor.
    DEFAULTS = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,                             // 0 to 9

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -EXP_LIMIT

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to EXP_LIMIT

      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false                          // true/false
    },


  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


    inexact, quadrant,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    precisionLimitExceeded = decimalError + 'Precision limit exceeded',
    cryptoUnavailable = decimalError + 'crypto unavailable',
    tag = '[object Decimal]',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,

    LN10_PRECISION = LN10.length - 1,
    PI_PRECISION = PI.length - 1,

    // Decimal.prototype object
    P = { toStringTag: tag };


  // Decimal prototype methods


  /*
   *  absoluteValue             abs
   *  ceil
   *  clampedTo                 clamp
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */
  P.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal clamped to the range
   * delineated by `min` and `max`.
   *
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  P.clampedTo = P.clamp = function (min, max) {
    var k,
      x = this,
      Ctor = x.constructor;
    min = new Ctor(min);
    max = new Ctor(max);
    if (!min.s || !max.s) return new Ctor(NaN);
    if (min.gt(max)) throw Error(invalidArgument + max);
    k = x.cmp(min);
    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this,
      xd = x.d,
      yd = (y = new x.constructor(y)).d,
      xs = x.s,
      ys = y.s;

    // Either NaN or Infinity?
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }

    // Either zero?
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

    // Signs differ?
    if (xs !== ys) return xs;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

    xdL = xd.length;
    ydL = yd.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };


  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */
  P.cosine = P.cos = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.d) return new Ctor(NaN);

    // cos(0) = cos(-0) = 1
    if (!x.d[0]) return new Ctor(1);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };


  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * mathpow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;

      // Adjust n exponent so it is a multiple of 3 away from x exponent.
      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
      s = mathpow(n, 1 / 3);

      // Rarely, e may be one less than the result exponent value.
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Halley's method.
    // TODO? Compare Newton's method.
    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var w,
      d = this.d,
      n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last word.
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide$1(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedToIntegerBy = P.divToInt = function (y) {
    var x = this,
      Ctor = x.constructor;
    return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */
  P.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */
  P.hyperbolicCosine = P.cosh = function () {
    var k, n, pr, rm, len,
      x = this,
      Ctor = x.constructor,
      one = new Ctor(1);

    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

    // Reverse argument reduction
    var cosh2_x,
      i = k,
      d8 = new Ctor(8);
    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */
  P.hyperbolicSine = P.sinh = function () {
    var k, pr, rm, len,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {

      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition

      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);

      // Reverse argument reduction
      var sinh2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */
  P.hyperbolicTangent = P.tanh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;

    return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };


  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */
  P.inverseCosine = P.acos = function () {
    var halfPi,
      x = this,
      Ctor = x.constructor,
      k = x.abs().cmp(1),
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0
        // |x| is 1
        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
        // |x| > 1 or x is NaN
        : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return halfPi.minus(x);
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).minus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */
  P.inverseHyperbolicSine = P.asinh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).plus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */
  P.inverseHyperbolicTangent = P.atanh = function () {
    var pr, rm, wpr, xsd,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();

    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

    Ctor.precision = wpr = xsd - x.e;

    x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

    Ctor.precision = pr + 4;
    Ctor.rounding = 1;

    x = x.ln();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(0.5);
  };


  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */
  P.inverseSine = P.asin = function () {
    var halfPi, k,
      pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.isZero()) return new Ctor(x);

    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {

      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }

      // |x| > 1 or x is NaN
      return new Ctor(NaN);
    }

    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(2);
  };


  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */
  P.inverseTangent = P.atan = function () {
    var i, j, k, n, px, t, r, wpr, x2,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;

    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

    external = false;

    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;

    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));

      px = px.times(x2);
      r = t.plus(px.div(n += 2));

      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
    }

    if (k) r = r.times(2 << (k - 1));

    external = true;

    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */
  P.isFinite = function () {
    return !!this.d;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isNeg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.isPos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */
  P.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var isBase10, d, denominator, k, inf, num, sd, r,
      arg = this,
      Ctor = arg.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding,
      guard = 5;

    // Default base is 10.
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;

      // Return NaN if base is negative, or non-finite, or is 0 or 1.
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

      isBase10 = base.eq(10);
    }

    d = arg.d;

    // Is arg negative, non-finite, 0 or 1?
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }

    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) k /= 10;
        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

    // The result will have 5 rounding digits.
    r = divide$1(num, denominator, sd, 1);

    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.
    if (checkRoundingDigits(r.d, k = pr, rm)) {

      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide$1(num, denominator, sd, 1);

        if (!inf) {

          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;

    return finalise(r, pr, rm);
  };


  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */


  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.minus = P.sub = function (y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return y negated if x is finite and y is Infinity.
      else if (x.d) y.s = -y.s;

      // Return x if y is finite and x is Infinity.
      // Return x if both are Infinity with different signs.
      // Return NaN if both are Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

      return y;
    }

    // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s;

      // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x);

      // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);

    xd = xd.slice();
    k = xe - e;

    // If base 1e7 exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {

      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // Return NaN if x is Infinity or NaN, or y is NaN or 0.
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

    // Return x if y is Infinity or x is 0.
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }

    // Prevent rounding of intermediate calculations.
    external = false;

    if (Ctor.modulo == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide$1(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide$1(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);

    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.naturalExponential = P.exp = function () {
    return naturalExponential(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return naturalLogarithm(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.plus = P.add = function (y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return x if y is finite and x is Infinity.
      // Return x if both are Infinity with the same sign.
      // Return NaN if both are Infinity with different signs.
      // Return y if x is finite and y is Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

      return y;
    }

     // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);

    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {

      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var k,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.round = function () {
    var x = this,
      Ctor = x.constructor;

    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };


  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */
  P.sine = P.sin = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = sine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, sd, r, rep, t,
      x = this,
      d = x.d,
      e = x.e,
      s = x.s,
      Ctor = x.constructor;

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);

      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */
  P.tangent = P.tan = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;

    x = x.sin();
    x.s = 1;
    x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    y.s *= x.s;

     // If either is NaN, Infinity or 0...
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

        // Return NaN if either is NaN.
        // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
        ? NaN

        // Return Infinity if either is Infinity.
        // Return 0 if either is 0.
        : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = getBase10Exponent(r, e);

    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };


  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.toDP = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return finalise(x, dp + x.e + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */
  P.toFraction = function (maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
      x = this,
      xd = x.d,
      Ctor = x.constructor;

    if (!xd) return new Ctor(x);

    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);

    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {

      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;)  {
      q = divide$1(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;

    // Determine which fraction is closer to x, n0/d0 or n1/d1?
    r = divide$1(n1, d1, e, 1).minus(x).abs().cmp(divide$1(n0, d0, e, 1).minus(x).abs()) < 1
        ? [n1, d1] : [n0, d0];

    Ctor.precision = pr;
    external = true;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toHexadecimal = P.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };


  /*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */
  P.toNearest = function (y, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);

    if (y == null) {

      // If x is not finite, return x.
      if (!x.d) return x;

      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }

      // If x is not finite, return x if y is not NaN, else NaN.
      if (!x.d) return y.s ? x : y;

      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }

    // If y is not zero, calculate the nearest multiple of y to x.
    if (y.d[0]) {
      external = false;
      x = divide$1(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);

    // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, 0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, rm, s,
      x = this,
      Ctor = x.constructor,
      yn = +(y = new Ctor(y));

    // Either Infinity, NaN or 0?
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

    x = new Ctor(x);

    if (x.eq(1)) return x;

    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (y.eq(1)) return finalise(x, pr, rm);

    // y exponent
    e = mathfloor(y.e / LOG_BASE);

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    s = x.s;

    // if x is negative
    if (s < 0) {

      // if y is not an integer
      if (e < y.d.length - 1) return new Ctor(NaN);

      // Result is positive if x is negative and the last digit of integer y is even.
      if ((y.d[e] & 1) == 0) s = 1;

      // if x.eq(-1)
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }

    // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e;

    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

    // Overflow/underflow?
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

    external = false;
    Ctor.rounding = x.s = 1;

    // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
    k = Math.min(12, (e + '').length);

    // r = x^y = exp(y*ln(x))
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
    if (r.d) {

      // Truncate to the required precision plus five rounding digits.
      r = finalise(r, pr + 5, 1);

      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
      // the result.
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;

        // Truncate to the increased precision plus five rounding digits.
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }

    r.s = s;
    external = true;
    Ctor.rounding = rm;

    return finalise(r, pr, rm);
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */
  P.toSignificantDigits = P.toSD = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */
  P.truncated = P.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };


  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */
  P.valueOf = P.toJSON = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() ? '-' + str : str;
  };


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;

    // Get the length of the first word of the array d.
    for (k = d[0]; k >= 10; k /= 10) --i;

    // Is the rounding digit in the first word of d?
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }

    // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k ||
        (!repeating && rm > 3) && rd + 1 == k / 2) &&
          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  }


  // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
  function convertBase(str, baseIn, baseOut) {
    var j,
      arr = [0],
      arrL,
      i = 0,
      strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }


  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */
  function cosine(Ctor, x) {
    var k, len, y;

    if (x.isZero()) return x;

    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

    // Estimate the optimum number of times to use the argument reduction.
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;

    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

    // Reverse argument reduction
    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;

    return x;
  }


  /*
   * Perform division in the specified base.
   */
  var divide$1 = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
        yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either NaN, Infinity or 0?
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.
      for (i = 0; yd[i] == (xd[i] || 0); i++);

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;

          // k is the carry.
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL;

        // divisor >= 1e7
        } else {

          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL;) rem[remL++] = 0;

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];

          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0;

            // Compare divisor and remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // k will be how many times the divisor goes into the current remainder.
              k = rem0 / yd0 | 0;

              //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1;

                // product = divisor * trial digit.
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                cmp = compare(prod, rem, prodL, remL);

                // product > remainder.
                if (cmp == 1) {
                  k--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {

                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);

              // If product was < previous remainder.
              if (cmp == -1) {
                remL = rem.length;

                // Compare divisor and new remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < new remainder, subtract divisor from remainder.
                if (cmp < 1) {
                  k++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }    // if cmp === 1, k will be 0

            // Add the next digit, k, to the result array.
            qd[i++] = k;

            // Update the remainder.
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }

          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        }

        // Leading zero?
        if (!qd[0]) qd.shift();
      }

      // logBase is 1 when divide is being used for base conversion.
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {

        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;

        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  })();


  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */
   function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi,
      Ctor = x.constructor;

    // Don't round if sd is null or undefined.
    out: if (sd != null) {
      xd = x.d;

      // Infinity/NaN.
      if (!xd) return x;

      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

      // Get the length of the first word of the digits array xd.
      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
      i = sd - digits;

      // Is the rounding digit in the first word of xd?
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];

        // Get the rounding digit at index j of w.
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {

            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];

          // Get the number of digits of w.
          for (digits = 1; k >= 10; k /= 10) digits++;

          // Get the index of rd within w.
          i %= LOG_BASE;

          // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.
          j = i - LOG_BASE + digits;

          // Get the rounding digit at index j of w.
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }

      // Are there any non-zero digits after the rounding digit?
      isTruncated = isTruncated || sd < 0 ||
        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {

          // Convert sd to decimal places.
          sd -= x.e + 1;

          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {

          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      }

      // Remove excess digits.
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {

          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {

            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;

            // if i != k the length has increased.
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }

      // Remove trailing zeros.
      for (i = xd.length; xd[--i] === 0;) xd.pop();
    }

    if (external) {

      // Overflow?
      if (x.e > Ctor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < Ctor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // Ctor.underflow = true;
      } // else Ctor.underflow = false;
    }

    return x;
  }


  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
      e = x.e,
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(digits, e) {
    var w = digits[0];

    // Add the number of digits of the first word of the digits array.
    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
    return e;
  }


  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {

      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }


  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }


  function getPrecision(digits) {
    var w = digits.length - 1,
      len = w * LOG_BASE + 1;

    w = digits[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) len--;

      // Add the number of digits of the first word.
      for (w = digits[0]; w >= 10; w /= 10) len++;
    }

    return len;
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */
  function intPow(Ctor, x, n, pr) {
    var isTruncated,
      r = new Ctor(1),

      // Max n of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      k = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);
      if (n === 0) {

        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;

    return r;
  }


  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }


  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */
  function maxOrMin(Ctor, args, ltgt) {
    var y,
      x = new Ctor(args[0]),
      i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow, sum, t, wpr,
      rep = 0,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // 0/NaN/Infinity?
    if (!x.d || !x.d[0] || x.e > 17) {

      return new Ctor(x.d
        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
        : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    // while abs(x) >= 0.1
    while (x.e > -2) {

      // x = x / 2^5
      x = x.times(t);
      k += 5;
    }

    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide$1(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;
        while (j--) sum = finalise(sum.times(sum), wpr, 1);

        // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {

          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // Is x negative or Infinity, NaN, 0 or 1?
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;

      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }

    // x1 is x reduced to a value near 1.
    x1 = x;

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide$1(sum, new Ctor(n), wpr, 1);

        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  }


  // Infinity, NaN.
  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external) {

        // Overflow?
        if (x.e > x.constructor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < x.constructor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;
      }
    } else {

      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str.indexOf('_') > -1) {
      str = str.replace(/(\d)_(?=\d)/g, '$1');
      if (isDecimal.test(str)) return parseDecimal(x, str);
    } else if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str))  {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str))  {
      base = 2;
    } else if (isOctal.test(str))  {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }

    // Is there a binary exponent part?
    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }

    // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.
    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i;

      // log[10](16) = 1.2041... , log[10](88) = 1.9444....
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;

    // Remove trailing zeros.
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;

    // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.
    if (isFloat) x = divide$1(x, divisor, len * 4);

    // Multiply by the binary exponent part if present.
    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;

    return x;
  }


  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */
  function sine(Ctor, x) {
    var k,
      len = x.d.length;

    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }

    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);

    // Reverse argument reduction
    var sin2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  }


  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2,
      pr = Ctor.precision,
      k = Math.ceil(pr / LOG_BASE);

    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;);
        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
    }

    external = true;
    t.d.length = k + 1;

    return t;
  }


  // Exponent e must be positive and non-zero.
  function tinyPow(b, e) {
    var n = b;
    while (--e) n *= b;
    return n;
  }


  // Return the absolute value of `x` reduced to less than or equal to half pi.
  function toLessThanHalfPi(Ctor, x) {
    var t,
      isNeg = x.s < 0,
      pi = getPi(Ctor, Ctor.precision, 1),
      halfPi = pi.times(0.5);

    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));

      // 0 <= x < pi
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
        return x;
      }

      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
    }

    return x.minus(pi).abs();
  }


  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y,
      Ctor = x.constructor,
      isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.');

      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }

      // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.

      // Non-integer.
      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length;

      // Remove trailing zeros.
      for (; xd[--len] == 0;) xd.pop();

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide$1(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }

        // The rounding digit, i.e. the digit after the digit that may be rounded up.
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;

        roundUp = rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
            rm === (x.s < 0 ? 8 : 7));

        xd.length = sd;

        if (roundUp) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }

        // Determine trailing zeros.
        for (len = xd.length; !xd[len - 1]; --len);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

        // Add binary exponent suffix?
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += '0';
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len);

              // xd[0] will always be be 1
              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str =  str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) str = '0' + str;
          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e-- ;) str += '0';
          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clamp
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  sum
   *  tan
   *  tanh
   *  trunc
   */


  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function abs(x) {
    return new this(x).abs();
  }


  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function acos(x) {
    return new this(x).acos();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function acosh(x) {
    return new this(x).acosh();
  }


  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function add$1(x, y) {
    return new this(x).plus(y);
  }


  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function asin(x) {
    return new this(x).asin();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function asinh(x) {
    return new this(x).asinh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function atan(x) {
    return new this(x).atan();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function atanh(x) {
    return new this(x).atanh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(0, -0)               = pi
   * atan2(0, +0)               = 0
   * atan2(0, -x)               = pi for x > 0
   * atan2(0, x)                = 0 for x > 0
   * atan2(-y, 0)               = -pi/2 for y > 0
   * atan2(y, 0)                = pi/2 for y > 0
   * atan2(y, -Infinity)        = pi for finite y > 0
   * atan2(y, +Infinity)        = 0 for finite y > 0
   * atan2(Infinity, x)         = pi/2 for finite x
   * atan2(Infinity, -Infinity) = 3*pi/4
   * atan2(Infinity, +Infinity) = pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
      pr = this.precision,
      rm = this.rounding,
      wpr = pr + 4;

    // Either NaN
    if (!y.s || !x.s) {
      r = new this(NaN);

    // Both Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;

    // x is Infinity or y is 0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;

    // y is Infinity or x is 0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;

    // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide$1(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide$1(y, x, wpr, 1));
    }

    return r;
  }


  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function cbrt(x) {
    return new this(x).cbrt();
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }


  /*
   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
   *
   * x {number|string|Decimal}
   * min {number|string|Decimal}
   * max {number|string|Decimal}
   *
   */
  function clamp$1(x, min, max) {
    return new this(x).clamp(min, max);
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i, p, v,
      useDefaults = obj.defaults === true,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -EXP_LIMIT, 0,
        'toExpPos', 0, EXP_LIMIT,
        'maxE', 0, EXP_LIMIT,
        'minE', -EXP_LIMIT, 0,
        'modulo', 0, 9
      ];

    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != 'undefined' && crypto &&
            (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }


  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cos(x) {
    return new this(x).cos();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cosh(x) {
    return new this(x).cosh();
  }


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone$2(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(v) {
      var e, i, t,
        x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(v);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (isDecimalInstance(v)) {
        x.s = v.s;

        if (external) {
          if (!v.d || v.e > Decimal.maxE) {

            // Infinity.
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }

        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }

        // Fast path for small integers.
        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) e++;

          if (external) {
            if (e > Decimal.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }

          return;

        // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());

      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      }

      // Minus sign?
      if ((i = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        // Plus sign?
        if (i === 43) v = v.slice(1);
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;

    Decimal.config = Decimal.set = config;
    Decimal.clone = clone$2;
    Decimal.isDecimal = isDecimalInstance;

    Decimal.abs = abs;
    Decimal.acos = acos;
    Decimal.acosh = acosh;        // ES6
    Decimal.add = add$1;
    Decimal.asin = asin;
    Decimal.asinh = asinh;        // ES6
    Decimal.atan = atan;
    Decimal.atanh = atanh;        // ES6
    Decimal.atan2 = atan2;
    Decimal.cbrt = cbrt;          // ES6
    Decimal.ceil = ceil;
    Decimal.clamp = clamp$1;
    Decimal.cos = cos;
    Decimal.cosh = cosh;          // ES6
    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.hypot = hypot;        // ES6
    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10;        // ES6
    Decimal.log2 = log2;          // ES6
    Decimal.max = max$1;
    Decimal.min = min$1;
    Decimal.mod = mod;
    Decimal.mul = mul;
    Decimal.pow = pow;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign;          // ES6
    Decimal.sin = sin;
    Decimal.sinh = sinh;          // ES6
    Decimal.sqrt = sqrt;
    Decimal.sub = sub;
    Decimal.sum = sum$1;
    Decimal.tan = tan;
    Decimal.tanh = tanh;          // ES6
    Decimal.trunc = trunc;        // ES6

    if (obj === void 0) obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
      }
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function div(x, y) {
    return new this(x).div(y);
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */
  function exp(x) {
    return new this(x).exp();
  }


  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }


  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */
  function hypot() {
    var i, n,
      t = new this(0);

    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;

    return t.sqrt();
  }


  /*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function ln(x) {
    return new this(x).ln();
  }


  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */
  function log(x, y) {
    return new this(x).log(y);
  }


  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log2(x) {
    return new this(x).log(2);
  }


  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log10(x) {
    return new this(x).log(10);
  }


  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function max$1() {
    return maxOrMin(this, arguments, 'lt');
  }


  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function min$1() {
    return maxOrMin(this, arguments, 'gt');
  }


  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mod(x, y) {
    return new this(x).mod(y);
  }


  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mul(x, y) {
    return new this(x).mul(y);
  }


  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */
  function pow(x, y) {
    return new this(x).pow(y);
  }


  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */
  function random(sd) {
    var d, e, k, n,
      i = 0,
      r = new this(1),
      rd = [];

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i];

        // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
        if (n >= 4.29e9) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {

          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      }

    // Node.js supporting crypto.randomBytes.
    } else if (crypto.randomBytes) {

      // buffer
      d = crypto.randomBytes(k *= 4);

      for (; i < k;) {

        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
        if (n >= 2.14e9) {
          crypto.randomBytes(4).copy(d, i);
        } else {

          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }

    k = rd[--i];
    sd %= LOG_BASE;

    // Convert trailing digits to zeros according to sd.
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }

    // Remove trailing words which are zero.
    for (; rd[i] === 0; i--) rd.pop();

    // Zero?
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;

      // Remove leading words which are zero and adjust exponent accordingly.
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

      // Count the digits of the first word of rd to determine leading zeros.
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

      // Adjust the exponent for leading zeros of the first word of rd.
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;

    return r;
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }


  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */
  function sign(x) {
    x = new this(x);
    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
  }


  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sin(x) {
    return new this(x).sin();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sinh(x) {
    return new this(x).sinh();
  }


  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function sqrt(x) {
    return new this(x).sqrt();
  }


  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function sub(x, y) {
    return new this(x).sub(y);
  }


  /*
   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * Only the result is rounded, not the intermediate calculations.
   *
   * arguments {number|string|Decimal}
   *
   */
  function sum$1() {
    var i = 0,
      args = arguments,
      x = new this(args[i]);

    external = false;
    for (; x.s && ++i < args.length;) x = x.plus(args[i]);
    external = true;

    return finalise(x, this.precision, this.rounding);
  }


  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tan(x) {
    return new this(x).tan();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tanh(x) {
    return new this(x).tanh();
  }


  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }


  P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
  P[Symbol.toStringTag] = 'Decimal';

  // Create and configure initial Decimal constructor.
  var Decimal = P.constructor = clone$2(DEFAULTS);

  // Create the internal constants from their string values.
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var numeral$1 = {exports: {}};

  /*! @preserve
   * numeral.js
   * version : 2.0.6
   * author : Adam Draper
   * license : MIT
   * http://adamwdraper.github.com/Numeral-js/
   */

  (function (module) {
  	(function (global, factory) {
  	    if (module.exports) {
  	        module.exports = factory();
  	    } else {
  	        global.numeral = factory();
  	    }
  	}(commonjsGlobal, function () {
  	    /************************************
  	        Variables
  	    ************************************/

  	    var numeral,
  	        _,
  	        VERSION = '2.0.6',
  	        formats = {},
  	        locales = {},
  	        defaults = {
  	            currentLocale: 'en',
  	            zeroFormat: null,
  	            nullFormat: null,
  	            defaultFormat: '0,0',
  	            scalePercentBy100: true
  	        },
  	        options = {
  	            currentLocale: defaults.currentLocale,
  	            zeroFormat: defaults.zeroFormat,
  	            nullFormat: defaults.nullFormat,
  	            defaultFormat: defaults.defaultFormat,
  	            scalePercentBy100: defaults.scalePercentBy100
  	        };


  	    /************************************
  	        Constructors
  	    ************************************/

  	    // Numeral prototype object
  	    function Numeral(input, number) {
  	        this._input = input;

  	        this._value = number;
  	    }

  	    numeral = function(input) {
  	        var value,
  	            kind,
  	            unformatFunction,
  	            regexp;

  	        if (numeral.isNumeral(input)) {
  	            value = input.value();
  	        } else if (input === 0 || typeof input === 'undefined') {
  	            value = 0;
  	        } else if (input === null || _.isNaN(input)) {
  	            value = null;
  	        } else if (typeof input === 'string') {
  	            if (options.zeroFormat && input === options.zeroFormat) {
  	                value = 0;
  	            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
  	                value = null;
  	            } else {
  	                for (kind in formats) {
  	                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

  	                    if (regexp && input.match(regexp)) {
  	                        unformatFunction = formats[kind].unformat;

  	                        break;
  	                    }
  	                }

  	                unformatFunction = unformatFunction || numeral._.stringToNumber;

  	                value = unformatFunction(input);
  	            }
  	        } else {
  	            value = Number(input)|| null;
  	        }

  	        return new Numeral(input, value);
  	    };

  	    // version number
  	    numeral.version = VERSION;

  	    // compare numeral object
  	    numeral.isNumeral = function(obj) {
  	        return obj instanceof Numeral;
  	    };

  	    // helper functions
  	    numeral._ = _ = {
  	        // formats numbers separators, decimals places, signs, abbreviations
  	        numberToFormat: function(value, format, roundingFunction) {
  	            var locale = locales[numeral.options.currentLocale],
  	                negP = false,
  	                optDec = false,
  	                leadingCount = 0,
  	                abbr = '',
  	                trillion = 1000000000000,
  	                billion = 1000000000,
  	                million = 1000000,
  	                thousand = 1000,
  	                decimal = '',
  	                neg = false,
  	                abbrForce, // force abbreviation
  	                abs,
  	                int,
  	                precision,
  	                signed,
  	                thousands,
  	                output;

  	            // make sure we never format a null value
  	            value = value || 0;

  	            abs = Math.abs(value);

  	            // see if we should use parentheses for negative number or if we should prefix with a sign
  	            // if both are present we default to parentheses
  	            if (numeral._.includes(format, '(')) {
  	                negP = true;
  	                format = format.replace(/[\(|\)]/g, '');
  	            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
  	                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
  	                format = format.replace(/[\+|\-]/g, '');
  	            }

  	            // see if abbreviation is wanted
  	            if (numeral._.includes(format, 'a')) {
  	                abbrForce = format.match(/a(k|m|b|t)?/);

  	                abbrForce = abbrForce ? abbrForce[1] : false;

  	                // check for space before abbreviation
  	                if (numeral._.includes(format, ' a')) {
  	                    abbr = ' ';
  	                }

  	                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

  	                if (abs >= trillion && !abbrForce || abbrForce === 't') {
  	                    // trillion
  	                    abbr += locale.abbreviations.trillion;
  	                    value = value / trillion;
  	                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
  	                    // billion
  	                    abbr += locale.abbreviations.billion;
  	                    value = value / billion;
  	                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
  	                    // million
  	                    abbr += locale.abbreviations.million;
  	                    value = value / million;
  	                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
  	                    // thousand
  	                    abbr += locale.abbreviations.thousand;
  	                    value = value / thousand;
  	                }
  	            }

  	            // check for optional decimals
  	            if (numeral._.includes(format, '[.]')) {
  	                optDec = true;
  	                format = format.replace('[.]', '.');
  	            }

  	            // break number and format
  	            int = value.toString().split('.')[0];
  	            precision = format.split('.')[1];
  	            thousands = format.indexOf(',');
  	            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

  	            if (precision) {
  	                if (numeral._.includes(precision, '[')) {
  	                    precision = precision.replace(']', '');
  	                    precision = precision.split('[');
  	                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
  	                } else {
  	                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
  	                }

  	                int = decimal.split('.')[0];

  	                if (numeral._.includes(decimal, '.')) {
  	                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
  	                } else {
  	                    decimal = '';
  	                }

  	                if (optDec && Number(decimal.slice(1)) === 0) {
  	                    decimal = '';
  	                }
  	            } else {
  	                int = numeral._.toFixed(value, 0, roundingFunction);
  	            }

  	            // check abbreviation again after rounding
  	            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
  	                int = String(Number(int) / 1000);

  	                switch (abbr) {
  	                    case locale.abbreviations.thousand:
  	                        abbr = locale.abbreviations.million;
  	                        break;
  	                    case locale.abbreviations.million:
  	                        abbr = locale.abbreviations.billion;
  	                        break;
  	                    case locale.abbreviations.billion:
  	                        abbr = locale.abbreviations.trillion;
  	                        break;
  	                }
  	            }


  	            // format number
  	            if (numeral._.includes(int, '-')) {
  	                int = int.slice(1);
  	                neg = true;
  	            }

  	            if (int.length < leadingCount) {
  	                for (var i = leadingCount - int.length; i > 0; i--) {
  	                    int = '0' + int;
  	                }
  	            }

  	            if (thousands > -1) {
  	                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
  	            }

  	            if (format.indexOf('.') === 0) {
  	                int = '';
  	            }

  	            output = int + decimal + (abbr ? abbr : '');

  	            if (negP) {
  	                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
  	            } else {
  	                if (signed >= 0) {
  	                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
  	                } else if (neg) {
  	                    output = '-' + output;
  	                }
  	            }

  	            return output;
  	        },
  	        // unformats numbers separators, decimals places, signs, abbreviations
  	        stringToNumber: function(string) {
  	            var locale = locales[options.currentLocale],
  	                stringOriginal = string,
  	                abbreviations = {
  	                    thousand: 3,
  	                    million: 6,
  	                    billion: 9,
  	                    trillion: 12
  	                },
  	                abbreviation,
  	                value,
  	                regexp;

  	            if (options.zeroFormat && string === options.zeroFormat) {
  	                value = 0;
  	            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
  	                value = null;
  	            } else {
  	                value = 1;

  	                if (locale.delimiters.decimal !== '.') {
  	                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
  	                }

  	                for (abbreviation in abbreviations) {
  	                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

  	                    if (stringOriginal.match(regexp)) {
  	                        value *= Math.pow(10, abbreviations[abbreviation]);
  	                        break;
  	                    }
  	                }

  	                // check for negative number
  	                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

  	                // remove non numbers
  	                string = string.replace(/[^0-9\.]+/g, '');

  	                value *= Number(string);
  	            }

  	            return value;
  	        },
  	        isNaN: function(value) {
  	            return typeof value === 'number' && isNaN(value);
  	        },
  	        includes: function(string, search) {
  	            return string.indexOf(search) !== -1;
  	        },
  	        insert: function(string, subString, start) {
  	            return string.slice(0, start) + subString + string.slice(start);
  	        },
  	        reduce: function(array, callback /*, initialValue*/) {
  	            if (this === null) {
  	                throw new TypeError('Array.prototype.reduce called on null or undefined');
  	            }

  	            if (typeof callback !== 'function') {
  	                throw new TypeError(callback + ' is not a function');
  	            }

  	            var t = Object(array),
  	                len = t.length >>> 0,
  	                k = 0,
  	                value;

  	            if (arguments.length === 3) {
  	                value = arguments[2];
  	            } else {
  	                while (k < len && !(k in t)) {
  	                    k++;
  	                }

  	                if (k >= len) {
  	                    throw new TypeError('Reduce of empty array with no initial value');
  	                }

  	                value = t[k++];
  	            }
  	            for (; k < len; k++) {
  	                if (k in t) {
  	                    value = callback(value, t[k], k, t);
  	                }
  	            }
  	            return value;
  	        },
  	        /**
  	         * Computes the multiplier necessary to make x >= 1,
  	         * effectively eliminating miscalculations caused by
  	         * finite precision.
  	         */
  	        multiplier: function (x) {
  	            var parts = x.toString().split('.');

  	            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
  	        },
  	        /**
  	         * Given a variable number of arguments, returns the maximum
  	         * multiplier that must be used to normalize an operation involving
  	         * all of them.
  	         */
  	        correctionFactor: function () {
  	            var args = Array.prototype.slice.call(arguments);

  	            return args.reduce(function(accum, next) {
  	                var mn = _.multiplier(next);
  	                return accum > mn ? accum : mn;
  	            }, 1);
  	        },
  	        /**
  	         * Implementation of toFixed() that treats floats more like decimals
  	         *
  	         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
  	         * problems for accounting- and finance-related software.
  	         */
  	        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
  	            var splitValue = value.toString().split('.'),
  	                minDecimals = maxDecimals - (optionals || 0),
  	                boundedPrecision,
  	                optionalsRegExp,
  	                power,
  	                output;

  	            // Use the smallest precision value possible to avoid errors from floating point representation
  	            if (splitValue.length === 2) {
  	              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
  	            } else {
  	              boundedPrecision = minDecimals;
  	            }

  	            power = Math.pow(10, boundedPrecision);

  	            // Multiply up by precision, round accurately, then divide and use native toFixed():
  	            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

  	            if (optionals > maxDecimals - boundedPrecision) {
  	                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
  	                output = output.replace(optionalsRegExp, '');
  	            }

  	            return output;
  	        }
  	    };

  	    // avaliable options
  	    numeral.options = options;

  	    // avaliable formats
  	    numeral.formats = formats;

  	    // avaliable formats
  	    numeral.locales = locales;

  	    // This function sets the current locale.  If
  	    // no arguments are passed in, it will simply return the current global
  	    // locale key.
  	    numeral.locale = function(key) {
  	        if (key) {
  	            options.currentLocale = key.toLowerCase();
  	        }

  	        return options.currentLocale;
  	    };

  	    // This function provides access to the loaded locale data.  If
  	    // no arguments are passed in, it will simply return the current
  	    // global locale object.
  	    numeral.localeData = function(key) {
  	        if (!key) {
  	            return locales[options.currentLocale];
  	        }

  	        key = key.toLowerCase();

  	        if (!locales[key]) {
  	            throw new Error('Unknown locale : ' + key);
  	        }

  	        return locales[key];
  	    };

  	    numeral.reset = function() {
  	        for (var property in defaults) {
  	            options[property] = defaults[property];
  	        }
  	    };

  	    numeral.zeroFormat = function(format) {
  	        options.zeroFormat = typeof(format) === 'string' ? format : null;
  	    };

  	    numeral.nullFormat = function (format) {
  	        options.nullFormat = typeof(format) === 'string' ? format : null;
  	    };

  	    numeral.defaultFormat = function(format) {
  	        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
  	    };

  	    numeral.register = function(type, name, format) {
  	        name = name.toLowerCase();

  	        if (this[type + 's'][name]) {
  	            throw new TypeError(name + ' ' + type + ' already registered.');
  	        }

  	        this[type + 's'][name] = format;

  	        return format;
  	    };


  	    numeral.validate = function(val, culture) {
  	        var _decimalSep,
  	            _thousandSep,
  	            _currSymbol,
  	            _valArray,
  	            _abbrObj,
  	            _thousandRegEx,
  	            localeData,
  	            temp;

  	        //coerce val to string
  	        if (typeof val !== 'string') {
  	            val += '';

  	            if (console.warn) {
  	                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
  	            }
  	        }

  	        //trim whitespaces from either sides
  	        val = val.trim();

  	        //if val is just digits return true
  	        if (!!val.match(/^\d+$/)) {
  	            return true;
  	        }

  	        //if val is empty return false
  	        if (val === '') {
  	            return false;
  	        }

  	        //get the decimal and thousands separator from numeral.localeData
  	        try {
  	            //check if the culture is understood by numeral. if not, default it to current locale
  	            localeData = numeral.localeData(culture);
  	        } catch (e) {
  	            localeData = numeral.localeData(numeral.locale());
  	        }

  	        //setup the delimiters and currency symbol based on culture/locale
  	        _currSymbol = localeData.currency.symbol;
  	        _abbrObj = localeData.abbreviations;
  	        _decimalSep = localeData.delimiters.decimal;
  	        if (localeData.delimiters.thousands === '.') {
  	            _thousandSep = '\\.';
  	        } else {
  	            _thousandSep = localeData.delimiters.thousands;
  	        }

  	        // validating currency symbol
  	        temp = val.match(/^[^\d]+/);
  	        if (temp !== null) {
  	            val = val.substr(1);
  	            if (temp[0] !== _currSymbol) {
  	                return false;
  	            }
  	        }

  	        //validating abbreviation symbol
  	        temp = val.match(/[^\d]+$/);
  	        if (temp !== null) {
  	            val = val.slice(0, -1);
  	            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
  	                return false;
  	            }
  	        }

  	        _thousandRegEx = new RegExp(_thousandSep + '{2}');

  	        if (!val.match(/[^\d.,]/g)) {
  	            _valArray = val.split(_decimalSep);
  	            if (_valArray.length > 2) {
  	                return false;
  	            } else {
  	                if (_valArray.length < 2) {
  	                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
  	                } else {
  	                    if (_valArray[0].length === 1) {
  	                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
  	                    } else {
  	                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
  	                    }
  	                }
  	            }
  	        }

  	        return false;
  	    };


  	    /************************************
  	        Numeral Prototype
  	    ************************************/

  	    numeral.fn = Numeral.prototype = {
  	        clone: function() {
  	            return numeral(this);
  	        },
  	        format: function(inputString, roundingFunction) {
  	            var value = this._value,
  	                format = inputString || options.defaultFormat,
  	                kind,
  	                output,
  	                formatFunction;

  	            // make sure we have a roundingFunction
  	            roundingFunction = roundingFunction || Math.round;

  	            // format based on value
  	            if (value === 0 && options.zeroFormat !== null) {
  	                output = options.zeroFormat;
  	            } else if (value === null && options.nullFormat !== null) {
  	                output = options.nullFormat;
  	            } else {
  	                for (kind in formats) {
  	                    if (format.match(formats[kind].regexps.format)) {
  	                        formatFunction = formats[kind].format;

  	                        break;
  	                    }
  	                }

  	                formatFunction = formatFunction || numeral._.numberToFormat;

  	                output = formatFunction(value, format, roundingFunction);
  	            }

  	            return output;
  	        },
  	        value: function() {
  	            return this._value;
  	        },
  	        input: function() {
  	            return this._input;
  	        },
  	        set: function(value) {
  	            this._value = Number(value);

  	            return this;
  	        },
  	        add: function(value) {
  	            var corrFactor = _.correctionFactor.call(null, this._value, value);

  	            function cback(accum, curr, currI, O) {
  	                return accum + Math.round(corrFactor * curr);
  	            }

  	            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

  	            return this;
  	        },
  	        subtract: function(value) {
  	            var corrFactor = _.correctionFactor.call(null, this._value, value);

  	            function cback(accum, curr, currI, O) {
  	                return accum - Math.round(corrFactor * curr);
  	            }

  	            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

  	            return this;
  	        },
  	        multiply: function(value) {
  	            function cback(accum, curr, currI, O) {
  	                var corrFactor = _.correctionFactor(accum, curr);
  	                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
  	            }

  	            this._value = _.reduce([this._value, value], cback, 1);

  	            return this;
  	        },
  	        divide: function(value) {
  	            function cback(accum, curr, currI, O) {
  	                var corrFactor = _.correctionFactor(accum, curr);
  	                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
  	            }

  	            this._value = _.reduce([this._value, value], cback);

  	            return this;
  	        },
  	        difference: function(value) {
  	            return Math.abs(numeral(this._value).subtract(value).value());
  	        }
  	    };

  	    /************************************
  	        Default Locale && Format
  	    ************************************/

  	    numeral.register('locale', 'en', {
  	        delimiters: {
  	            thousands: ',',
  	            decimal: '.'
  	        },
  	        abbreviations: {
  	            thousand: 'k',
  	            million: 'm',
  	            billion: 'b',
  	            trillion: 't'
  	        },
  	        ordinal: function(number) {
  	            var b = number % 10;
  	            return (~~(number % 100 / 10) === 1) ? 'th' :
  	                (b === 1) ? 'st' :
  	                (b === 2) ? 'nd' :
  	                (b === 3) ? 'rd' : 'th';
  	        },
  	        currency: {
  	            symbol: '$'
  	        }
  	    });

  	    

  	(function() {
  	        numeral.register('format', 'bps', {
  	            regexps: {
  	                format: /(BPS)/,
  	                unformat: /(BPS)/
  	            },
  	            format: function(value, format, roundingFunction) {
  	                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
  	                    output;

  	                value = value * 10000;

  	                // check for space before BPS
  	                format = format.replace(/\s?BPS/, '');

  	                output = numeral._.numberToFormat(value, format, roundingFunction);

  	                if (numeral._.includes(output, ')')) {
  	                    output = output.split('');

  	                    output.splice(-1, 0, space + 'BPS');

  	                    output = output.join('');
  	                } else {
  	                    output = output + space + 'BPS';
  	                }

  	                return output;
  	            },
  	            unformat: function(string) {
  	                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
  	            }
  	        });
  	})();


  	(function() {
  	        var decimal = {
  	            base: 1000,
  	            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
  	        },
  	        binary = {
  	            base: 1024,
  	            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
  	        };

  	    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
  	            return decimal.suffixes.indexOf(item) < 0;
  	        }));
  	        var unformatRegex = allSuffixes.join('|');
  	        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
  	        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

  	    numeral.register('format', 'bytes', {
  	        regexps: {
  	            format: /([0\s]i?b)/,
  	            unformat: new RegExp(unformatRegex)
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var output,
  	                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
  	                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
  	                power,
  	                min,
  	                max;

  	            // check for space before
  	            format = format.replace(/\s?i?b/, '');

  	            for (power = 0; power <= bytes.suffixes.length; power++) {
  	                min = Math.pow(bytes.base, power);
  	                max = Math.pow(bytes.base, power + 1);

  	                if (value === null || value === 0 || value >= min && value < max) {
  	                    suffix += bytes.suffixes[power];

  	                    if (min > 0) {
  	                        value = value / min;
  	                    }

  	                    break;
  	                }
  	            }

  	            output = numeral._.numberToFormat(value, format, roundingFunction);

  	            return output + suffix;
  	        },
  	        unformat: function(string) {
  	            var value = numeral._.stringToNumber(string),
  	                power,
  	                bytesMultiplier;

  	            if (value) {
  	                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
  	                    if (numeral._.includes(string, decimal.suffixes[power])) {
  	                        bytesMultiplier = Math.pow(decimal.base, power);

  	                        break;
  	                    }

  	                    if (numeral._.includes(string, binary.suffixes[power])) {
  	                        bytesMultiplier = Math.pow(binary.base, power);

  	                        break;
  	                    }
  	                }

  	                value *= (bytesMultiplier || 1);
  	            }

  	            return value;
  	        }
  	    });
  	})();


  	(function() {
  	        numeral.register('format', 'currency', {
  	        regexps: {
  	            format: /(\$)/
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var locale = numeral.locales[numeral.options.currentLocale],
  	                symbols = {
  	                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
  	                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
  	                },
  	                output,
  	                symbol,
  	                i;

  	            // strip format of spaces and $
  	            format = format.replace(/\s?\$\s?/, '');

  	            // format the number
  	            output = numeral._.numberToFormat(value, format, roundingFunction);

  	            // update the before and after based on value
  	            if (value >= 0) {
  	                symbols.before = symbols.before.replace(/[\-\(]/, '');
  	                symbols.after = symbols.after.replace(/[\-\)]/, '');
  	            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
  	                symbols.before = '-' + symbols.before;
  	            }

  	            // loop through each before symbol
  	            for (i = 0; i < symbols.before.length; i++) {
  	                symbol = symbols.before[i];

  	                switch (symbol) {
  	                    case '$':
  	                        output = numeral._.insert(output, locale.currency.symbol, i);
  	                        break;
  	                    case ' ':
  	                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
  	                        break;
  	                }
  	            }

  	            // loop through each after symbol
  	            for (i = symbols.after.length - 1; i >= 0; i--) {
  	                symbol = symbols.after[i];

  	                switch (symbol) {
  	                    case '$':
  	                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
  	                        break;
  	                    case ' ':
  	                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
  	                        break;
  	                }
  	            }


  	            return output;
  	        }
  	    });
  	})();


  	(function() {
  	        numeral.register('format', 'exponential', {
  	        regexps: {
  	            format: /(e\+|e-)/,
  	            unformat: /(e\+|e-)/
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var output,
  	                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
  	                parts = exponential.split('e');

  	            format = format.replace(/e[\+|\-]{1}0/, '');

  	            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

  	            return output + 'e' + parts[1];
  	        },
  	        unformat: function(string) {
  	            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
  	                value = Number(parts[0]),
  	                power = Number(parts[1]);

  	            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

  	            function cback(accum, curr, currI, O) {
  	                var corrFactor = numeral._.correctionFactor(accum, curr),
  	                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
  	                return num;
  	            }

  	            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
  	        }
  	    });
  	})();


  	(function() {
  	        numeral.register('format', 'ordinal', {
  	        regexps: {
  	            format: /(o)/
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var locale = numeral.locales[numeral.options.currentLocale],
  	                output,
  	                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

  	            // check for space before
  	            format = format.replace(/\s?o/, '');

  	            ordinal += locale.ordinal(value);

  	            output = numeral._.numberToFormat(value, format, roundingFunction);

  	            return output + ordinal;
  	        }
  	    });
  	})();


  	(function() {
  	        numeral.register('format', 'percentage', {
  	        regexps: {
  	            format: /(%)/,
  	            unformat: /(%)/
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var space = numeral._.includes(format, ' %') ? ' ' : '',
  	                output;

  	            if (numeral.options.scalePercentBy100) {
  	                value = value * 100;
  	            }

  	            // check for space before %
  	            format = format.replace(/\s?\%/, '');

  	            output = numeral._.numberToFormat(value, format, roundingFunction);

  	            if (numeral._.includes(output, ')')) {
  	                output = output.split('');

  	                output.splice(-1, 0, space + '%');

  	                output = output.join('');
  	            } else {
  	                output = output + space + '%';
  	            }

  	            return output;
  	        },
  	        unformat: function(string) {
  	            var number = numeral._.stringToNumber(string);
  	            if (numeral.options.scalePercentBy100) {
  	                return number * 0.01;
  	            }
  	            return number;
  	        }
  	    });
  	})();


  	(function() {
  	        numeral.register('format', 'time', {
  	        regexps: {
  	            format: /(:)/,
  	            unformat: /(:)/
  	        },
  	        format: function(value, format, roundingFunction) {
  	            var hours = Math.floor(value / 60 / 60),
  	                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
  	                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

  	            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
  	        },
  	        unformat: function(string) {
  	            var timeArray = string.split(':'),
  	                seconds = 0;

  	            // turn hours and minutes into seconds and add them all up
  	            if (timeArray.length === 3) {
  	                // hours
  	                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
  	                // minutes
  	                seconds = seconds + (Number(timeArray[1]) * 60);
  	                // seconds
  	                seconds = seconds + Number(timeArray[2]);
  	            } else if (timeArray.length === 2) {
  	                // minutes
  	                seconds = seconds + (Number(timeArray[0]) * 60);
  	                // seconds
  	                seconds = seconds + Number(timeArray[1]);
  	            }
  	            return Number(seconds);
  	        }
  	    });
  	})();

  	return numeral;
  	})); 
  } (numeral$1));

  var numeralExports = numeral$1.exports;
  var numeral = /*@__PURE__*/getDefaultExportFromCjs(numeralExports);

  /**
   * A function that always returns `false`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.T
   * @example
   *
   *      R.F(); //=> false
   */
  var F$1 = function () {
    return false;
  };

  /**
   * A function that always returns `true`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.F
   * @example
   *
   *      R.T(); //=> true
   */
  var T = function () {
    return true;
  };

  /**
   * A special placeholder value used to specify "gaps" within curried functions,
   * allowing partial application of any combination of arguments, regardless of
   * their positions.
   *
   * If `g` is a curried ternary function and `_` is `R.__`, the following are
   * equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2, _)(1, 3)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @name __
   * @constant
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @example
   *
   *      const greet = R.replace('{name}', R.__, 'Hello, {name}!');
   *      greet('Alice'); //=> 'Hello, Alice!'
   */
  var __ = {
    '@@functional/placeholder': true
  };

  function _isPlaceholder(a) {
    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;

        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  /**
   * Adds two values.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a
   * @param {Number} b
   * @return {Number}
   * @see R.subtract
   * @example
   *
   *      R.add(2, 3);       //=>  5
   *      R.add(7)(10);      //=> 17
   */

  var add =
  /*#__PURE__*/
  _curry2(function add(a, b) {
    return Number(a) + Number(b);
  });

  /**
   * Private `concat` function to merge two array-like objects.
   *
   * @private
   * @param {Array|Arguments} [set1=[]] An array-like object.
   * @param {Array|Arguments} [set2=[]] An array-like object.
   * @return {Array} A new, merged array.
   * @example
   *
   *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   */
  function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];
    idx = 0;

    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }

    idx = 0;

    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }

    return result;
  }

  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };

      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };

      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };

      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };

      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };

      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };

      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };

      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };

      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };

      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };

      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };

      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;
      var hasPlaceholder = false;

      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;

        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }

        combined[combinedIdx] = result;

        if (!_isPlaceholder(result)) {
          left -= 1;
        } else {
          hasPlaceholder = true;
        }

        combinedIdx += 1;
      }

      return !hasPlaceholder && left <= 0 ? fn.apply(this, combined) : _arity(Math.max(0, left), _curryN(length, combined, fn));
    };
  }

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      const sumArgs = (...args) => R.sum(args);
   *
   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */

  var curryN =
  /*#__PURE__*/
  _curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }

    return _arity(length, _curryN(length, [], fn));
  });

  /**
   * Creates a new list iteration function from an existing one by adding two new
   * parameters to its callback function: the current index, and the entire list.
   *
   * This would turn, for instance, [`R.map`](#map) function into one that
   * more closely resembles `Array.prototype.map`. Note that this will only work
   * for functions in which the iteration callback function is the first
   * parameter, and where the list is the last parameter. (This latter might be
   * unimportant if the list parameter is not used.)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Function
   * @category List
   * @sig (((a ...) -> b) ... -> [a] -> *) -> (((a ..., Int, [a]) -> b) ... -> [a] -> *)
   * @param {Function} fn A list iteration function that does not pass index or list to its callback
   * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
   * @example
   *
   *      const mapIndexed = R.addIndex(R.map);
   *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
   *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
   */

  var addIndex =
  /*#__PURE__*/
  _curry1(function addIndex(fn) {
    return curryN(fn.length, function () {
      var idx = 0;
      var origFn = arguments[0];
      var list = arguments[arguments.length - 1];
      var args = Array.prototype.slice.call(arguments, 0);

      args[0] = function () {
        var result = origFn.apply(this, _concat(arguments, [idx, list]));
        idx += 1;
        return result;
      };

      return fn.apply(this, args);
    });
  });

  /**
   * As with `addIndex`, `addIndexRight` creates a new list iteration function
   * from an existing one by adding two new parameters to its callback function:
   * the current index, and the entire list.
   *
   * Unlike `addIndex`, `addIndexRight` iterates from the right to the left.
   *
   * @func
   * @memberOf R
   * @since v0.29.0
   * @category Function
   * @category List
   * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
   * @param {Function} fn A list iteration function that does not pass index or list to its callback
   * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
   * @example
   *
   *      const revmap = (fn, ary) => R.map(fn, R.reverse(ary));
   *      const revmapIndexed = R.addIndexRight(revmap);
   *      revmapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
   *      //=> [ '5-r', '4-a', '3-b', '2-o', '1-o', '0-f' ]
   */

  var addIndexRight =
  /*#__PURE__*/
  _curry1(function addIndex(fn) {
    return curryN(fn.length, function () {
      var origFn = arguments[0];
      var list = arguments[arguments.length - 1];
      var idx = list.length - 1;
      var args = Array.prototype.slice.call(arguments, 0);

      args[0] = function () {
        var result = origFn.apply(this, _concat(arguments, [idx, list]));
        idx -= 1;
        return result;
      };

      return fn.apply(this, args);
    });
  });

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;

        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });

        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  /**
   * Applies a function to the value at the given index of an array, returning a
   * new copy of the array with the element at the given index replaced with the
   * result of the function application.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> (a -> a) -> [a] -> [a]
   * @param {Number} idx The index.
   * @param {Function} fn The function to apply.
   * @param {Array|Arguments} list An array-like object whose value
   *        at the supplied index will be replaced.
   * @return {Array} A copy of the supplied array-like object with
   *         the element at index `idx` replaced with the value
   *         returned by applying `fn` to the existing element.
   * @see R.update
   * @example
   *
   *      R.adjust(1, R.toUpper, ['a', 'b', 'c', 'd']);      //=> ['a', 'B', 'c', 'd']
   *      R.adjust(-1, R.toUpper, ['a', 'b', 'c', 'd']);     //=> ['a', 'b', 'c', 'D']
   * @symb R.adjust(-1, f, [a, b]) = [a, f(b)]
   * @symb R.adjust(0, f, [a, b]) = [f(a), b]
   */

  var adjust =
  /*#__PURE__*/
  _curry3(function adjust(idx, fn, list) {
    var len = list.length;

    if (idx >= len || idx < -len) {
      return list;
    }

    var _idx = (len + idx) % len;

    var _list = _concat(list);

    _list[_idx] = fn(list[_idx]);
    return _list;
  });

  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  var _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };

  function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
  }

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer created by [transducerCreator] to return a new transformer
   * (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} transducerCreator transducer factory if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */

  function _dispatchable(methodNames, transducerCreator, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }

      var obj = arguments[arguments.length - 1];

      if (!_isArray(obj)) {
        var idx = 0;

        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }

          idx += 1;
        }

        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }

      return fn.apply(this, arguments);
    };
  }

  function _reduced(x) {
    return x && x['@@transducer/reduced'] ? x : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }

  var _xfBase = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };

  var XAll =
  /*#__PURE__*/
  function () {
    function XAll(f, xf) {
      this.xf = xf;
      this.f = f;
      this.all = true;
    }

    XAll.prototype['@@transducer/init'] = _xfBase.init;

    XAll.prototype['@@transducer/result'] = function (result) {
      if (this.all) {
        result = this.xf['@@transducer/step'](result, true);
      }

      return this.xf['@@transducer/result'](result);
    };

    XAll.prototype['@@transducer/step'] = function (result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf['@@transducer/step'](result, false));
      }

      return result;
    };

    return XAll;
  }();

  function _xall(f) {
    return function (xf) {
      return new XAll(f, xf);
    };
  }

  /**
   * Returns `true` if all elements of the list match the predicate, `false` if
   * there are any that don't.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
   *         otherwise.
   * @see R.any, R.none, R.transduce
   * @example
   *
   *      const equals3 = R.equals(3);
   *      R.all(equals3)([3, 3, 3, 3]); //=> true
   *      R.all(equals3)([3, 3, 1, 3]); //=> false
   */

  var all =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['all'], _xall, function all(fn, list) {
    var idx = 0;

    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }

      idx += 1;
    }

    return true;
  }));

  function _arrayFromIterator(iter) {
    var list = [];
    var next;

    while (!(next = iter.next()).done) {
      list.push(next.value);
    }

    return list;
  }

  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }

      idx += 1;
    }

    return false;
  }

  function _functionName(f) {
    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var match = String(f).match(/^function (\w*)/);
    return match == null ? '' : match[1];
  }

  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  function _objectIs(a, b) {
    // SameValue algorithm
    if (a === b) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return a !== 0 || 1 / a === 1 / b;
    } else {
      // Step 6.a: NaN == NaN
      return a !== a && b !== b;
    }
  }

  var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

  var toString$1 = Object.prototype.toString;

  var _isArguments =
  /*#__PURE__*/
  function () {
    return toString$1.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString$1.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();

  var hasEnumBug = !
  /*#__PURE__*/
  {
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

  var hasArgsEnumBug =
  /*#__PURE__*/
  function () {

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;

    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }

      idx += 1;
    }

    return false;
  };
  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values, R.toPairs
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */


  var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
  /*#__PURE__*/
  _curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) :
  /*#__PURE__*/
  _curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }

    var prop, nIdx;
    var ks = [];

    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }

    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;

      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];

        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }

        nIdx -= 1;
      }
    }

    return ks;
  });

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig * -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   *      R.type(() => {}); //=> "Function"
   *      R.type(async () => {}); //=> "AsyncFunction"
   *      R.type(undefined); //=> "Undefined"
   */

  var type =
  /*#__PURE__*/
  _curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });

  /**
   * private _uniqContentEquals function.
   * That function is checking equality of 2 iterator contents with 2 assumptions
   * - iterators lengths are the same
   * - iterators values are unique
   *
   * false-positive result will be returned for comparison of, e.g.
   * - [1,2,3] and [1,2,3,4]
   * - [1,1,1] and [1,2,3]
   * */

  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);

    var b = _arrayFromIterator(bIterator);

    function eq(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    } // if *a* array contains any element that is not included in *b*


    return !_includesWith(function (b, aItem) {
      return !_includesWith(eq, aItem, b);
    }, b, a);
  }

  function _equals(a, b, stackA, stackB) {
    if (_objectIs$1(a, b)) {
      return true;
    }

    var typeA = type(a);

    if (typeA !== type(b)) {
      return false;
    }

    if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
      return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
    }

    if (typeof a.equals === 'function' || typeof b.equals === 'function') {
      return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
    }

    switch (typeA) {
      case 'Arguments':
      case 'Array':
      case 'Object':
        if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
          return a === b;
        }

        break;

      case 'Boolean':
      case 'Number':
      case 'String':
        if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
          return false;
        }

        break;

      case 'Date':
        if (!_objectIs$1(a.valueOf(), b.valueOf())) {
          return false;
        }

        break;

      case 'Error':
        return a.name === b.name && a.message === b.message;

      case 'RegExp':
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }

        break;
    }

    var idx = stackA.length - 1;

    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }

      idx -= 1;
    }

    switch (typeA) {
      case 'Map':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

      case 'Set':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

      case 'Arguments':
      case 'Array':
      case 'Object':
      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Date':
      case 'Error':
      case 'RegExp':
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'ArrayBuffer':
        break;

      default:
        // Values of other types are only equal if identical.
        return false;
    }

    var keysA = keys(a);

    if (keysA.length !== keys(b).length) {
      return false;
    }

    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;

    while (idx >= 0) {
      var key = keysA[idx];

      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }

      idx -= 1;
    }

    return true;
  }

  /**
   * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
   * cyclical data structures.
   *
   * Dispatches symmetrically to the `equals` methods of both arguments, if
   * present.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> b -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      R.equals(1, 1); //=> true
   *      R.equals(1, '1'); //=> false
   *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
   *
   *      const a = {}; a.v = a;
   *      const b = {}; b.v = b;
   *      R.equals(a, b); //=> true
   */

  var equals =
  /*#__PURE__*/
  _curry2(function equals(a, b) {
    return _equals(a, b, [], []);
  });

  function _indexOf(list, a, idx) {
    var inf, item; // Array.prototype.indexOf doesn't exist below IE9

    if (typeof list.indexOf === 'function') {
      switch (typeof a) {
        case 'number':
          if (a === 0) {
            // manually crawl the list to distinguish between +0 and -0
            inf = 1 / a;

            while (idx < list.length) {
              item = list[idx];

              if (item === 0 && 1 / item === inf) {
                return idx;
              }

              idx += 1;
            }

            return -1;
          } else if (a !== a) {
            // NaN
            while (idx < list.length) {
              item = list[idx];

              if (typeof item === 'number' && item !== item) {
                return idx;
              }

              idx += 1;
            }

            return -1;
          } // non-zero numbers can utilise Set


          return list.indexOf(a, idx);
        // all these types can utilise Set

        case 'string':
        case 'boolean':
        case 'function':
        case 'undefined':
          return list.indexOf(a, idx);

        case 'object':
          if (a === null) {
            // null can utilise Set
            return list.indexOf(a, idx);
          }

      }
    } // anything else not covered above, defer to R.equals


    while (idx < list.length) {
      if (equals(list[idx], a)) {
        return idx;
      }

      idx += 1;
    }

    return -1;
  }

  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);

    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }

    return result;
  }

  function _quote(s) {
    var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
    return '"' + escaped.replace(/"/g, '\\"') + '"';
  }

  /**
   * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
   */
  var pad = function pad(n) {
    return (n < 10 ? '0' : '') + n;
  };

  var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
    return d.toISOString();
  } : function _toISOString(d) {
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
  };

  function _complement(f) {
    return function () {
      return !f.apply(this, arguments);
    };
  }

  function _arrayReduce(reducer, acc, list) {
    var index = 0;
    var length = list.length;

    while (index < length) {
      acc = reducer(acc, list[index]);
      index += 1;
    }

    return acc;
  }

  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];

    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }

      idx += 1;
    }

    return result;
  }

  function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  }

  var XFilter =
  /*#__PURE__*/
  function () {
    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;

    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XFilter;
  }();

  function _xfilter(f) {
    return function (xf) {
      return new XFilter(f, xf);
    };
  }

  /**
   * Takes a predicate and a `Filterable`, and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @category Object
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array} Filterable
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */

  var filter =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/filter', 'filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _arrayReduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }

      return acc;
    }, {}, keys(filterable)) : // else
    _filter(pred, filterable);
  }));

  /**
   * The complement of [`filter`](#filter).
   *
   * Acts as a transducer if a transformer is given in list position. Filterable
   * objects include plain objects or any object that has a filter method such
   * as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.filter, R.transduce, R.addIndex
   * @example
   *
   *      const isOdd = (n) => n % 2 !== 0;
   *
   *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */

  var reject =
  /*#__PURE__*/
  _curry2(function reject(pred, filterable) {
    return filter(_complement(pred), filterable);
  });

  function _toString(x, seen) {
    var recur = function recur(y) {
      var xs = seen.concat([x]);
      return _includes(y, xs) ? '<Circular>' : _toString(y, xs);
    }; //  mapPairs :: (Object, [String]) -> [String]


    var mapPairs = function (obj, keys) {
      return _map(function (k) {
        return _quote(k) + ': ' + recur(obj[k]);
      }, keys.slice().sort());
    };

    switch (Object.prototype.toString.call(x)) {
      case '[object Arguments]':
        return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';

      case '[object Array]':
        return '[' + _map(recur, x).concat(mapPairs(x, reject(function (k) {
          return /^\d+$/.test(k);
        }, keys(x)))).join(', ') + ']';

      case '[object Boolean]':
        return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();

      case '[object Date]':
        return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';

      case '[object Map]':
        return 'new Map(' + recur(Array.from(x)) + ')';

      case '[object Null]':
        return 'null';

      case '[object Number]':
        return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);

      case '[object Set]':
        return 'new Set(' + recur(Array.from(x).sort()) + ')';

      case '[object String]':
        return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);

      case '[object Undefined]':
        return 'undefined';

      default:
        if (typeof x.toString === 'function') {
          var repr = x.toString();

          if (repr !== '[object Object]') {
            return repr;
          }
        }

        return '{' + mapPairs(x, keys(x)).join(', ') + '}';
    }
  }

  /**
   * Returns the string representation of the given value. `eval`'ing the output
   * should result in a value equivalent to the input value. Many of the built-in
   * `toString` methods do not satisfy this requirement.
   *
   * If the given value is an `[object Object]` with a `toString` method other
   * than `Object.prototype.toString`, this method is invoked with no arguments
   * to produce the return value. This means user-defined constructor functions
   * can provide a suitable `toString` method. For example:
   *
   *     function Point(x, y) {
   *       this.x = x;
   *       this.y = y;
   *     }
   *
   *     Point.prototype.toString = function() {
   *       return 'new Point(' + this.x + ', ' + this.y + ')';
   *     };
   *
   *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category String
   * @sig * -> String
   * @param {*} val
   * @return {String}
   * @example
   *
   *      R.toString(42); //=> '42'
   *      R.toString('abc'); //=> '"abc"'
   *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
   *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
   *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
   */

  var toString =
  /*#__PURE__*/
  _curry1(function toString(val) {
    return _toString(val, []);
  });

  /**
   * Returns the larger of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.maxBy, R.min
   * @example
   *
   *      R.max(789, 123); //=> 789
   *      R.max('a', 'b'); //=> 'b'
   */

  var max =
  /*#__PURE__*/
  _curry2(function max(a, b) {
    if (a === b) {
      return b;
    }

    function safeMax(x, y) {
      if (x > y !== y > x) {
        return y > x ? y : x;
      }

      return undefined;
    }

    var maxByValue = safeMax(a, b);

    if (maxByValue !== undefined) {
      return maxByValue;
    }

    var maxByType = safeMax(typeof a, typeof b);

    if (maxByType !== undefined) {
      return maxByType === typeof a ? a : b;
    }

    var stringA = toString(a);
    var maxByStringValue = safeMax(stringA, toString(b));

    if (maxByStringValue !== undefined) {
      return maxByStringValue === stringA ? a : b;
    }

    return b;
  });

  var XMap =
  /*#__PURE__*/
  function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;

    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return XMap;
  }();

  var _xmap = function _xmap(f) {
    return function (xf) {
      return new XMap(f, xf);
    };
  };

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex, R.pluck, R.project
   * @example
   *
   *      const double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */

  var map =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });

      case '[object Object]':
        return _arrayReduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));

      default:
        return _map(fn, functor);
    }
  }));

  /**
   * Determine if the passed argument is an integer.
   *
   * @private
   * @param {*} n
   * @category Type
   * @return {Boolean}
   */
  var _isInteger = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }

  /**
   * Returns the nth element of the given list or string. If n is negative the
   * element at index length + n is returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> a | Undefined
   * @sig Number -> String -> String
   * @param {Number} offset
   * @param {*} list
   * @return {*}
   * @example
   *
   *      const list = ['foo', 'bar', 'baz', 'quux'];
   *      R.nth(1, list); //=> 'bar'
   *      R.nth(-1, list); //=> 'quux'
   *      R.nth(-99, list); //=> undefined
   *
   *      R.nth(2, 'abc'); //=> 'c'
   *      R.nth(3, 'abc'); //=> ''
   * @symb R.nth(-1, [a, b, c]) = c
   * @symb R.nth(0, [a, b, c]) = a
   * @symb R.nth(1, [a, b, c]) = b
   */

  var nth =
  /*#__PURE__*/
  _curry2(function nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  });

  /**
   * Returns a function that when supplied an object returns the indicated
   * property of that object, if it exists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx -> {s: a} -> a | Undefined
   * @param {String|Number} p The property name or array index
   * @param {Object} obj The object to query
   * @return {*} The value at `obj.p`.
   * @see R.path, R.props, R.pluck, R.project, R.nth
   * @example
   *
   *      R.prop('x', {x: 100}); //=> 100
   *      R.prop('x', {}); //=> undefined
   *      R.prop(0, [100]); //=> 100
   *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
   */

  var prop =
  /*#__PURE__*/
  _curry2(function prop(p, obj) {
    if (obj == null) {
      return;
    }

    return _isInteger(p) ? nth(p, obj) : obj[p];
  });

  /**
   * Returns a new list by plucking the same named property off all objects in
   * the list supplied.
   *
   * `pluck` will work on
   * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
   * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => k -> f {k: v} -> f v
   * @param {Number|String} key The key name to pluck off of each object.
   * @param {Array} f The array or functor to consider.
   * @return {Array} The list of values for the given key.
   * @see R.project, R.prop, R.props
   * @example
   *
   *      var getAges = R.pluck('age');
   *      getAges([{name: 'fred', age: 29}, {name: 'wilma', age: 27}]); //=> [29, 27]
   *
   *      R.pluck(0, [[1, 2], [3, 4]]);               //=> [1, 3]
   *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
   * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
   * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
   */

  var pluck =
  /*#__PURE__*/
  _curry2(function pluck(p, list) {
    return map(prop(p), list);
  });

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   *      _isArrayLike({nodeType: 1, length: 1}) // => false
   */

  var _isArrayLike =
  /*#__PURE__*/
  _curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }

    if (!x) {
      return false;
    }

    if (typeof x !== 'object') {
      return false;
    }

    if (_isString(x)) {
      return false;
    }

    if (x.length === 0) {
      return true;
    }

    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }

    return false;
  });

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  function _createReduce(arrayReduce, methodReduce, iterableReduce) {
    return function _reduce(xf, acc, list) {
      if (_isArrayLike(list)) {
        return arrayReduce(xf, acc, list);
      }

      if (list == null) {
        return acc;
      }

      if (typeof list['fantasy-land/reduce'] === 'function') {
        return methodReduce(xf, acc, list, 'fantasy-land/reduce');
      }

      if (list[symIterator] != null) {
        return iterableReduce(xf, acc, list[symIterator]());
      }

      if (typeof list.next === 'function') {
        return iterableReduce(xf, acc, list);
      }

      if (typeof list.reduce === 'function') {
        return methodReduce(xf, acc, list, 'reduce');
      }

      throw new TypeError('reduce: list must be array or iterable');
    };
  }

  function _xArrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx += 1;
    }

    return xf['@@transducer/result'](acc);
  }

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      const log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */

  var bind =
  /*#__PURE__*/
  _curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });

  function _xIterableReduce(xf, acc, iter) {
    var step = iter.next();

    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      step = iter.next();
    }

    return xf['@@transducer/result'](acc);
  }

  function _xMethodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var _xReduce =
  /*#__PURE__*/
  _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);

  var XWrap =
  /*#__PURE__*/
  function () {
    function XWrap(fn) {
      this.f = fn;
    }

    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };

    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };

    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return XWrap;
  }();

  function _xwrap(fn) {
    return new XWrap(fn);
  }

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Be cautious of mutating and returning the accumulator. If you reuse it across
   * invocations, it will continue to accumulate onto the same value. The general
   * recommendation is to always return a new value. If you can't do so for
   * performance reasons, then be sure to reinitialize the accumulator on each
   * invocation.
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */

  var reduce =
  /*#__PURE__*/
  _curry3(function (xf, acc, list) {
    return _xReduce(typeof xf === 'function' ? _xwrap(xf) : xf, acc, list);
  });

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if every one of the provided predicates is satisfied
   * by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.anyPass, R.both
   * @example
   *
   *      const isQueen = R.propEq('Q', 'rank');
   *      const isSpade = R.propEq('', 'suit');
   *      const isQueenOfSpades = R.allPass([isQueen, isSpade]);
   *
   *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
   *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
   */

  var allPass =
  /*#__PURE__*/
  _curry1(function allPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;

      while (idx < len) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }

        idx += 1;
      }

      return true;
    });
  });

  /**
   * Returns a function that always returns the given value. Note that for
   * non-primitives the value returned is a reference to the original value.
   *
   * This function is known as `const`, `constant`, or `K` (for K combinator) in
   * other languages and libraries.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> (* -> a)
   * @param {*} val The value to wrap in a function
   * @return {Function} A Function :: * -> val.
   * @example
   *
   *      const t = R.always('Tee');
   *      t(); //=> 'Tee'
   */

  var always =
  /*#__PURE__*/
  _curry1(function always(val) {
    return function () {
      return val;
    };
  });

  /**
   * Returns the first argument if it is falsy, otherwise the second argument.
   * Acts as the boolean `and` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.both, R.or
   * @example
   *
   *      R.and(true, true); //=> true
   *      R.and(true, false); //=> false
   *      R.and(false, true); //=> false
   *      R.and(false, false); //=> false
   */

  var and =
  /*#__PURE__*/
  _curry2(function and(a, b) {
    return a && b;
  });

  var XAny =
  /*#__PURE__*/
  function () {
    function XAny(f, xf) {
      this.xf = xf;
      this.f = f;
      this.any = false;
    }

    XAny.prototype['@@transducer/init'] = _xfBase.init;

    XAny.prototype['@@transducer/result'] = function (result) {
      if (!this.any) {
        result = this.xf['@@transducer/step'](result, false);
      }

      return this.xf['@@transducer/result'](result);
    };

    XAny.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.any = true;
        result = _reduced(this.xf['@@transducer/step'](result, true));
      }

      return result;
    };

    return XAny;
  }();

  function _xany(f) {
    return function (xf) {
      return new XAny(f, xf);
    };
  }

  /**
   * Returns `true` if at least one of the elements of the list match the predicate,
   * `false` otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
   *         otherwise.
   * @see R.all, R.none, R.transduce
   * @example
   *
   *      const lessThan0 = R.flip(R.lt)(0);
   *      const lessThan2 = R.flip(R.lt)(2);
   *      R.any(lessThan0)([1, 2]); //=> false
   *      R.any(lessThan2)([1, 2]); //=> true
   */

  var any =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['any'], _xany, function any(fn, list) {
    var idx = 0;

    while (idx < list.length) {
      if (fn(list[idx])) {
        return true;
      }

      idx += 1;
    }

    return false;
  }));

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if at least one of the provided predicates is
   * satisfied by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.allPass, R.either
   * @example
   *
   *      const isClub = R.propEq('', 'suit');
   *      const isSpade = R.propEq('', 'suit');
   *      const isBlackCard = R.anyPass([isClub, isSpade]);
   *
   *      isBlackCard({rank: '10', suit: ''}); //=> true
   *      isBlackCard({rank: 'Q', suit: ''}); //=> true
   *      isBlackCard({rank: 'Q', suit: ''}); //=> false
   */

  var anyPass =
  /*#__PURE__*/
  _curry1(function anyPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;

      while (idx < len) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }

        idx += 1;
      }

      return false;
    });
  });

  function _iterableReduce(reducer, acc, iter) {
    var step = iter.next();

    while (!step.done) {
      acc = reducer(acc, step.value);
      step = iter.next();
    }

    return acc;
  }

  function _methodReduce(reducer, acc, obj, methodName) {
    return obj[methodName](reducer, acc);
  }

  var _reduce =
  /*#__PURE__*/
  _createReduce(_arrayReduce, _methodReduce, _iterableReduce);

  /**
   * ap applies a list of functions to a list of values.
   *
   * Dispatches to the `ap` method of the first argument, if present. Also
   * treats curried functions as applicatives.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig [a -> b] -> [a] -> [b]
   * @sig Apply f => f (a -> b) -> f a -> f b
   * @sig (r -> a -> b) -> (r -> a) -> (r -> b)
   * @param {*} applyF
   * @param {*} applyX
   * @return {*}
   * @example
   *
   *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
   *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
   *
   *      // R.ap can also be used as S combinator
   *      // when only two functions are passed
   *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
   * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
   */

  var ap =
  /*#__PURE__*/
  _curry2(function ap(applyF, applyX) {
    return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
      return applyF(x)(applyX(x));
    } : _reduce(function (acc, f) {
      return _concat(acc, map(f, applyX));
    }, [], applyF);
  });

  function _aperture(n, list) {
    var idx = 0;
    var limit = list.length - (n - 1);
    var acc = new Array(limit >= 0 ? limit : 0);

    while (idx < limit) {
      acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
      idx += 1;
    }

    return acc;
  }

  var XAperture =
  /*#__PURE__*/
  function () {
    function XAperture(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }

    XAperture.prototype['@@transducer/init'] = _xfBase.init;

    XAperture.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };

    XAperture.prototype['@@transducer/step'] = function (result, input) {
      this.store(input);
      return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
    };

    XAperture.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;

      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    XAperture.prototype.getCopy = function () {
      return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
    };

    return XAperture;
  }();

  function _xaperture(n) {
    return function (xf) {
      return new XAperture(n, xf);
    };
  }

  /**
   * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
   * greater than the length of the list, an empty list is returned.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @param {Number} n The size of the tuples to create
   * @param {Array} list The list to split into `n`-length tuples
   * @return {Array} The resulting list of `n`-length tuples
   * @see R.transduce
   * @example
   *
   *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
   *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
   *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
   */

  var aperture =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xaperture, _aperture));

  /**
   * Returns a new list containing the contents of the given list, followed by
   * the given element.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The element to add to the end of the new list.
   * @param {Array} list The list of elements to add a new item to.
   *        list.
   * @return {Array} A new list containing the elements of the old list followed by `el`.
   * @see R.prepend
   * @example
   *
   *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
   *      R.append('tests', []); //=> ['tests']
   *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
   */

  var append =
  /*#__PURE__*/
  _curry2(function append(el, list) {
    return _concat(list, [el]);
  });

  /**
   * Applies function `fn` to the argument list `args`. This is useful for
   * creating a fixed-arity function from a variadic function. `fn` should be a
   * bound function if context is significant.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> a) -> [*] -> a
   * @param {Function} fn The function which will be called with `args`
   * @param {Array} args The arguments to call `fn` with
   * @return {*} result The result, equivalent to `fn(...args)`
   * @see R.call, R.unapply
   * @example
   *
   *      const nums = [1, 2, 3, -99, 42, 6, 7];
   *      R.apply(Math.max, nums); //=> 42
   * @symb R.apply(f, [a, b, c]) = f(a, b, c)
   */

  var apply =
  /*#__PURE__*/
  _curry2(function apply(fn, args) {
    return fn.apply(this, args);
  });

  /**
   * Returns a list of all the enumerable own properties of the supplied object.
   * Note that the order of the output array is not guaranteed across different
   * JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own properties.
   * @see R.valuesIn, R.keys, R.toPairs
   * @example
   *
   *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
   */

  var values =
  /*#__PURE__*/
  _curry1(function values(obj) {
    var props = keys(obj);
    var len = props.length;
    var vals = [];
    var idx = 0;

    while (idx < len) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }

    return vals;
  });

  // delegating calls to .map

  function mapValues(fn, obj) {
    return _isArray(obj) ? obj.map(fn) : keys(obj).reduce(function (acc, key) {
      acc[key] = fn(obj[key]);
      return acc;
    }, {});
  }
  /**
   * Given a spec object recursively mapping properties to functions, creates a
   * function producing an object of the same structure, by mapping each property
   * to the result of calling its associated function with the supplied arguments.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
   * @param {Object} spec an object recursively mapping properties to functions for
   *        producing the values for these properties.
   * @return {Function} A function that returns an object of the same structure
   * as `spec', with each property set to the value returned by calling its
   * associated function with the supplied arguments.
   * @see R.converge, R.juxt
   * @example
   *
   *      const getMetrics = R.applySpec({
   *        sum: R.add,
   *        nested: { mul: R.multiply }
   *      });
   *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
   * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
   */


  var applySpec =
  /*#__PURE__*/
  _curry1(function applySpec(spec) {
    spec = mapValues(function (v) {
      return typeof v == 'function' ? v : applySpec(v);
    }, spec);
    return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
      var args = arguments;
      return mapValues(function (f) {
        return apply(f, args);
      }, spec);
    });
  });

  /**
   * Takes a value and applies a function to it.
   *
   * This function is also known as the `thrush` combinator.
   *
   * @func
   * @memberOf R
   * @since v0.25.0
   * @category Function
   * @sig a -> (a -> b) -> b
   * @param {*} x The value
   * @param {Function} f The function to apply
   * @return {*} The result of applying `f` to `x`
   * @example
   *
   *      const t42 = R.applyTo(42);
   *      t42(R.identity); //=> 42
   *      t42(R.add(1)); //=> 43
   */

  var applyTo =
  /*#__PURE__*/
  _curry2(function applyTo(x, f) {
    return f(x);
  });

  /**
   * Makes an ascending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
   * @see R.descend
   * @example
   *
   *      const byAge = R.ascend(R.prop('age'));
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByYoungestFirst = R.sort(byAge, people);
   *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
   */

  var ascend =
  /*#__PURE__*/
  _curry3(function ascend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @private
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original except for the changed property.
   */

  function _assoc(prop, val, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop] = val;
      return arr;
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    result[prop] = val;
    return result;
  }

  /**
   * Checks if the input value is `null` or `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
   * @example
   *
   *      R.isNil(null); //=> true
   *      R.isNil(undefined); //=> true
   *      R.isNil(0); //=> false
   *      R.isNil([]); //=> false
   */

  var isNil =
  /*#__PURE__*/
  _curry1(function isNil(x) {
    return x == null;
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the nodes required
   * to create the given path, and placing the specific value at the tail end of
   * that path. Note that this copies and flattens prototype properties onto the
   * new object as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> a -> {a} -> {a}
   * @param {Array} path the path to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except along the specified path.
   * @see R.dissocPath
   * @example
   *
   *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
   *
   *      // Any missing or non-object keys in path will be overridden
   *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
   */

  var assocPath =
  /*#__PURE__*/
  _curry3(function assocPath(path, val, obj) {
    if (path.length === 0) {
      return val;
    }

    var idx = path[0];

    if (path.length > 1) {
      var nextObj = !isNil(obj) && _has(idx, obj) && typeof obj[idx] === 'object' ? obj[idx] : _isInteger(path[1]) ? [] : {};
      val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
    }

    return _assoc(idx, val, obj);
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig Idx -> a -> {k: v} -> {k: v}
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except for the changed property.
   * @see R.dissoc, R.pick
   * @example
   *
   *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
   */

  var assoc =
  /*#__PURE__*/
  _curry3(function assoc(prop, val, obj) {
    return assocPath([prop], val, obj);
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly `n` parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} n The desired arity of the new function.
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity `n`.
   * @see R.binary, R.unary
   * @example
   *
   *      const takesTwoArgs = (a, b) => [a, b];
   *
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      const takesOneArg = R.nAry(1, takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only `n` arguments are passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.nAry(0, f)(a, b) = f()
   * @symb R.nAry(1, f)(a, b) = f(a)
   * @symb R.nAry(2, f)(a, b) = f(a, b)
   */

  var nAry =
  /*#__PURE__*/
  _curry2(function nAry(n, fn) {
    switch (n) {
      case 0:
        return function () {
          return fn.call(this);
        };

      case 1:
        return function (a0) {
          return fn.call(this, a0);
        };

      case 2:
        return function (a0, a1) {
          return fn.call(this, a0, a1);
        };

      case 3:
        return function (a0, a1, a2) {
          return fn.call(this, a0, a1, a2);
        };

      case 4:
        return function (a0, a1, a2, a3) {
          return fn.call(this, a0, a1, a2, a3);
        };

      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.call(this, a0, a1, a2, a3, a4);
        };

      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.call(this, a0, a1, a2, a3, a4, a5);
        };

      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
        };

      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
        };

      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
        };

      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
        };

      default:
        throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
    }
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 2 parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (a -> b -> c -> ... -> z) -> ((a, b) -> z)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 2.
   * @see R.nAry, R.unary
   * @example
   *
   *      const takesThreeArgs = function(a, b, c) {
   *        return [a, b, c];
   *      };
   *      takesThreeArgs.length; //=> 3
   *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
   *
   *      const takesTwoArgs = R.binary(takesThreeArgs);
   *      takesTwoArgs.length; //=> 2
   *      // Only 2 arguments are passed to the wrapped function
   *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
   * @symb R.binary(f)(a, b, c) = f(a, b)
   */

  var binary =
  /*#__PURE__*/
  _curry1(function binary(fn) {
    return nAry(2, fn);
  });

  function _isFunction(x) {
    var type = Object.prototype.toString.call(x);
    return type === '[object Function]' || type === '[object AsyncFunction]' || type === '[object GeneratorFunction]' || type === '[object AsyncGeneratorFunction]';
  }

  /**
   * "lifts" a function to be the specified arity, so that it may "map over" that
   * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig Number -> (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.lift, R.ap
   * @example
   *
   *      const madd3 = R.liftN(3, (...args) => R.sum(args));
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   */

  var liftN =
  /*#__PURE__*/
  _curry2(function liftN(arity, fn) {
    var lifted = curryN(arity, fn);
    return curryN(arity, function () {
      return _arrayReduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });

  /**
   * "lifts" a function of arity >= 1 so that it may "map over" a list, Function or other
   * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.liftN
   * @example
   *
   *      const madd3 = R.lift((a, b, c) => a + b + c);
   *
   *      madd3([100, 200], [30, 40], [5, 6, 7]); //=> [135, 136, 137, 145, 146, 147, 235, 236, 237, 245, 246, 247]
   *
   *      const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
   *
   *      madd5([10, 20], [1], [2, 3], [4], [100, 200]); //=> [117, 217, 118, 218, 127, 227, 128, 228]
   */

  var lift =
  /*#__PURE__*/
  _curry1(function lift(fn) {
    return liftN(fn.length, fn);
  });

  /**
   * A function which calls the two provided functions and returns the `&&`
   * of the results.
   * It returns the result of the first function if it is false-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * false-y value.
   *
   * In addition to functions, `R.both` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f A predicate
   * @param {Function} g Another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
   * @see R.either, R.allPass, R.and
   * @example
   *
   *      const gt10 = R.gt(R.__, 10)
   *      const lt20 = R.lt(R.__, 20)
   *      const f = R.both(gt10, lt20);
   *      f(15); //=> true
   *      f(30); //=> false
   *
   *      R.both(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(false)
   *      R.both([false, false, 'a'], [11]); //=> [false, false, 11]
   */

  var both =
  /*#__PURE__*/
  _curry2(function both(f, g) {
    return _isFunction(f) ? function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } : lift(and)(f, g);
  });

  /**
   * Returns the result of calling its first argument with the remaining
   * arguments. This is occasionally useful as a converging function for
   * [`R.converge`](#converge): the first branch can produce a function while the
   * remaining branches produce values to be passed to that function as its
   * arguments.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig ((*... -> a), *...) -> a
   * @param {Function} fn The function to apply to the remaining arguments.
   * @param {...*} args Any number of positional arguments.
   * @return {*}
   * @see R.apply
   * @example
   *
   *      R.call(R.add, 1, 2); //=> 3
   *
   *      const indentN = R.pipe(
   *        R.repeat(' '),
   *        R.join(''),
   *        R.replace(/^(?!$)/gm)
   *      );
   *
   *      const format = R.converge(
   *        R.call,
   *        [
   *          R.pipe(R.prop('indent'), indentN),
   *          R.prop('value')
   *        ]
   *      );
   *
   *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
   * @symb R.call(f, a, b) = f(a, b)
   */

  var call =
  /*#__PURE__*/
  _curry1(function call(fn) {
    return fn.apply(this, Array.prototype.slice.call(arguments, 1));
  });

  /**
   * `_makeFlat` is a helper function that returns a one-level or fully recursive
   * function based on the flag passed in.
   *
   * @private
   */

  function _makeFlat(recursive) {
    return function flatt(list) {
      var value, jlen, j;
      var result = [];
      var idx = 0;
      var ilen = list.length;

      while (idx < ilen) {
        if (_isArrayLike(list[idx])) {
          value = recursive ? flatt(list[idx]) : list[idx];
          j = 0;
          jlen = value.length;

          while (j < jlen) {
            result[result.length] = value[j];
            j += 1;
          }
        } else {
          result[result.length] = list[idx];
        }

        idx += 1;
      }

      return result;
    };
  }

  function _forceReduced(x) {
    return {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }

  var tInit$1 = '@@transducer/init';
  var tStep$1 = '@@transducer/step';
  var tResult = '@@transducer/result';

  var XPreservingReduced =
  /*#__PURE__*/
  function () {
    function XPreservingReduced(xf) {
      this.xf = xf;
    }

    XPreservingReduced.prototype[tInit$1] = _xfBase.init;
    XPreservingReduced.prototype[tResult] = _xfBase.result;

    XPreservingReduced.prototype[tStep$1] = function (result, input) {
      var ret = this.xf[tStep$1](result, input);
      return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
    };

    return XPreservingReduced;
  }();

  var XFlatCat =
  /*#__PURE__*/
  function () {
    function XFlatCat(xf) {
      this.xf = new XPreservingReduced(xf);
    }

    XFlatCat.prototype[tInit$1] = _xfBase.init;
    XFlatCat.prototype[tResult] = _xfBase.result;

    XFlatCat.prototype[tStep$1] = function (result, input) {
      return !_isArrayLike(input) ? _xArrayReduce(this.xf, result, [input]) : _xReduce(this.xf, result, input);
    };

    return XFlatCat;
  }();

  var _flatCat = function _xcat(xf) {
    return new XFlatCat(xf);
  };

  function _xchain(f) {
    return function (xf) {
      return _xmap(f)(_flatCat(xf));
    };
  }

  /**
   * `chain` maps a function over a list and concatenates the results. `chain`
   * is also known as `flatMap` in some libraries.
   *
   * Dispatches to the `chain` method of the second argument, if present,
   * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
   *
   * If second argument is a function, `chain(f, g)(x)` is equivalent to `f(g(x), x)`.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain m => (a -> m b) -> m a -> m b
   * @param {Function} fn The function to map with
   * @param {Array} list The list to map over
   * @return {Array} The result of flat-mapping `list` with `fn`
   * @example
   *
   *      const duplicate = n => [n, n];
   *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
   *
   *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
   */

  var chain =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
    if (typeof monad === 'function') {
      return function (x) {
        return fn(monad(x))(x);
      };
    }

    return _makeFlat(false)(map(fn, monad));
  }));

  /**
   * Restricts a number to be within a range.
   *
   * Also works for other ordered types such as Strings and Dates.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Relation
   * @sig Ord a => a -> a -> a -> a
   * @param {Number} minimum The lower limit of the clamp (inclusive)
   * @param {Number} maximum The upper limit of the clamp (inclusive)
   * @param {Number} value Value to be clamped
   * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
   * @example
   *
   *      R.clamp(1, 10, -5) // => 1
   *      R.clamp(1, 10, 15) // => 10
   *      R.clamp(1, 10, 4)  // => 4
   */

  var clamp =
  /*#__PURE__*/
  _curry3(function clamp(min, max, value) {
    if (min > max) {
      throw new Error('min must not be greater than max in clamp(min, max, value)');
    }

    return value < min ? min : value > max ? max : value;
  });

  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : '') + (pattern.dotAll ? 's' : ''));
  }

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */

  function _clone(value, deep, map) {
    map || (map = new _ObjectMap()); // this avoids the slower switch with a quick if decision removing some milliseconds in each run.

    if (_isPrimitive(value)) {
      return value;
    }

    var copy = function copy(copiedValue) {
      // Check for circular and same references on the object graph and return its corresponding clone.
      var cachedCopy = map.get(value);

      if (cachedCopy) {
        return cachedCopy;
      }

      map.set(value, copiedValue);

      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          copiedValue[key] = deep ? _clone(value[key], true, map) : value[key];
        }
      }

      return copiedValue;
    };

    switch (type(value)) {
      case 'Object':
        return copy(Object.create(Object.getPrototypeOf(value)));

      case 'Array':
        return copy([]);

      case 'Date':
        return new Date(value.valueOf());

      case 'RegExp':
        return _cloneRegExp(value);

      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'BigInt64Array':
      case 'BigUint64Array':
        return value.slice();

      default:
        return value;
    }
  }

  function _isPrimitive(param) {
    var type = typeof param;
    return param == null || type != 'object' && type != 'function';
  }

  var _ObjectMap =
  /*#__PURE__*/
  function () {
    function _ObjectMap() {
      this.map = {};
      this.length = 0;
    }

    _ObjectMap.prototype.set = function (key, value) {
      const hashedKey = this.hash(key);
      let bucket = this.map[hashedKey];

      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }

      bucket.push([key, value]);
      this.length += 1;
    };

    _ObjectMap.prototype.hash = function (key) {
      let hashedKey = [];

      for (var value in key) {
        hashedKey.push(Object.prototype.toString.call(key[value]));
      }

      return hashedKey.join();
    };

    _ObjectMap.prototype.get = function (key) {
      /**
       * depending on the number of objects to be cloned is faster to just iterate over the items in the map just because the hash function is so costly,
       * on my tests this number is 180, anything above that using the hash function is faster.
       */
      if (this.length <= 180) {
        for (const p in this.map) {
          const bucket = this.map[p];

          for (let i = 0; i < bucket.length; i += 1) {
            const element = bucket[i];

            if (element[0] === key) {
              return element[1];
            }
          }
        }

        return;
      }

      const hashedKey = this.hash(key);
      const bucket = this.map[hashedKey];

      if (!bucket) {
        return;
      }

      for (let i = 0; i < bucket.length; i += 1) {
        const element = bucket[i];

        if (element[0] === key) {
          return element[1];
        }
      }
    };

    return _ObjectMap;
  }();

  /**
   * Creates a deep copy of the source that can be used in place of the source
   * object without retaining any references to it.
   * The source object may contain (nested) `Array`s and `Object`s,
   * `Number`s, `String`s, `Boolean`s and `Date`s.
   * `Function`s are assigned by reference rather than copied.
   *
   * Dispatches to a `clone` method if present.
   *
   * Note that if the source object has multiple nodes that share a reference,
   * the returned object will have the same structure, but the references will
   * be pointed to the location within the cloned value.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {*} -> {*}
   * @param {*} value The object or array to clone
   * @return {*} A deeply cloned copy of `val`
   * @example
   *
   *      const objects = [{}, {}, {}];
   *      const objectsClone = R.clone(objects);
   *      objects === objectsClone; //=> false
   *      objects[0] === objectsClone[0]; //=> false
   */

  var clone$1 =
  /*#__PURE__*/
  _curry1(function clone(value) {
    return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, true);
  });

  /**
   * Splits a list into sub-lists, based on the result of calling a key-returning function on each element,
   * and grouping the results according to values returned.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> [[b]]
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} list The array to group
   * @return {Array}
   *    An array of arrays where each sub-array contains items for which
   *    the String-returning function has returned the same value.
   * @see R.groupBy, R.partition
   * @example
   *      R.collectBy(R.prop('type'), [
   *        {type: 'breakfast', item: ''},
   *        {type: 'lunch', item: ''},
   *        {type: 'dinner', item: ''},
   *        {type: 'breakfast', item: ''},
   *        {type: 'lunch', item: ''}
   *      ]);
   *
   *      // [ [ {type: 'breakfast', item: ''},
   *      //     {type: 'breakfast', item: ''} ],
   *      //   [ {type: 'lunch', item: ''},
   *      //     {type: 'lunch', item: ''} ],
   *      //   [ {type: 'dinner', item: ''} ] ]
   */

  var collectBy =
  /*#__PURE__*/
  _curry2(function collectBy(fn, list) {
    var group = _reduce(function (o, x) {
      var tag = fn(x);

      if (o[tag] === undefined) {
        o[tag] = [];
      }

      o[tag].push(x);
      return o;
    }, {}, list);

    var newList = [];

    for (var tag in group) {
      newList.push(group[tag]);
    }

    return newList;
  });

  /**
   * Makes a comparator function out of a function that reports whether the first
   * element is less than the second.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
   * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
   * is less than the second, `false` otherwise
   * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
   * @example
   *
   *      const byAge = R.comparator((a, b) => a.age < b.age);
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByIncreasingAge = R.sort(byAge, people);
   *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
   */

  var comparator =
  /*#__PURE__*/
  _curry1(function comparator(pred) {
    return function (a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });

  /**
   * A function that returns the `!` of its argument. It will return `true` when
   * passed false-y value, and `false` when passed a truth-y one.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig * -> Boolean
   * @param {*} a any value
   * @return {Boolean} the logical inverse of passed argument.
   * @see R.complement
   * @example
   *
   *      R.not(true); //=> false
   *      R.not(false); //=> true
   *      R.not(0); //=> true
   *      R.not(1); //=> false
   */

  var not =
  /*#__PURE__*/
  _curry1(function not(a) {
    return !a;
  });

  /**
   * Takes a function `f` and returns a function `g` such that if called with the same arguments
   * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
   *
   * `R.complement` may be applied to any functor
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> *) -> (*... -> Boolean)
   * @param {Function} f
   * @return {Function}
   * @see R.not
   * @example
   *
   *      const isNotNil = R.complement(R.isNil);
   *      R.isNil(null); //=> true
   *      isNotNil(null); //=> false
   *      R.isNil(7); //=> false
   *      isNotNil(7); //=> true
   */

  var complement =
  /*#__PURE__*/
  lift(not);

  function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  }

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implementation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */

  function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;

      if (length === 0) {
        return fn();
      }

      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */

  var slice =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */

  var tail =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _checkForMethod('tail',
  /*#__PURE__*/
  slice(1, Infinity)));

  /**
   * Performs left-to-right function composition. The first argument may have
   * any arity; the remaining arguments must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      const f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   * @symb R.pipe(f, g, h)(a)(b) = h(g(f(a)))(b)
   */

  function pipe() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }

    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  }

  /**
   * Returns a new list or string with the elements or characters in reverse
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {Array|String} list
   * @return {Array|String}
   * @example
   *
   *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
   *      R.reverse([1, 2]);     //=> [2, 1]
   *      R.reverse([1]);        //=> [1]
   *      R.reverse([]);         //=> []
   *
   *      R.reverse('abc');      //=> 'cba'
   *      R.reverse('ab');       //=> 'ba'
   *      R.reverse('a');        //=> 'a'
   *      R.reverse('');         //=> ''
   */

  var reverse =
  /*#__PURE__*/
  _curry1(function reverse(list) {
    return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
  });

  /**
   * Performs right-to-left function composition. The last argument may have
   * any arity; the remaining arguments must be unary.
   *
   * **Note:** The result of compose is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipe
   * @example
   *
   *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
   *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
   *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
   *
   * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
   * @symb R.compose(f, g, h)(a)(b) = f(g(h(a)))(b)
   */

  function compose() {
    if (arguments.length === 0) {
      throw new Error('compose requires at least one argument');
    }

    return pipe.apply(this, reverse(arguments));
  }

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> ''
   */

  var head =
  /*#__PURE__*/
  nth(0);

  function _identity(x) {
    return x;
  }

  /**
   * A function that does nothing but return the parameter supplied to it. Good
   * as a default or placeholder function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> a
   * @param {*} x The value to return.
   * @return {*} The input value, `x`.
   * @example
   *
   *      R.identity(1); //=> 1
   *
   *      const obj = {};
   *      R.identity(obj) === obj; //=> true
   * @symb R.identity(a) = a
   */

  var identity =
  /*#__PURE__*/
  _curry1(_identity);

  /**
   * Performs left-to-right function composition using transforming function. The first function may have
   * any arity; the remaining functions must be unary.
   *
   * **Note:** The result of pipeWith is not automatically curried. Transforming function is not used on the
   * first argument.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((* -> *), [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)]) -> ((a, b, ..., n) -> z)
   * @param {Function} transformer The transforming function
   * @param {Array} functions The functions to pipe
   * @return {Function}
   * @see R.composeWith, R.pipe
   * @example
   *
   *      const pipeWhileNotNil = R.pipeWith((f, res) => R.isNil(res) ? res : f(res));
   *      const f = pipeWhileNotNil([Math.pow, R.negate, R.inc])
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipeWith(f)([g, h, i])(...args) = f(i, f(h, g(...args)))
   */

  var pipeWith =
  /*#__PURE__*/
  _curry2(function pipeWith(xf, list) {
    if (list.length <= 0) {
      return identity;
    }

    var headList = head(list);
    var tailList = tail(list);
    return _arity(headList.length, function () {
      return _reduce(function (result, f) {
        return xf.call(this, f, result);
      }, headList.apply(this, arguments), tailList);
    });
  });

  /**
   * Performs right-to-left function composition using transforming function. The last function may have
   * any arity; the remaining functions must be unary. Unlike `compose`, functions are passed in an array.
   *
   * **Note:** The result of composeWith is not automatically curried. Transforming function is not used
   * on the last argument.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((* -> *), [(y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)]) -> ((a, b, ..., n) -> z)
   * @param {Function} transformer The transforming function
   * @param {Array} functions The functions to compose
   * @return {Function}
   * @see R.compose, R.pipeWith
   * @example
   *
   *      const composeWhileNotNil = R.composeWith((f, res) => R.isNil(res) ? res : f(res));
   *
   *      composeWhileNotNil([R.inc, R.prop('age')])({age: 1}) //=> 2
   *      composeWhileNotNil([R.inc, R.prop('age')])({}) //=> undefined
   *
   * @symb R.composeWith(f)([g, h, i])(...args) = f(g, f(h, i(...args)))
   */

  var composeWith =
  /*#__PURE__*/
  _curry2(function composeWith(xf, list) {
    return pipeWith.apply(this, [xf, reverse(list)]);
  });

  /**
   * Returns the result of concatenating the given lists or strings.
   *
   * Note: `R.concat` expects both arguments to be of the same type,
   * unlike the native `Array.prototype.concat` method. It will throw
   * an error if you `concat` an Array with a non-Array value.
   *
   * Dispatches to the `concat` method of the first argument, if present.
   * Can also concatenate two members of a [fantasy-land
   * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @sig String -> String -> String
   * @param {Array|String} firstList The first list
   * @param {Array|String} secondList The second list
   * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
   * `secondList`.
   *
   * @example
   *
   *      R.concat('ABC', 'DEF'); // 'ABCDEF'
   *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   *      R.concat([], []); //=> []
   */

  var concat =
  /*#__PURE__*/
  _curry2(function concat(a, b) {
    if (_isArray(a)) {
      if (_isArray(b)) {
        return a.concat(b);
      }

      throw new TypeError(toString(b) + ' is not an array');
    }

    if (_isString(a)) {
      if (_isString(b)) {
        return a + b;
      }

      throw new TypeError(toString(b) + ' is not a string');
    }

    if (a != null && _isFunction(a['fantasy-land/concat'])) {
      return a['fantasy-land/concat'](b);
    }

    if (a != null && _isFunction(a.concat)) {
      return a.concat(b);
    }

    throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
  });

  /**
   * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
   * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
   * to `fn` are applied to each of the predicates in turn until one returns a
   * "truthy" value, at which point `fn` returns the result of applying its
   * arguments to the corresponding transformer. If none of the predicates
   * matches, `fn` returns undefined.
   *
   * **Please note**: This is not a direct substitute for a `switch` statement.
   * Remember that both elements of every pair passed to `cond` are *functions*,
   * and `cond` returns a function.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Logic
   * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
   * @param {Array} pairs A list of [predicate, transformer]
   * @return {Function}
   * @see R.ifElse, R.unless, R.when
   * @example
   *
   *      const fn = R.cond([
   *        [R.equals(0),   R.always('water freezes at 0C')],
   *        [R.equals(100), R.always('water boils at 100C')],
   *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
   *      ]);
   *      fn(0); //=> 'water freezes at 0C'
   *      fn(50); //=> 'nothing special happens at 50C'
   *      fn(100); //=> 'water boils at 100C'
   */

  var cond =
  /*#__PURE__*/
  _curry1(function cond(pairs) {
    var arity = reduce(max, 0, map(function (pair) {
      return pair[0].length;
    }, pairs));
    return _arity(arity, function () {
      var idx = 0;

      while (idx < pairs.length) {
        if (pairs[idx][0].apply(this, arguments)) {
          return pairs[idx][1].apply(this, arguments);
        }

        idx += 1;
      }
    });
  });

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * Please note that default parameters don't count towards a [function arity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/length)
   * and therefore `curry` won't work well with those.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN, R.partial
   * @example
   *
   *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
   *      const curriedAddFourNumbers = R.curry(addFourNumbers);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   *
   *      // R.curry not working well with default parameters
   *      const h = R.curry((a, b, c = 2) => a + b + c);
   *      h(1)(2)(7); //=> Error! (`3` is not a function!)
   */

  var curry =
  /*#__PURE__*/
  _curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type. The arity of the function
   * returned is specified to allow using variadic constructor functions.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Function
   * @sig Number -> (* -> {*}) -> (* -> {*})
   * @param {Number} n The arity of the constructor function.
   * @param {Function} Fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @example
   *
   *      // Variadic Constructor function
   *      function Salad() {
   *        this.ingredients = arguments;
   *      }
   *
   *      Salad.prototype.recipe = function() {
   *        const instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
   *        return R.join('\n', instructions);
   *      };
   *
   *      const ThreeLayerSalad = R.constructN(3, Salad);
   *
   *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
   *      const salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
   *
   *      console.log(salad.recipe());
   *      // Add a dollop of Mayonnaise
   *      // Add a dollop of Potato Chips
   *      // Add a dollop of Ketchup
   */

  var constructN =
  /*#__PURE__*/
  _curry2(function constructN(n, Fn) {
    if (n > 10) {
      throw new Error('Constructor with greater than ten arguments');
    }

    if (n === 0) {
      return function () {
        return new Fn();
      };
    }

    return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
      switch (n) {
        case 1:
          return new Fn($0);

        case 2:
          return new Fn($0, $1);

        case 3:
          return new Fn($0, $1, $2);

        case 4:
          return new Fn($0, $1, $2, $3);

        case 5:
          return new Fn($0, $1, $2, $3, $4);

        case 6:
          return new Fn($0, $1, $2, $3, $4, $5);

        case 7:
          return new Fn($0, $1, $2, $3, $4, $5, $6);

        case 8:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7);

        case 9:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);

        case 10:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
      }
    }));
  });

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> {*}) -> (* -> {*})
   * @param {Function} fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @see R.invoker
   * @example
   *
   *      // Constructor function
   *      function Animal(kind) {
   *        this.kind = kind;
   *      };
   *      Animal.prototype.sighting = function() {
   *        return "It's a " + this.kind + "!";
   *      }
   *
   *      const AnimalConstructor = R.construct(Animal)
   *
   *      // Notice we no longer need the 'new' keyword:
   *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
   *
   *      const animalTypes = ["Lion", "Tiger", "Bear"];
   *      const animalSighting = R.invoker(0, 'sighting');
   *      const sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
   *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
   */

  var construct =
  /*#__PURE__*/
  _curry1(function construct(Fn) {
    return constructN(Fn.length, Fn);
  });

  /**
   * Accepts a converging function and a list of branching functions and returns
   * a new function. The arity of the new function is the same as the arity of
   * the longest branching function. When invoked, this new function is applied
   * to some arguments, and each branching function is applied to those same
   * arguments. The results of each branching function are passed as arguments
   * to the converging function to produce the return value.
   *
   * @func
   * @memberOf R
   * @since v0.4.2
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} after A function. `after` will be invoked with the return values of
   *        `fn1` and `fn2` as its arguments.
   * @param {Array} functions A list of functions.
   * @return {Function} A new function.
   * @see R.useWith
   * @example
   *
   *      const average = R.converge(R.divide, [R.sum, R.length])
   *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
   *
   *      const strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
   *      strangeConcat("Yodel") //=> "YODELyodel"
   *
   * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
   */

  var converge =
  /*#__PURE__*/
  _curry2(function converge(after, fns) {
    return curryN(reduce(max, 0, pluck('length', fns)), function () {
      var args = arguments;
      var context = this;
      return after.apply(context, _map(function (fn) {
        return fn.apply(context, args);
      }, fns));
    });
  });

  /**
   * Returns the number of items in a given `list` matching the predicate `f`
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} predicate to match items against
   * @return {Array} list of items to count in
   * @example
   *
   *      const even = x => x % 2 == 0;
   *
   *      R.count(even, [1, 2, 3, 4, 5]); // => 2
   *      R.map(R.count(even), [[1, 1, 1], [2, 3, 4, 5], [6]]); // => [0, 2, 1]
   */

  var count =
  /*#__PURE__*/
  curry(function (pred, list) {
    return _reduce(function (a, e) {
      return pred(e) ? a + 1 : a;
    }, 0, list);
  });

  var XReduceBy =
  /*#__PURE__*/
  function () {
    function XReduceBy(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }

    XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

    XReduceBy.prototype['@@transducer/result'] = function (result) {
      var key;

      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf['@@transducer/step'](result, this.inputs[key]);

          if (result['@@transducer/reduced']) {
            result = result['@@transducer/value'];
            break;
          }
        }
      }

      this.inputs = null;
      return this.xf['@@transducer/result'](result);
    };

    XReduceBy.prototype['@@transducer/step'] = function (result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, _clone(this.valueAcc, false)];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };

    return XReduceBy;
  }();

  function _xreduceBy(valueFn, valueAcc, keyFn) {
    return function (xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    };
  }

  /**
   * Groups the elements of the list according to the result of calling
   * the String-returning function `keyFn` on each element and reduces the elements
   * of each group to a single value via the reducer function `valueFn`.
   *
   * The value function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to short circuit the iteration.
   *
   * This function is basically a more general [`groupBy`](#groupBy) function.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category List
   * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
   * @param {Function} valueFn The function that reduces the elements of each group to a single
   *        value. Receives two values, accumulator for a particular group and the current element.
   * @param {*} acc The (initial) accumulator value for each group.
   * @param {Function} keyFn The function that maps the list's element into a key.
   * @param {Array} list The array to group.
   * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
   *         `valueFn` for elements which produced that key when passed to `keyFn`.
   * @see R.groupBy, R.reduce, R.reduced
   * @example
   *
   *      const groupNames = (acc, {name}) => acc.concat(name)
   *      const toGrade = ({score}) =>
   *        score < 65 ? 'F' :
   *        score < 70 ? 'D' :
   *        score < 80 ? 'C' :
   *        score < 90 ? 'B' : 'A'
   *
   *      var students = [
   *        {name: 'Abby', score: 83},
   *        {name: 'Bart', score: 62},
   *        {name: 'Curt', score: 88},
   *        {name: 'Dora', score: 92},
   *      ]
   *
   *      reduceBy(groupNames, [], toGrade, students)
   *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
   */

  var reduceBy =
  /*#__PURE__*/
  _curryN(4, [],
  /*#__PURE__*/
  _dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
    var xf = _xwrap(function (acc, elt) {
      var key = keyFn(elt);
      var value = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, false), elt);

      if (value && value['@@transducer/reduced']) {
        return _reduced(acc);
      }

      acc[key] = value;
      return acc;
    });

    return _xReduce(xf, {}, list);
  }));

  /**
   * Counts the elements of a list according to how many match each value of a
   * key generated by the supplied function. Returns an object mapping the keys
   * produced by `fn` to the number of occurrences in the list. Note that all
   * keys are coerced to strings because of how JavaScript objects work.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig (a -> String) -> [a] -> {*}
   * @param {Function} fn The function used to map values to keys.
   * @param {Array} list The list to count elements from.
   * @return {Object} An object mapping keys to number of occurrences in the list.
   * @example
   *
   *      const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
   *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
   *
   *      const letters = ['a', 'b', 'A', 'a', 'B', 'c'];
   *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
   */

  var countBy =
  /*#__PURE__*/
  reduceBy(function (acc, elem) {
    return acc + 1;
  }, 0);

  /**
   * Decrements its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n - 1
   * @see R.inc
   * @example
   *
   *      R.dec(42); //=> 41
   */

  var dec =
  /*#__PURE__*/
  add(-1);

  /**
   * Returns the second argument if it is not `null`, `undefined` or `NaN`;
   * otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {a} default The default value.
   * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
   * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
   * @example
   *
   *      const defaultTo42 = R.defaultTo(42);
   *
   *      defaultTo42(null);  //=> 42
   *      defaultTo42(undefined);  //=> 42
   *      defaultTo42(false);  //=> false
   *      defaultTo42('Ramda');  //=> 'Ramda'
   *      // parseInt('string') results in NaN
   *      defaultTo42(parseInt('string')); //=> 42
   */

  var defaultTo =
  /*#__PURE__*/
  _curry2(function defaultTo(d, v) {
    return v == null || v !== v ? d : v;
  });

  /**
   * Makes a descending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
   * @see R.ascend
   * @example
   *
   *      const byAge = R.descend(R.prop('age'));
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByOldestFirst = R.sort(byAge, people);
   *        //=> [{ name: 'Peter', age: 78 }, { name: 'Emma', age: 70 }, { name: 'Mikhail', age: 62 }]
   */

  var descend =
  /*#__PURE__*/
  _curry3(function descend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa > bb ? -1 : aa < bb ? 1 : 0;
  });

  var _Set =
  /*#__PURE__*/
  function () {
    function _Set() {
      /* globals Set */
      this._nativeSet = typeof Set === 'function' ? new Set() : null;
      this._items = {};
    }

    // until we figure out why jsdoc chokes on this
    // @param item The item to add to the Set
    // @returns {boolean} true if the item did not exist prior, otherwise false
    //
    _Set.prototype.add = function (item) {
      return !hasOrAdd(item, true, this);
    }; //
    // @param item The item to check for existence in the Set
    // @returns {boolean} true if the item exists in the Set, otherwise false
    //


    _Set.prototype.has = function (item) {
      return hasOrAdd(item, false, this);
    }; //
    // Combines the logic for checking whether an item is a member of the set and
    // for adding a new item to the set.
    //
    // @param item       The item to check or add to the Set instance.
    // @param shouldAdd  If true, the item will be added to the set if it doesn't
    //                   already exist.
    // @param set        The set instance to check or add to.
    // @return {boolean} true if the item already existed, otherwise false.
    //


    return _Set;
  }();

  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item;
    var prevSize, newSize;

    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }

            return false;
          }
        } // these types can all utilise the native Set


        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;

            set._nativeSet.add(item);

            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }

            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }

            return false;
          }
        }

      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;

          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }

            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }

          return false;
        }

      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;

            set._nativeSet.add(item);

            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }

            return false;
          }

          if (!_includes(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }

            return false;
          }

          return true;
        }

      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }

          return false;
        }

      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }

            return false;
          }

          return true;
        }

      /* falls through */

      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);

        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }

          return false;
        } // scan through all previously applied items


        if (!_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }

          return false;
        }

        return true;
    }
  } // A simple Set type that honours R.equals semantics

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Objects and Arrays are compared in terms of
   * value equality, not reference equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
   * @example
   *
   *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
   *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
   *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
   */

  var difference =
  /*#__PURE__*/
  _curry2(function difference(first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    var secondLen = second.length;
    var toFilterOut = new _Set();

    for (var i = 0; i < secondLen; i += 1) {
      toFilterOut.add(second[i]);
    }

    while (idx < firstLen) {
      if (toFilterOut.add(first[idx])) {
        out[out.length] = first[idx];
      }

      idx += 1;
    }

    return out;
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Duplication is determined according to the
   * value returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
   * @example
   *
   *      const cmp = (x, y) => x.a === y.a;
   *      const l1 = [{a: 1}, {a: 2}, {a: 3}];
   *      const l2 = [{a: 3}, {a: 4}];
   *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
   *
   *      R.differenceWith(R.equals, [1, 2, 3, 3, 3], []); //=> [1, 2, 3]
   *      R.differenceWith(R.equals, [1, 2, 3, 3, 3], [1]); //=> [2, 3]
   */

  var differenceWith =
  /*#__PURE__*/
  _curry3(function differenceWith(pred, first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;

    while (idx < firstLen) {
      if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
        out.push(first[idx]);
      }

      idx += 1;
    }

    return out;
  });

  /**
   * Removes the sub-list of `list` starting at index `start` and containing
   * `count` elements. _Note that this is not destructive_: it returns a copy of
   * the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} start The position to start removing elements
   * @param {Number} count The number of elements to remove
   * @param {Array} list The list to remove from
   * @return {Array} A new Array with `count` elements from `start` removed.
   * @see R.without
   * @example
   *
   *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
   */

  var remove =
  /*#__PURE__*/
  _curry3(function remove(start, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start, count);
    return result;
  });

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @private
   * @param {String|Number} prop The name of the property to dissociate
   * @param {Object|Array} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   */

  function _dissoc(prop, obj) {
    if (obj == null) {
      return obj;
    }

    if (_isInteger(prop) && _isArray(obj)) {
      return remove(prop, 1, obj);
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    delete result[prop];
    return result;
  }

  /**
   * Makes a shallow clone of an object. Note that this copies and flattens
   * prototype properties onto the new object as well. All non-primitive
   * properties are copied by reference.
   *
   * @private
   * @param {String|Integer} prop The prop operating
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original.
   */

  function _shallowCloneObject(prop, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      return [].concat(obj);
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    return result;
  }
  /**
   * Makes a shallow clone of an object, omitting the property at the given path.
   * Note that this copies and flattens prototype properties onto the new object
   * as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.11.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {k: v} -> {k: v}
   * @param {Array} path The path to the value to omit
   * @param {Object} obj The object to clone
   * @return {Object} A new object without the property at path
   * @see R.assocPath
   * @example
   *
   *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
   */


  var dissocPath =
  /*#__PURE__*/
  _curry2(function dissocPath(path, obj) {
    if (obj == null) {
      return obj;
    }

    switch (path.length) {
      case 0:
        return obj;

      case 1:
        return _dissoc(path[0], obj);

      default:
        var head = path[0];
        var tail = Array.prototype.slice.call(path, 1);

        if (obj[head] == null) {
          return _shallowCloneObject(head, obj);
        } else {
          return assoc(head, dissocPath(tail, obj[head]), obj);
        }

    }
  });

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Object
   * @sig String -> {k: v} -> {k: v}
   * @param {String} prop The name of the property to dissociate
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   * @see R.assoc, R.omit
   * @example
   *
   *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
   */

  var dissoc =
  /*#__PURE__*/
  _curry2(function dissoc(prop, obj) {
    return dissocPath([prop], obj);
  });

  /**
   * Divides two numbers. Equivalent to `a / b`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a / b`.
   * @see R.multiply
   * @example
   *
   *      R.divide(71, 100); //=> 0.71
   *
   *      const half = R.divide(R.__, 2);
   *      half(42); //=> 21
   *
   *      const reciprocal = R.divide(1);
   *      reciprocal(4);   //=> 0.25
   */

  var divide =
  /*#__PURE__*/
  _curry2(function divide(a, b) {
    return a / b;
  });

  var XDrop =
  /*#__PURE__*/
  function () {
    function XDrop(n, xf) {
      this.xf = xf;
      this.n = n;
    }

    XDrop.prototype['@@transducer/init'] = _xfBase.init;
    XDrop.prototype['@@transducer/result'] = _xfBase.result;

    XDrop.prototype['@@transducer/step'] = function (result, input) {
      if (this.n > 0) {
        this.n -= 1;
        return result;
      }

      return this.xf['@@transducer/step'](result, input);
    };

    return XDrop;
  }();

  function _xdrop(n) {
    return function (xf) {
      return new XDrop(n, xf);
    };
  }

  /**
   * Returns all but the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `drop` method).
   *
   * Dispatches to the `drop` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*} A copy of list without the first `n` elements
   * @see R.take, R.transduce, R.dropLast, R.dropWhile
   * @example
   *
   *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(3, 'ramda');               //=> 'da'
   */

  var drop$1 =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['drop'], _xdrop, function drop(n, xs) {
    return slice(Math.max(0, n), Infinity, xs);
  }));

  var XTake =
  /*#__PURE__*/
  function () {
    function XTake(n, xf) {
      this.xf = xf;
      this.n = n;
      this.i = 0;
    }

    XTake.prototype['@@transducer/init'] = _xfBase.init;
    XTake.prototype['@@transducer/result'] = _xfBase.result;

    XTake.prototype['@@transducer/step'] = function (result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
      return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
    };

    return XTake;
  }();

  function _xtake(n) {
    return function (xf) {
      return new XTake(n, xf);
    };
  }

  /**
   * Returns the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `take` method).
   *
   * Dispatches to the `take` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*}
   * @see R.drop
   * @example
   *
   *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(3, 'ramda');               //=> 'ram'
   *
   *      const personnel = [
   *        'Dave Brubeck',
   *        'Paul Desmond',
   *        'Eugene Wright',
   *        'Joe Morello',
   *        'Gerry Mulligan',
   *        'Bob Bates',
   *        'Joe Dodge',
   *        'Ron Crotty'
   *      ];
   *
   *      const takeFive = R.take(5);
   *      takeFive(personnel);
   *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
   * @symb R.take(-1, [a, b]) = [a, b]
   * @symb R.take(0, [a, b]) = []
   * @symb R.take(1, [a, b]) = [a]
   * @symb R.take(2, [a, b]) = [a, b]
   */

  var take =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['take'], _xtake, function take(n, xs) {
    return slice(0, n < 0 ? Infinity : n, xs);
  }));

  function dropLast$1(n, xs) {
    return take(n < xs.length ? xs.length - n : 0, xs);
  }

  var XDropLast =
  /*#__PURE__*/
  function () {
    function XDropLast(n, xf) {
      if (n <= 0) {
        return xf;
      }

      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }

    XDropLast.prototype['@@transducer/init'] = _xfBase.init;

    XDropLast.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };

    XDropLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.full) {
        result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
      }

      this.store(input);
      return result;
    };

    XDropLast.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;

      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    return XDropLast;
  }();

  function _xdropLast(n) {
    return function (xf) {
      return new XDropLast(n, xf);
    };
  }

  /**
   * Returns a list containing all but the last `n` elements of the given `list`.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements of `list` to skip.
   * @param {Array} list The list of elements to consider.
   * @return {Array} A copy of the list with only the first `list.length - n` elements
   * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
   * @example
   *
   *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(3, 'ramda');               //=> 'ra'
   */

  var dropLast =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropLast, dropLast$1));

  function dropLastWhile$1(pred, xs) {
    var idx = xs.length - 1;

    while (idx >= 0 && pred(xs[idx])) {
      idx -= 1;
    }

    return slice(0, idx + 1, xs);
  }

  var XDropLastWhile =
  /*#__PURE__*/
  function () {
    function XDropLastWhile(fn, xf) {
      this.f = fn;
      this.retained = [];
      this.xf = xf;
    }

    XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;

    XDropLastWhile.prototype['@@transducer/result'] = function (result) {
      this.retained = null;
      return this.xf['@@transducer/result'](result);
    };

    XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.retain(result, input) : this.flush(result, input);
    };

    XDropLastWhile.prototype.flush = function (result, input) {
      result = _xReduce(this.xf, result, this.retained);
      this.retained = [];
      return this.xf['@@transducer/step'](result, input);
    };

    XDropLastWhile.prototype.retain = function (result, input) {
      this.retained.push(input);
      return result;
    };

    return XDropLastWhile;
  }();

  function _xdropLastWhile(fn) {
    return function (xf) {
      return new XDropLastWhile(fn, xf);
    };
  }

  /**
   * Returns a new list excluding all the tailing elements of a given list which
   * satisfy the supplied predicate function. It passes each value from the right
   * to the supplied predicate function, skipping elements until the predicate
   * function returns a `falsy` value. The predicate function is applied to one argument:
   * *(value)*.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} predicate The function to be called on each element
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
   * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
   * @example
   *
   *      const lteThree = x => x <= 3;
   *
   *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
   *
   *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
   */

  var dropLastWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropLastWhile, dropLastWhile$1));

  var XDropRepeatsWith =
  /*#__PURE__*/
  function () {
    function XDropRepeatsWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.lastValue = undefined;
      this.seenFirstValue = false;
    }

    XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
    XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;

    XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
      var sameAsLast = false;

      if (!this.seenFirstValue) {
        this.seenFirstValue = true;
      } else if (this.pred(this.lastValue, input)) {
        sameAsLast = true;
      }

      this.lastValue = input;
      return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
    };

    return XDropRepeatsWith;
  }();

  function _xdropRepeatsWith(pred) {
    return function (xf) {
      return new XDropRepeatsWith(pred, xf);
    };
  }

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> ''
   */

  var last =
  /*#__PURE__*/
  nth(-1);

  /**
   * Returns a new list without any consecutively repeating elements. Equality is
   * determined by applying the supplied predicate to each pair of consecutive elements. The
   * first element in a series of equal elements will be preserved.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *      const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
   *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
   */

  var dropRepeatsWith =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;

    if (len !== 0) {
      result[0] = list[0];

      while (idx < len) {
        if (!pred(last(result), list[idx])) {
          result[result.length] = list[idx];
        }

        idx += 1;
      }
    }

    return result;
  }));

  /**
   * Returns a new list without any consecutively repeating elements.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
   */

  var dropRepeats =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _dispatchable([], function () {
    return _xdropRepeatsWith(equals);
  },
  /*#__PURE__*/
  dropRepeatsWith(equals)));

  /**
   * Takes a function and two values in its domain and returns `true` if the
   * values map to the same value in the codomain; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Relation
   * @sig (a -> b) -> a -> a -> Boolean
   * @param {Function} f
   * @param {*} x
   * @param {*} y
   * @return {Boolean}
   * @example
   *
   *      R.eqBy(Math.abs, 5, -5); //=> true
   */

  var eqBy =
  /*#__PURE__*/
  _curry3(function eqBy(f, x, y) {
    return equals(f(x), f(y));
  });

  /**
   * Returns a new list without any consecutively repeating elements,
   * based upon the value returned by applying the supplied function to
   * each list element. [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.29.0
   * @category List
   * @sig (a -> b) -> [a] -> [a]
   * @param {Function} fn A function used to produce a value to use during comparisons.
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *     R.dropRepeatsBy(Math.abs, [1, -1, -1, 2, 3, -4, 4, 2, 2]); //=> [1, 2, 3, -4, 2]
   */

  var dropRepeatsBy =
  /*#__PURE__*/
  _curry2(function (fn, list) {
    return _dispatchable([], function () {
      return _xdropRepeatsWith(eqBy(fn));
    }, dropRepeatsWith(eqBy(fn)))(list);
  });

  var XDropWhile =
  /*#__PURE__*/
  function () {
    function XDropWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropWhile.prototype['@@transducer/result'] = _xfBase.result;

    XDropWhile.prototype['@@transducer/step'] = function (result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }

        this.f = null;
      }

      return this.xf['@@transducer/step'](result, input);
    };

    return XDropWhile;
  }();

  function _xdropWhile(f) {
    return function (xf) {
      return new XDropWhile(f, xf);
    };
  }

  /**
   * Returns a new list excluding the leading elements of a given list which
   * satisfy the supplied predicate function. It passes each value to the supplied
   * predicate function, skipping elements while the predicate function returns
   * `true`. The predicate function is applied to one argument: *(value)*.
   *
   * Dispatches to the `dropWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.takeWhile, R.transduce, R.addIndex
   * @example
   *
   *      const lteTwo = x => x <= 2;
   *
   *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
   *
   *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
   */

  var dropWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
    var idx = 0;
    var len = xs.length;

    while (idx < len && pred(xs[idx])) {
      idx += 1;
    }

    return slice(idx, Infinity, xs);
  }));

  /**
   * Returns the first argument if it is truthy, otherwise the second argument.
   * Acts as the boolean `or` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.either, R.and
   * @example
   *
   *      R.or(true, true); //=> true
   *      R.or(true, false); //=> true
   *      R.or(false, true); //=> true
   *      R.or(false, false); //=> false
   */

  var or =
  /*#__PURE__*/
  _curry2(function or(a, b) {
    return a || b;
  });

  /**
   * A function wrapping calls to the two functions in an `||` operation,
   * returning the result of the first function if it is truth-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * truth-y value.
   *
   * In addition to functions, `R.either` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f a predicate
   * @param {Function} g another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
   * @see R.both, R.anyPass, R.or
   * @example
   *
   *      const gt10 = x => x > 10;
   *      const even = x => x % 2 === 0;
   *      const f = R.either(gt10, even);
   *      f(101); //=> true
   *      f(8); //=> true
   *
   *      R.either(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(55)
   *      R.either([false, false, 'a'], [11]) // => [11, 11, "a"]
   */

  var either =
  /*#__PURE__*/
  _curry2(function either(f, g) {
    return _isFunction(f) ? function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } : lift(or)(f, g);
  });

  /**
   * Tests whether or not an object is a typed array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is a typed array, `false` otherwise.
   * @example
   *
   *      _isTypedArray(new Uint8Array([])); //=> true
   *      _isTypedArray(new Float32Array([])); //=> true
   *      _isTypedArray([]); //=> false
   *      _isTypedArray(null); //=> false
   *      _isTypedArray({}); //=> false
   */
  function _isTypedArray(val) {
    var type = Object.prototype.toString.call(val);
    return type === '[object Uint8ClampedArray]' || type === '[object Int8Array]' || type === '[object Uint8Array]' || type === '[object Int16Array]' || type === '[object Uint16Array]' || type === '[object Int32Array]' || type === '[object Uint32Array]' || type === '[object Float32Array]' || type === '[object Float64Array]' || type === '[object BigInt64Array]' || type === '[object BigUint64Array]';
  }

  /**
   * Returns the empty value of its argument's type. Ramda defines the empty
   * value of Array (`[]`), Object (`{}`), String (`''`),
   * TypedArray (`Uint8Array []`, `Float32Array []`, etc), and Arguments. Other
   * types are supported if they define `<Type>.empty`,
   * `<Type>.prototype.empty` or implement the
   * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
   *
   * Dispatches to the `empty` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> a
   * @param {*} x
   * @return {*}
   * @example
   *
   *      R.empty(Just(42));               //=> Nothing()
   *      R.empty([1, 2, 3]);              //=> []
   *      R.empty('unicorns');             //=> ''
   *      R.empty({x: 1, y: 2});           //=> {}
   *      R.empty(Uint8Array.from('123')); //=> Uint8Array []
   */

  var empty =
  /*#__PURE__*/
  _curry1(function empty(x) {
    return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
      return arguments;
    }() : _isTypedArray(x) ? x.constructor.from('') : void 0 // else
    ;
  });

  /**
   * Returns a new list containing the last `n` elements of the given list.
   * If `n > list.length`, returns a list of `list.length` elements.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements to return.
   * @param {Array} xs The collection to consider.
   * @return {Array}
   * @see R.dropLast
   * @example
   *
   *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(3, 'ramda');               //=> 'mda'
   */

  var takeLast =
  /*#__PURE__*/
  _curry2(function takeLast(n, xs) {
    return drop$1(n >= 0 ? xs.length - n : 0, xs);
  });

  /**
   * Checks if a list ends with the provided sublist.
   *
   * Similarly, checks if a string ends with the provided substring.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> [a] -> Boolean
   * @sig String -> String -> Boolean
   * @param {*} suffix
   * @param {*} list
   * @return {Boolean}
   * @see R.startsWith
   * @example
   *
   *      R.endsWith('c', 'abc')                //=> true
   *      R.endsWith('b', 'abc')                //=> false
   *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
   *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
   */

  var endsWith =
  /*#__PURE__*/
  _curry2(function (suffix, list) {
    return equals(takeLast(suffix.length, list), suffix);
  });

  /**
   * Reports whether two objects have the same value, in [`R.equals`](#equals)
   * terms, for the specified property. Useful as a curried predicate.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig k -> {k: v} -> {k: v} -> Boolean
   * @param {String} prop The name of the property to compare
   * @param {Object} obj1
   * @param {Object} obj2
   * @return {Boolean}
   *
   * @example
   *
   *      const o1 = { a: 1, b: 2, c: 3, d: 4 };
   *      const o2 = { a: 10, b: 20, c: 3, d: 40 };
   *      R.eqProps('a', o1, o2); //=> false
   *      R.eqProps('c', o1, o2); //=> true
   */

  var eqProps =
  /*#__PURE__*/
  _curry3(function eqProps(prop, obj1, obj2) {
    return equals(obj1[prop], obj2[prop]);
  });

  /**
   * Creates a new object by recursively evolving a shallow copy of `object`,
   * according to the `transformation` functions. All non-primitive properties
   * are copied by reference.
   *
   * A `transformation` function will not be invoked if its corresponding key
   * does not exist in the evolved object.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {k: (v -> v)} -> {k: v} -> {k: v}
   * @param {Object} transformations The object specifying transformation functions to apply
   *        to the object.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const tomato = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
   *      const transformations = {
   *        firstName: R.trim,
   *        lastName: R.trim, // Will not get invoked.
   *        data: {elapsed: R.add(1), remaining: R.add(-1)}
   *      };
   *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
   */

  var evolve =
  /*#__PURE__*/
  _curry2(function evolve(transformations, object) {
    if (!_isObject(object) && !_isArray(object)) {
      return object;
    }

    var result = object instanceof Array ? [] : {};
    var transformation, key, type;

    for (key in object) {
      transformation = transformations[key];
      type = typeof transformation;
      result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
    }

    return result;
  });

  var XFind =
  /*#__PURE__*/
  function () {
    function XFind(f, xf) {
      this.xf = xf;
      this.f = f;
      this.found = false;
    }

    XFind.prototype['@@transducer/init'] = _xfBase.init;

    XFind.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, void 0);
      }

      return this.xf['@@transducer/result'](result);
    };

    XFind.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, input));
      }

      return result;
    };

    return XFind;
  }();

  function _xfind(f) {
    return function (xf) {
      return new XFind(f, xf);
    };
  }

  /**
   * Returns the first element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Dispatches to the `find` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   *        desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      const xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.find(R.propEq(2, 'a'))(xs); //=> {a: 2}
   *      R.find(R.propEq(4, 'a'))(xs); //=> undefined
   */

  var find$1 =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['find'], _xfind, function find(fn, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (fn(list[idx])) {
        return list[idx];
      }

      idx += 1;
    }
  }));

  var XFindIndex =
  /*#__PURE__*/
  function () {
    function XFindIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.found = false;
    }

    XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

    XFindIndex.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, -1);
      }

      return this.xf['@@transducer/result'](result);
    };

    XFindIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;

      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, this.idx));
      }

      return result;
    };

    return XFindIndex;
  }();

  function _xfindIndex(f) {
    return function (xf) {
      return new XFindIndex(f, xf);
    };
  }

  /**
   * Returns the index of the first element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce, R.indexOf
   * @example
   *
   *      const xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.findIndex(R.propEq(2, 'a'))(xs); //=> 1
   *      R.findIndex(R.propEq(4, 'a'))(xs); //=> -1
   */

  var findIndex =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindIndex, function findIndex(fn, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (fn(list[idx])) {
        return idx;
      }

      idx += 1;
    }

    return -1;
  }));

  var XFindLast =
  /*#__PURE__*/
  function () {
    function XFindLast(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XFindLast.prototype['@@transducer/init'] = _xfBase.init;

    XFindLast.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
    };

    XFindLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.last = input;
      }

      return result;
    };

    return XFindLast;
  }();

  function _xfindLast(f) {
    return function (xf) {
      return new XFindLast(f, xf);
    };
  }

  /**
   * Returns the last element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLast(R.propEq(1, 'a'))(xs); //=> {a: 1, b: 1}
   *      R.findLast(R.propEq(4, 'a'))(xs); //=> undefined
   */

  var findLast =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindLast, function findLast(fn, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      if (fn(list[idx])) {
        return list[idx];
      }

      idx -= 1;
    }
  }));

  var XFindLastIndex =
  /*#__PURE__*/
  function () {
    function XFindLastIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.lastIdx = -1;
    }

    XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;

    XFindLastIndex.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
    };

    XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;

      if (this.f(input)) {
        this.lastIdx = this.idx;
      }

      return result;
    };

    return XFindLastIndex;
  }();

  function _xfindLastIndex(f) {
    return function (xf) {
      return new XFindLastIndex(f, xf);
    };
  }

  /**
   * Returns the index of the last element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce, R.lastIndexOf
   * @example
   *
   *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLastIndex(R.propEq(1, 'a'))(xs); //=> 1
   *      R.findLastIndex(R.propEq(4, 'a'))(xs); //=> -1
   */

  var findLastIndex =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      if (fn(list[idx])) {
        return idx;
      }

      idx -= 1;
    }

    return -1;
  }));

  /**
   * Returns a new list by pulling every item out of it (and all its sub-arrays)
   * and putting them in a new array, depth-first.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b]
   * @param {Array} list The array to consider.
   * @return {Array} The flattened list.
   * @see R.unnest
   * @example
   *
   *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
   *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
   */

  var flatten =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _makeFlat(true));

  /**
   * Returns a new function much like the supplied one, except that the first two
   * arguments' order is reversed.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
   * @param {Function} fn The function to invoke with its first two parameters reversed.
   * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
   * @example
   *
   *      const mergeThree = (a, b, c) => [].concat(a, b, c);
   *
   *      mergeThree(1, 2, 3); //=> [1, 2, 3]
   *
   *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
   * @symb R.flip(f)(a, b, c) = f(b, a, c)
   */

  var flip =
  /*#__PURE__*/
  _curry1(function flip(fn) {
    return curryN(fn.length, function (a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });

  /**
   * Iterate over an input `list`, calling a provided function `fn` for each
   * element in the list.
   *
   * `fn` receives one argument: *(value)*.
   *
   * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.forEach` method. For more
   * details on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
   *
   * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
   * the original array. In some libraries this function is named `each`.
   *
   * Dispatches to the `forEach` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> *) -> [a] -> [a]
   * @param {Function} fn The function to invoke. Receives one argument, `value`.
   * @param {Array} list The list to iterate over.
   * @return {Array} The original list.
   * @see R.addIndex
   * @example
   *
   *      const printXPlusFive = x => console.log(x + 5);
   *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
   *      // logs 6
   *      // logs 7
   *      // logs 8
   * @symb R.forEach(f, [a, b, c]) = [a, b, c]
   */

  var forEach =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('forEach', function forEach(fn, list) {
    var len = list.length;
    var idx = 0;

    while (idx < len) {
      fn(list[idx]);
      idx += 1;
    }

    return list;
  }));

  /**
   * Iterate over an input `object`, calling a provided function `fn` for each
   * key and value in the object.
   *
   * `fn` receives three argument: *(value, key, obj)*.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Object
   * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
   * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
   * @param {Object} obj The object to iterate over.
   * @return {Object} The original object.
   * @example
   *
   *      const printKeyConcatValue = (value, key) => console.log(key + ':' + value);
   *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
   *      // logs x:1
   *      // logs y:2
   * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
   */

  var forEachObjIndexed =
  /*#__PURE__*/
  _curry2(function forEachObjIndexed(fn, obj) {
    var keyList = keys(obj);
    var idx = 0;

    while (idx < keyList.length) {
      var key = keyList[idx];
      fn(obj[key], key, obj);
      idx += 1;
    }

    return obj;
  });

  /**
   * Creates a new object from a list key-value pairs. If a key appears in
   * multiple pairs, the rightmost pair is included in the object.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [[k,v]] -> {k: v}
   * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
   * @return {Object} The object made by pairing up `keys` and `values`.
   * @see R.toPairs, R.pair
   * @example
   *
   *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
   */

  var fromPairs =
  /*#__PURE__*/
  _curry1(function fromPairs(pairs) {
    var result = {};
    var idx = 0;

    while (idx < pairs.length) {
      result[pairs[idx][0]] = pairs[idx][1];
      idx += 1;
    }

    return result;
  });

  /**
   * Splits a list into sub-lists stored in an object, based on the result of
   * calling a key-returning function on each element, and grouping the
   * results according to values returned.
   *
   * Dispatches to the `groupBy` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> {a: [b]}
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} list The array to group
   * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
   *         that produced that key when passed to `fn`.
   * @see R.reduceBy, R.transduce, R.indexBy, R.collectBy
   * @example
   *
   *      const byGrade = R.groupBy(function(student) {
   *        const score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      const students = [{name: 'Abby', score: 84},
   *                      {name: 'Eddy', score: 58},
   *                      // ...
   *                      {name: 'Jack', score: 69}];
   *      byGrade(students);
   *      // {
   *      //   'A': [{name: 'Dianne', score: 99}],
   *      //   'B': [{name: 'Abby', score: 84}]
   *      //   // ...,
   *      //   'F': [{name: 'Eddy', score: 58}]
   *      // }
   */

  var groupBy =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('groupBy',
  /*#__PURE__*/
  reduceBy(function (acc, item) {
    acc.push(item);
    return acc;
  }, [])));

  /**
   * Takes a list and returns a list of lists where each sublist's elements are
   * all satisfied pairwise comparison according to the provided function.
   * Only adjacent elements are passed to the comparison function.
   *
   * @func
   * @memberOf R
   * @since v0.21.0
   * @category List
   * @sig ((a, a)  Boolean)  [a]  [[a]]
   * @param {Function} fn Function for determining whether two given (adjacent)
   *        elements should be in the same group
   * @param {Array} list The array to group. Also accepts a string, which will be
   *        treated as a list of characters.
   * @return {List} A list that contains sublists of elements,
   *         whose concatenations are equal to the original list.
   * @example
   *
   * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
   *
   * const isVowel = R.test(/^[aeiou]$/i);
   * R.groupWith(R.eqBy(isVowel), 'aestiou')
   * //=> ['ae', 'st', 'iou']
   */

  var groupWith =
  /*#__PURE__*/
  _curry2(function (fn, list) {
    var res = [];
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      var nextidx = idx + 1;

      while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
        nextidx += 1;
      }

      res.push(list.slice(idx, nextidx));
      idx = nextidx;
    }

    return res;
  });

  /**
   * Returns `true` if the first argument is greater than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.lt
   * @example
   *
   *      R.gt(2, 1); //=> true
   *      R.gt(2, 2); //=> false
   *      R.gt(2, 3); //=> false
   *      R.gt('a', 'z'); //=> false
   *      R.gt('z', 'a'); //=> true
   */

  var gt =
  /*#__PURE__*/
  _curry2(function gt(a, b) {
    return a > b;
  });

  /**
   * Returns `true` if the first argument is greater than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.lte
   * @example
   *
   *      R.gte(2, 1); //=> true
   *      R.gte(2, 2); //=> true
   *      R.gte(2, 3); //=> false
   *      R.gte('a', 'z'); //=> false
   *      R.gte('z', 'a'); //=> true
   */

  var gte =
  /*#__PURE__*/
  _curry2(function gte(a, b) {
    return a >= b;
  });

  /**
   * Returns whether or not a path exists in an object. Only the object's
   * own properties are checked.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> Boolean
   * @param {Array} path The path to use.
   * @param {Object} obj The object to check the path in.
   * @return {Boolean} Whether the path exists.
   * @see R.has
   * @example
   *
   *      R.hasPath(['a', 'b'], {a: {b: 2}});         // => true
   *      R.hasPath(['a', 'b'], {a: {b: undefined}}); // => true
   *      R.hasPath(['a', 'b'], {a: {c: 2}});         // => false
   *      R.hasPath(['a', 'b'], {});                  // => false
   */

  var hasPath =
  /*#__PURE__*/
  _curry2(function hasPath(_path, obj) {
    if (_path.length === 0 || isNil(obj)) {
      return false;
    }

    var val = obj;
    var idx = 0;

    while (idx < _path.length) {
      if (!isNil(val) && _has(_path[idx], val)) {
        val = val[_path[idx]];
        idx += 1;
      } else {
        return false;
      }
    }

    return true;
  });

  /**
   * Returns whether or not an object has an own property with the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      const hasName = R.has('name');
   *      hasName({name: 'alice'});   //=> true
   *      hasName({name: 'bob'});     //=> true
   *      hasName({});                //=> false
   *
   *      const point = {x: 0, y: 0};
   *      const pointHas = R.has(R.__, point);
   *      pointHas('x');  //=> true
   *      pointHas('y');  //=> true
   *      pointHas('z');  //=> false
   */

  var has =
  /*#__PURE__*/
  _curry2(function has(prop, obj) {
    return hasPath([prop], obj);
  });

  /**
   * Returns whether or not an object or its prototype chain has a property with
   * the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      function Rectangle(width, height) {
   *        this.width = width;
   *        this.height = height;
   *      }
   *      Rectangle.prototype.area = function() {
   *        return this.width * this.height;
   *      };
   *
   *      const square = new Rectangle(2, 2);
   *      R.hasIn('width', square);  //=> true
   *      R.hasIn('area', square);  //=> true
   */

  var hasIn =
  /*#__PURE__*/
  _curry2(function hasIn(prop, obj) {
    if (isNil(obj)) {
      return false;
    }

    return prop in obj;
  });

  /**
   * Returns true if its arguments are identical, false otherwise. Values are
   * identical if they reference the same memory. `NaN` is identical to `NaN`;
   * `0` and `-0` are not identical.
   *
   * Note this is merely a curried version of ES6 `Object.is`.
   *
   * `identical` does not support the `__` placeholder.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      const o = {};
   *      R.identical(o, o); //=> true
   *      R.identical(1, 1); //=> true
   *      R.identical(1, '1'); //=> false
   *      R.identical([], []); //=> false
   *      R.identical(0, -0); //=> false
   *      R.identical(NaN, NaN); //=> true
   */

  var identical = function (a, b) {
    switch (arguments.length) {
      case 0:
        return identical;

      case 1:
        return function () {
          return function unaryIdentical(_b) {
            switch (arguments.length) {
              case 0:
                return unaryIdentical;

              default:
                return _objectIs$1(a, _b);
            }
          };
        }();

      default:
        return _objectIs$1(a, b);
    }
  }; // In order to support Cross-origin Window objects as arguments to identical,

  /**
   * Creates a function that will process either the `onTrue` or the `onFalse`
   * function depending upon the result of the `condition` predicate.
   *
   * Note that `ifElse` takes its arity from the longest of the three functions passed to it.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
   * @param {Function} condition A predicate function
   * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
   * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
   * @return {Function} A new function that will process either the `onTrue` or the `onFalse`
   *                    function depending upon the result of the `condition` predicate.
   * @see R.unless, R.when, R.cond
   * @example
   *
   *      const incCount = R.ifElse(
   *        R.has('count'),
   *        R.over(R.lensProp('count'), R.inc),
   *        R.assoc('count', 1)
   *      );
   *      incCount({ count: 1 }); //=> { count: 2 }
   *      incCount({});           //=> { count: 1 }
   */

  var ifElse =
  /*#__PURE__*/
  _curry3(function ifElse(condition, onTrue, onFalse) {
    return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });

  /**
   * Increments its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n + 1
   * @see R.dec
   * @example
   *
   *      R.inc(42); //=> 43
   */

  var inc =
  /*#__PURE__*/
  add(1);

  /**
   * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
   * terms, to at least one element of the given list; `false` otherwise.
   * Also works with strings.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category List
   * @sig a -> [a] -> Boolean
   * @param {Object} a The item to compare against.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
   * @see R.any
   * @example
   *
   *      R.includes(3, [1, 2, 3]); //=> true
   *      R.includes(4, [1, 2, 3]); //=> false
   *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
   *      R.includes([42], [[42]]); //=> true
   *      R.includes('ba', 'banana'); //=>true
   */

  var includes =
  /*#__PURE__*/
  _curry2(_includes);

  /**
   * Given a function that generates a key, turns a list of objects into an
   * object indexing the objects by the given key. Note that if multiple
   * objects generate the same value for the indexing key only the last value
   * will be included in the generated object.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> {a: b}
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} array The array of objects to index
   * @return {Object} An object indexing each array element by the given property.
   * @see R.groupBy
   * @example
   *
   *      const list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
   *      R.indexBy(R.prop('id'), list);
   *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
   */

  var indexBy =
  /*#__PURE__*/
  reduceBy(function (acc, elem) {
    return elem;
  }, null);

  /**
   * Returns the position of the first occurrence of an item in an array, or -1
   * if the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.lastIndexOf, R.findIndex
   * @example
   *
   *      R.indexOf(3, [1,2,3,4]); //=> 2
   *      R.indexOf(10, [1,2,3,4]); //=> -1
   */

  var indexOf =
  /*#__PURE__*/
  _curry2(function indexOf(target, xs) {
    return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
  });

  /**
   * Returns all but the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.last, R.head, R.tail
   * @example
   *
   *      R.init([1, 2, 3]);  //=> [1, 2]
   *      R.init([1, 2]);     //=> [1]
   *      R.init([1]);        //=> []
   *      R.init([]);         //=> []
   *
   *      R.init('abc');  //=> 'ab'
   *      R.init('ab');   //=> 'a'
   *      R.init('a');    //=> ''
   *      R.init('');     //=> ''
   */

  var init =
  /*#__PURE__*/
  slice(0, -1);

  /**
   * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
   * `xs'` comprising each of the elements of `xs` which is equal to one or more
   * elements of `ys` according to `pred`.
   *
   * `pred` must be a binary function expecting an element from each list.
   *
   * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
   * not be significant, but since `xs'` is ordered the implementation guarantees
   * that its values are in the same order as they appear in `xs`. Duplicates are
   * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Relation
   * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
   * @param {Function} pred
   * @param {Array} xs
   * @param {Array} ys
   * @return {Array}
   * @see R.intersection
   * @example
   *
   *      R.innerJoin(
   *        (record, id) => record.id === id,
   *        [{id: 824, name: 'Richie Furay'},
   *         {id: 956, name: 'Dewey Martin'},
   *         {id: 313, name: 'Bruce Palmer'},
   *         {id: 456, name: 'Stephen Stills'},
   *         {id: 177, name: 'Neil Young'}],
   *        [177, 456, 999]
   *      );
   *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
   */

  var innerJoin =
  /*#__PURE__*/
  _curry3(function innerJoin(pred, xs, ys) {
    return _filter(function (x) {
      return _includesWith(pred, x, ys);
    }, xs);
  });

  /**
   * Inserts the supplied element into the list, at the specified `index`. _Note that

   * this is not destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} index The position to insert the element
   * @param {*} elt The element to insert into the Array
   * @param {Array} list The list to insert into
   * @return {Array} A new Array with `elt` inserted at `index`.
   * @example
   *
   *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
   */

  var insert =
  /*#__PURE__*/
  _curry3(function insert(idx, elt, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    var result = Array.prototype.slice.call(list, 0);
    result.splice(idx, 0, elt);
    return result;
  });

  /**
   * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
   * destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig Number -> [a] -> [a] -> [a]
   * @param {Number} index The position to insert the sub-list
   * @param {Array} elts The sub-list to insert into the Array
   * @param {Array} list The list to insert the sub-list into
   * @return {Array} A new Array with `elts` inserted starting at `index`.
   * @example
   *
   *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
   */

  var insertAll =
  /*#__PURE__*/
  _curry3(function insertAll(idx, elts, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
  });

  var XUniqBy =
  /*#__PURE__*/
  function () {
    function XUniqBy(f, xf) {
      this.xf = xf;
      this.f = f;
      this.set = new _Set();
    }

    XUniqBy.prototype['@@transducer/init'] = _xfBase.init;
    XUniqBy.prototype['@@transducer/result'] = _xfBase.result;

    XUniqBy.prototype['@@transducer/step'] = function (result, input) {
      return this.set.add(this.f(input)) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XUniqBy;
  }();

  function _xuniqBy(f) {
    return function (xf) {
      return new XUniqBy(f, xf);
    };
  }

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied function to
   * each list element. Prefers the first item if the supplied function produces
   * the same value on two items. [`R.equals`](#equals) is used for comparison.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> b) -> [a] -> [a]
   * @param {Function} fn A function used to produce a value to use during comparisons.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
   */

  var uniqBy =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xuniqBy, function (fn, list) {
    var set = new _Set();
    var result = [];
    var idx = 0;
    var appliedItem, item;

    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);

      if (set.add(appliedItem)) {
        result.push(item);
      }

      idx += 1;
    }

    return result;
  }));

  /**
   * Returns a new list containing only one copy of each element in the original
   * list. [`R.equals`](#equals) is used to determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
   *      R.uniq([1, '1']);     //=> [1, '1']
   *      R.uniq([[42], [42]]); //=> [[42]]
   */

  var uniq =
  /*#__PURE__*/
  uniqBy(identity);

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of those
   * elements common to both lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The list of elements found in both `list1` and `list2`.
   * @see R.innerJoin
   * @example
   *
   *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
   */

  var intersection =
  /*#__PURE__*/
  _curry2(function intersection(list1, list2) {
    var toKeep = new _Set();

    for (var i = 0; i < list1.length; i += 1) {
      toKeep.add(list1[i]);
    }

    return uniq(_filter(toKeep.has.bind(toKeep), list2));
  });

  /**
   * Creates a new list with the separator interposed between elements.
   *
   * Dispatches to the `intersperse` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} separator The element to add to the list.
   * @param {Array} list The list to be interposed.
   * @return {Array} The new list.
   * @example
   *
   *      R.intersperse('a', ['b', 'n', 'n', 's']); //=> ['b', 'a', 'n', 'a', 'n', 'a', 's']
   */

  var intersperse =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('intersperse', function intersperse(separator, list) {
    var out = [];
    var idx = 0;
    var length = list.length;

    while (idx < length) {
      if (idx === length - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }

      idx += 1;
    }

    return out;
  }));

  function _objectAssign(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    var idx = 1;
    var length = arguments.length;

    while (idx < length) {
      var source = arguments[idx];

      if (source != null) {
        for (var nextKey in source) {
          if (_has(nextKey, source)) {
            output[nextKey] = source[nextKey];
          }
        }
      }

      idx += 1;
    }

    return output;
  }

  var _objectAssign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

  /**
   * Creates an object containing a single key:value pair.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @sig String -> a -> {String:a}
   * @param {String} key
   * @param {*} val
   * @return {Object}
   * @see R.pair
   * @example
   *
   *      const matchPhrases = R.compose(
   *        R.objOf('must'),
   *        R.map(R.objOf('match_phrase'))
   *      );
   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
   */

  var objOf =
  /*#__PURE__*/
  _curry2(function objOf(key, val) {
    var obj = {};
    obj[key] = val;
    return obj;
  });

  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function (xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function (a, b) {
      return a + b;
    },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function (result, input) {
      return _objectAssign$1(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
    },
    '@@transducer/result': _identity
  };
  function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }

    if (_isArrayLike(obj)) {
      return _stepCatArray;
    }

    if (typeof obj === 'string') {
      return _stepCatString;
    }

    if (typeof obj === 'object') {
      return _stepCatObject;
    }

    throw new Error('Cannot create transformer for ' + obj);
  }

  /**
   * Transforms the items of the list with the transducer and appends the
   * transformed items to the accumulator using an appropriate iterator function
   * based on the accumulator type.
   *
   * The accumulator can be an array, string, object or a transformer. Iterated
   * items will be appended to arrays and concatenated to strings. Objects will
   * be merged directly or 2-item arrays will be merged as key, value pairs.
   *
   * The accumulator can also be a transformer object that provides a 2-arity
   * reducing iterator function, step, 0-arity initial value function, init, and
   * 1-arity result extraction function result. The step function is used as the
   * iterator function in reduce. The result function is used to convert the
   * final accumulator into the return type and in most cases is R.identity. The
   * init function is used to provide the initial accumulator.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the
   * transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig a -> (b -> b) -> [c] -> a
   * @param {*} acc The initial accumulator value.
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.transduce
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.into([], transducer, numbers); //=> [2, 3]
   *
   *      const intoArray = R.into([]);
   *      intoArray(transducer, numbers); //=> [2, 3]
   */

  var into =
  /*#__PURE__*/
  _curry3(function into(acc, transducer, list) {
    var xf = transducer(_isTransformer(acc) ? acc : _stepCat(acc));
    return _xReduce(xf, xf['@@transducer/init'](), list);
  });

  /**
   * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
   * duplicate values by putting the values into an array.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: [ s, ... ]}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object with keys in an array.
   * @see R.invertObj
   * @example
   *
   *      const raceResultsByFirstName = {
   *        first: 'alice',
   *        second: 'jake',
   *        third: 'alice',
   *      };
   *      R.invert(raceResultsByFirstName);
   *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
   */

  var invert =
  /*#__PURE__*/
  _curry1(function invert(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      var val = obj[key];
      var list = _has(val, out) ? out[val] : out[val] = [];
      list[list.length] = key;
      idx += 1;
    }

    return out;
  });

  /**
   * Returns a new object with the keys of the given object as values, and the
   * values of the given object, which are coerced to strings, as keys. Note
   * that the last key found is preferred when handling the same value.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: s}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object
   * @see R.invert
   * @example
   *
   *      const raceResults = {
   *        first: 'alice',
   *        second: 'jake'
   *      };
   *      R.invertObj(raceResults);
   *      //=> { 'alice': 'first', 'jake':'second' }
   *
   *      // Alternatively:
   *      const raceResults = ['alice', 'jake'];
   *      R.invertObj(raceResults);
   *      //=> { 'alice': '0', 'jake':'1' }
   */

  var invertObj =
  /*#__PURE__*/
  _curry1(function invertObj(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      out[obj[key]] = key;
      idx += 1;
    }

    return out;
  });

  /**
   * Given an `arity` (Number) and a `name` (String) the `invoker` function
   * returns a curried function that takes `arity` arguments and a `context`
   * object. It will "invoke" the `name`'d function (a method) on the `context`
   * object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
   * @param {Number} arity Number of arguments the returned function should take
   *        before the target object.
   * @param {String} method Name of any of the target object's methods to call.
   * @return {Function} A new curried function.
   * @see R.construct
   * @example
   *      // A function with no arguments
   *      const asJson = invoker(0, "json")
   *      // Just like calling .then((response) => response.json())
   *      fetch("http://example.com/index.json").then(asJson)
   *
   *      // A function with one argument
   *      const sliceFrom = invoker(1, 'slice');
   *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
   *
   *      // A function with two arguments
   *      const sliceFrom6 = invoker(2, 'slice')(6);
   *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
   *
   *      // NOTE: You can't simply pass some of the arguments to the initial invoker function.
   *      const firstCreditCardSection = invoker(2, "slice", 0, 4)
   *      firstCreditCardSection("4242 4242 4242 4242") // => Function<...>
   *
   *      // Since invoker returns a curried function, you may partially apply it to create the function you need.
   *      const firstCreditCardSection = invoker(2, "slice")(0, 4)
   *      firstCreditCardSection("4242 4242 4242 4242") // => "4242"
   *
   * @symb R.invoker(0, 'method')(o) = o['method']()
   * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
   * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
   */

  var invoker =
  /*#__PURE__*/
  _curry2(function invoker(arity, method) {
    return curryN(arity + 1, function () {
      var target = arguments[arity];

      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }

      throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
    });
  });

  /**
   * See if an object (i.e. `val`) is an instance of the supplied constructor. This
   * function will check up the inheritance chain, if any.
   * If `val` was created using `Object.create`, `R.is(Object, val) === true`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Type
   * @sig (* -> {*}) -> a -> Boolean
   * @param {Object} ctor A constructor
   * @param {*} val The value to test
   * @return {Boolean}
   * @example
   *
   *      R.is(Object, {}); //=> true
   *      R.is(Number, 1); //=> true
   *      R.is(Object, 1); //=> false
   *      R.is(String, 's'); //=> true
   *      R.is(String, new String('')); //=> true
   *      R.is(Object, new String('')); //=> true
   *      R.is(Object, 's'); //=> false
   *      R.is(Number, {}); //=> false
   */

  var is =
  /*#__PURE__*/
  _curry2(function is(Ctor, val) {
    return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === 'Object' && typeof val === 'object');
  });

  /**
   * Returns `true` if the given value is its type's empty value; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty
   * @example
   *
   *      R.isEmpty([1, 2, 3]);           //=> false
   *      R.isEmpty([]);                  //=> true
   *      R.isEmpty('');                  //=> true
   *      R.isEmpty(null);                //=> false
   *      R.isEmpty({});                  //=> true
   *      R.isEmpty({length: 0});         //=> false
   *      R.isEmpty(Uint8Array.from('')); //=> true
   */

  var isEmpty =
  /*#__PURE__*/
  _curry1(function isEmpty(x) {
    return x != null && equals(x, empty(x));
  });

  /**
   * Checks if the input value is not `null` and not `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.29.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is not `undefined` or not `null`, otherwise `false`.
   * @example
   *
   *      R.isNotNil(null); //=> false
   *      R.isNotNil(undefined); //=> false
   *      R.isNotNil(0); //=> true
   *      R.isNotNil([]); //=> true
   */

  var isNotNil =
  /*#__PURE__*/
  _curry1(function isNotNil(x) {
    return !isNil(x);
  });

  /**
   * Returns a string made by inserting the `separator` between each element and
   * concatenating all the elements into a single string.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig String -> [a] -> String
   * @param {Number|String} separator The string used to separate the elements.
   * @param {Array} xs The elements to join into a string.
   * @return {String} str The string made by concatenating `xs` with `separator`.
   * @see R.split
   * @example
   *
   *      const spacer = R.join(' ');
   *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
   *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
   */

  var join =
  /*#__PURE__*/
  invoker(1, 'join');

  /**
   * juxt applies a list of functions to a list of values.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Function
   * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
   * @param {Array} fns An array of functions
   * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
   * @see R.applySpec
   * @example
   *
   *      const getRange = R.juxt([Math.min, Math.max]);
   *      getRange(3, 4, 9, -3); //=> [-3, 9]
   * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
   */

  var juxt =
  /*#__PURE__*/
  _curry1(function juxt(fns) {
    return converge(function () {
      return Array.prototype.slice.call(arguments, 0);
    }, fns);
  });

  /**
   * Returns a list containing the names of all the properties of the supplied
   * object, including prototype properties.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own and prototype properties.
   * @see R.keys, R.valuesIn
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.keysIn(f); //=> ['x', 'y']
   */

  var keysIn =
  /*#__PURE__*/
  _curry1(function keysIn(obj) {
    var prop;
    var ks = [];

    for (prop in obj) {
      ks[ks.length] = prop;
    }

    return ks;
  });

  /**
   * Returns the position of the last occurrence of an item in an array, or -1 if
   * the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.indexOf, R.findLastIndex
   * @example
   *
   *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
   *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
   */

  var lastIndexOf =
  /*#__PURE__*/
  _curry2(function lastIndexOf(target, xs) {
    if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
      return xs.lastIndexOf(target);
    } else {
      var idx = xs.length - 1;

      while (idx >= 0) {
        if (equals(xs[idx], target)) {
          return idx;
        }

        idx -= 1;
      }

      return -1;
    }
  });

  function _isNumber(x) {
    return Object.prototype.toString.call(x) === '[object Number]';
  }

  /**
   * Returns the number of elements in the array by returning `list.length`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [a] -> Number
   * @param {Array} list The array to inspect.
   * @return {Number} The length of the array.
   * @example
   *
   *      R.length([]); //=> 0
   *      R.length([1, 2, 3]); //=> 3
   */

  var length =
  /*#__PURE__*/
  _curry1(function length(list) {
    return list != null && _isNumber(list.length) ? list.length : NaN;
  });

  /**
   * Returns a lens for the given getter and setter functions. The getter "gets"
   * the value of the focus; the setter "sets" the value of the focus. The setter
   * should not mutate the data structure.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
   * @param {Function} getter
   * @param {Function} setter
   * @return {Lens}
   * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
   * @example
   *
   *      const xLens = R.lens(R.prop('x'), R.assoc('x'));
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */

  var lens =
  /*#__PURE__*/
  _curry2(function lens(getter, setter) {
    return function (toFunctorFn) {
      return function (target) {
        return map(function (focus) {
          return setter(focus, target);
        }, toFunctorFn(getter(target)));
      };
    };
  });

  /**
   * Returns a new copy of the array with the element at the provided index
   * replaced with the given value.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} idx The index to update.
   * @param {*} x The value to exist at the given index of the returned array.
   * @param {Array|Arguments} list The source array-like object to be updated.
   * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
   * @see R.adjust
   * @example
   *
   *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']
   *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']
   * @symb R.update(-1, a, [b, c]) = [b, a]
   * @symb R.update(0, a, [b, c]) = [a, c]
   * @symb R.update(1, a, [b, c]) = [b, a]
   */

  var update =
  /*#__PURE__*/
  _curry3(function update(idx, x, list) {
    return adjust(idx, always(x), list);
  });

  /**
   * Returns a lens whose focus is the specified index.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Number -> Lens s a
   * @param {Number} n
   * @return {Lens}
   * @see R.view, R.set, R.over, R.nth
   * @example
   *
   *      const headLens = R.lensIndex(0);
   *
   *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
   *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
   *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
   */

  var lensIndex =
  /*#__PURE__*/
  _curry1(function lensIndex(n) {
    return lens(nth(n), update(n));
  });

  /**
   * Retrieves the values at given paths of an object.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Object
   * @typedefn Idx = [String | Int | Symbol]
   * @sig [Idx] -> {a} -> [a | Undefined]
   * @param {Array} pathsArray The array of paths to be fetched.
   * @param {Object} obj The object to retrieve the nested properties from.
   * @return {Array} A list consisting of values at paths specified by "pathsArray".
   * @see R.path
   * @example
   *
   *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
   *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
   */

  var paths =
  /*#__PURE__*/
  _curry2(function paths(pathsArray, obj) {
    return pathsArray.map(function (paths) {
      var val = obj;
      var idx = 0;
      var p;

      while (idx < paths.length) {
        if (val == null) {
          return;
        }

        p = paths[idx];
        val = _isInteger(p) ? nth(p, val) : val[p];
        idx += 1;
      }

      return val;
    });
  });

  /**
   * Retrieves the value at a given path. The nodes of the path can be arbitrary strings or non-negative integers.
   * For anything else, the value is unspecified. Integer paths are meant to index arrays, strings are meant for objects.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> a | Undefined
   * @sig Idx = String | NonNegativeInt
   * @param {Array} path The path to use.
   * @param {Object} obj The object or array to retrieve the nested property from.
   * @return {*} The data at `path`.
   * @see R.prop, R.nth, R.assocPath, R.dissocPath
   * @example
   *
   *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
   *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
   *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
   *      R.path([2], {'2': 2}); //=> 2
   *      R.path([-2], {'-2': 'a'}); //=> undefined
   */

  var path =
  /*#__PURE__*/
  _curry2(function path(pathAr, obj) {
    return paths([pathAr], obj)[0];
  });

  /**
   * Returns a lens whose focus is the specified path.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig [Idx] -> Lens s a
   * @param {Array} path The path to use.
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      const xHeadYLens = R.lensPath(['x', 0, 'y']);
   *
   *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> 2
   *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
   *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
   */

  var lensPath =
  /*#__PURE__*/
  _curry1(function lensPath(p) {
    return lens(path(p), assocPath(p));
  });

  /**
   * Returns a lens whose focus is the specified property.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig String -> Lens s a
   * @param {String} k
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */

  var lensProp =
  /*#__PURE__*/
  _curry1(function lensProp(k) {
    return lens(prop(k), assoc(k));
  });

  /**
   * Returns `true` if the first argument is less than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.gt
   * @example
   *
   *      R.lt(2, 1); //=> false
   *      R.lt(2, 2); //=> false
   *      R.lt(2, 3); //=> true
   *      R.lt('a', 'z'); //=> true
   *      R.lt('z', 'a'); //=> false
   */

  var lt =
  /*#__PURE__*/
  _curry2(function lt(a, b) {
    return a < b;
  });

  /**
   * Returns `true` if the first argument is less than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.gte
   * @example
   *
   *      R.lte(2, 1); //=> false
   *      R.lte(2, 2); //=> true
   *      R.lte(2, 3); //=> true
   *      R.lte('a', 'z'); //=> true
   *      R.lte('z', 'a'); //=> false
   */

  var lte =
  /*#__PURE__*/
  _curry2(function lte(a, b) {
    return a <= b;
  });

  /**
   * The `mapAccum` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from left to right, and returning a final value of this
   * accumulator together with the new list.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.scan, R.addIndex, R.mapAccumRight
   * @example
   *
   *      const digits = ['1', '2', '3', '4'];
   *      const appender = (a, b) => [a + b, a + b];
   *
   *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
   * @symb R.mapAccum(f, a, [b, c, d]) = [
   *   f(f(f(a, b)[0], c)[0], d)[0],
   *   [
   *     f(a, b)[1],
   *     f(f(a, b)[0], c)[1],
   *     f(f(f(a, b)[0], c)[0], d)[1]
   *   ]
   * ]
   */

  var mapAccum =
  /*#__PURE__*/
  _curry3(function mapAccum(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var tuple = [acc];

    while (idx < len) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx += 1;
    }

    return [tuple[0], result];
  });

  /**
   * The `mapAccumRight` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from right to left, and returning a final value of this
   * accumulator together with the new list.
   *
   * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
   * the right to the left.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccum
   * @example
   *
   *      const digits = ['1', '2', '3', '4'];
   *      const appender = (a, b) => [b + a, b + a];
   *
   *      R.mapAccumRight(appender, 5, digits); //=> ['12345', ['12345', '2345', '345', '45']]
   * @symb R.mapAccumRight(f, a, [b, c, d]) = [
   *   f(f(f(a, d)[0], c)[0], b)[0],
   *   [
   *     f(a, d)[1],
   *     f(f(a, d)[0], c)[1],
   *     f(f(f(a, d)[0], c)[0], b)[1]
   *   ]
   * ]
   */

  var mapAccumRight =
  /*#__PURE__*/
  _curry3(function mapAccumRight(fn, acc, list) {
    var idx = list.length - 1;
    var result = [];
    var tuple = [acc];

    while (idx >= 0) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx -= 1;
    }

    return [tuple[0], result];
  });

  /**
   * An Object-specific version of [`map`](#map). The function is applied to three
   * arguments: *(value, key, obj)*. If only the value is significant, use
   * [`map`](#map) instead.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig ((*, String, Object) -> *) -> Object -> Object
   * @param {Function} fn
   * @param {Object} obj
   * @return {Object}
   * @see R.map
   * @example
   *
   *      const xyz = { x: 1, y: 2, z: 3 };
   *      const prependKeyAndDouble = (num, key, obj) => key + (num * 2);
   *
   *      R.mapObjIndexed(prependKeyAndDouble, xyz); //=> { x: 'x2', y: 'y4', z: 'z6' }
   */

  var mapObjIndexed =
  /*#__PURE__*/
  _curry2(function mapObjIndexed(fn, obj) {
    return _arrayReduce(function (acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys(obj));
  });

  /**
   * Tests a regular expression against a String. Note that this function will
   * return an empty array when there are no matches. This differs from
   * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
   * which returns `null` when there are no matches.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig RegExp -> String -> [String | Undefined]
   * @param {RegExp} rx A regular expression.
   * @param {String} str The string to match against
   * @return {Array} The list of matches or empty array.
   * @see R.test
   * @example
   *
   *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
   *      R.match(/a/, 'b'); //=> []
   *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
   */

  var match =
  /*#__PURE__*/
  _curry2(function match(rx, str) {
    return str.match(rx) || [];
  });

  /**
   * `mathMod` behaves like the modulo operator should mathematically, unlike the
   * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
   * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
   * arguments, and returns NaN when the modulus is zero or negative.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} m The dividend.
   * @param {Number} p the modulus.
   * @return {Number} The result of `b mod a`.
   * @see R.modulo
   * @example
   *
   *      R.mathMod(-17, 5);  //=> 3
   *      R.mathMod(17, 5);   //=> 2
   *      R.mathMod(17, -5);  //=> NaN
   *      R.mathMod(17, 0);   //=> NaN
   *      R.mathMod(17.2, 5); //=> NaN
   *      R.mathMod(17, 5.3); //=> NaN
   *
   *      const clock = R.mathMod(R.__, 12);
   *      clock(15); //=> 3
   *      clock(24); //=> 0
   *
   *      const seventeenMod = R.mathMod(17);
   *      seventeenMod(3);  //=> 2
   *      seventeenMod(4);  //=> 1
   *      seventeenMod(10); //=> 7
   */

  var mathMod =
  /*#__PURE__*/
  _curry2(function mathMod(m, p) {
    if (!_isInteger(m)) {
      return NaN;
    }

    if (!_isInteger(p) || p < 1) {
      return NaN;
    }

    return (m % p + p) % p;
  });

  /**
   * Takes a function and two values, and returns whichever value produces the
   * larger result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.max, R.minBy
   * @example
   *
   *      //  square :: Number -> Number
   *      const square = n => n * n;
   *
   *      R.maxBy(square, -3, 2); //=> -3
   *
   *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
   *      R.reduce(R.maxBy(square), 0, []); //=> 0
   */

  var maxBy =
  /*#__PURE__*/
  _curry3(function maxBy(f, a, b) {
    var resultB = f(b);
    return max(f(a), resultB) === resultB ? b : a;
  });

  /**
   * Adds together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The sum of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.sum([2,4,6,8,100,1]); //=> 121
   */

  var sum =
  /*#__PURE__*/
  reduce(add, 0);

  /**
   * Returns the mean of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.median
   * @example
   *
   *      R.mean([2, 7, 9]); //=> 6
   *      R.mean([]); //=> NaN
   */

  var mean =
  /*#__PURE__*/
  _curry1(function mean(list) {
    return sum(list) / list.length;
  });

  /**
   * Returns the median of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.mean
   * @example
   *
   *      R.median([2, 9, 7]); //=> 7
   *      R.median([7, 2, 10, 9]); //=> 8
   *      R.median([]); //=> NaN
   */

  var median =
  /*#__PURE__*/
  _curry1(function median(list) {
    var len = list.length;

    if (len === 0) {
      return NaN;
    }

    var width = 2 - len % 2;
    var idx = (len - width) / 2;
    return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }).slice(idx, idx + width));
  });

  /**
   * Takes a string-returning function `keyGen` and a function `fn` and returns
   * a new function that returns cached results for subsequent
   * calls with the same arguments.
   *
   * When the function is invoked, `keyGen` is applied to the same arguments
   * and its result becomes the cache key. If the cache contains something
   * under that key, the function simply returns it and does not invoke `fn` at all.
   *
   * Otherwise `fn` is applied to the same arguments and its return value
   * is cached under that key and returned by the function.
   *
   * Care must be taken when implementing `keyGen` to avoid key collision,
   * or if tracking references, memory leaks and mutating arguments.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
   * @param {Function} keyGen The function to generate the cache key.
   * @param {Function} fn The function to memoize.
   * @return {Function} Memoized version of `fn`.
   * @example
   *      const withAge = memoizeWith(o => `${o.birth}/${o.death}`, ({birth, death}) => {
   *      //                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^
   *      //                          keyGen                        fn
   *        console.log(`computing age for ${birth}/${death}`);
   *        return ({birth, death, age: death - birth});
   *      });
   *
   *      withAge({birth: 1921, death: 1999});
   *      //=> LOG: computing age for 1921/1999
   *      //=> {birth: 1921, death: 1999, age: 78} (returned from fn)
   *
   *      withAge({birth: 1921, death: 1999});
   *      //=> {birth: 1921, death: 1999, age: 78} (returned from cache)
   */

  var memoizeWith =
  /*#__PURE__*/
  _curry2(function memoizeWith(keyGen, fn) {
    var cache = {};
    return _arity(fn.length, function () {
      var key = keyGen.apply(this, arguments);

      if (!_has(key, cache)) {
        cache[key] = fn.apply(this, arguments);
      }

      return cache[key];
    });
  });

  /**
   * Creates one new object with the own properties from a list of objects.
   * If a key exists in more than one object, the value from the last
   * object it exists in will be used.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig [{k: v}] -> {k: v}
   * @param {Array} list An array of objects
   * @return {Object} A merged object.
   * @see R.reduce
   * @example
   *
   *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
   *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
   * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
   */

  var mergeAll =
  /*#__PURE__*/
  _curry1(function mergeAll(list) {
    return _objectAssign$1.apply(null, [{}].concat(list));
  });

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the key
   * and the values associated with the key in each object, with the result being
   * used as the value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWithKey, R.merge, R.mergeWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeWithKey(concatValues,
   *                     { a: true, thing: 'foo', values: [10, 20] },
   *                     { b: true, thing: 'bar', values: [15, 35] });
   *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
   * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
   */

  var mergeWithKey =
  /*#__PURE__*/
  _curry3(function mergeWithKey(fn, l, r) {
    var result = {};
    var k;
    l = l || {};
    r = r || {};

    for (k in l) {
      if (_has(k, l)) {
        result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
      }
    }

    for (k in r) {
      if (_has(k, r) && !_has(k, result)) {
        result[k] = r[k];
      }
    }

    return result;
  });

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to the key and associated values
   *   using the resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWithKey, R.mergeDeepWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeDeepWithKey(concatValues,
   *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
   *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
   *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
   */

  var mergeDeepWithKey =
  /*#__PURE__*/
  _curry3(function mergeDeepWithKey(fn, lObj, rObj) {
    return mergeWithKey(function (k, lVal, rVal) {
      if (_isObject(lVal) && _isObject(rVal)) {
        return mergeDeepWithKey(fn, lVal, rVal);
      } else {
        return fn(k, lVal, rVal);
      }
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the first object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                      { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
   */

  var mergeDeepLeft =
  /*#__PURE__*/
  _curry2(function mergeDeepLeft(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return lVal;
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                       { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
   */

  var mergeDeepRight =
  /*#__PURE__*/
  _curry2(function mergeDeepRight(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return rVal;
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to associated values using the
   *   resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepWith(R.concat,
   *                      { a: true, c: { values: [10, 20] }},
   *                      { b: true, c: { values: [15, 35] }});
   *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
   */

  var mergeDeepWith =
  /*#__PURE__*/
  _curry3(function mergeDeepWith(fn, lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return fn(lVal, rVal);
    }, lObj, rObj);
  });

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the first object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeRight, R.mergeDeepLeft, R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.mergeLeft({ 'age': 40 }, { 'name': 'fred', 'age': 10 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      const resetToDefault = R.mergeLeft({x: 0});
   *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
   * @symb R.mergeLeft(a, b) = {...b, ...a}
   */

  var mergeLeft =
  /*#__PURE__*/
  _curry2(function mergeLeft(l, r) {
    return _objectAssign$1({}, r, l);
  });

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeLeft, R.mergeDeepRight, R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.mergeRight({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      const withDefaults = R.mergeRight({x: 0, y: 0});
   *      withDefaults({y: 2}); //=> {x: 0, y: 2}
   * @symb R.mergeRight(a, b) = {...a, ...b}
   */

  var mergeRight =
  /*#__PURE__*/
  _curry2(function mergeRight(l, r) {
    return _objectAssign$1({}, l, r);
  });

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the values
   * associated with the key in each object, with the result being used as the
   * value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWith, R.merge, R.mergeWithKey
   * @example
   *
   *      R.mergeWith(R.concat,
   *                  { a: true, values: [10, 20] },
   *                  { b: true, values: [15, 35] });
   *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
   */

  var mergeWith =
  /*#__PURE__*/
  _curry3(function mergeWith(fn, l, r) {
    return mergeWithKey(function (_, _l, _r) {
      return fn(_l, _r);
    }, l, r);
  });

  /**
   * Returns the smaller of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.minBy, R.max
   * @example
   *
   *      R.min(789, 123); //=> 123
   *      R.min('a', 'b'); //=> 'a'
   */

  var min =
  /*#__PURE__*/
  _curry2(function min(a, b) {
    if (a === b) {
      return a;
    }

    function safeMin(x, y) {
      if (x < y !== y < x) {
        return y < x ? y : x;
      }

      return undefined;
    }

    var minByValue = safeMin(a, b);

    if (minByValue !== undefined) {
      return minByValue;
    }

    var minByType = safeMin(typeof a, typeof b);

    if (minByType !== undefined) {
      return minByType === typeof a ? a : b;
    }

    var stringA = toString(a);
    var minByStringValue = safeMin(stringA, toString(b));

    if (minByStringValue !== undefined) {
      return minByStringValue === stringA ? a : b;
    }

    return a;
  });

  /**
   * Takes a function and two values, and returns whichever value produces the
   * smaller result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.min, R.maxBy
   * @example
   *
   *      //  square :: Number -> Number
   *      const square = n => n * n;
   *
   *      R.minBy(square, -3, 2); //=> 2
   *
   *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
   *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
   */

  var minBy =
  /*#__PURE__*/
  _curry3(function minBy(f, a, b) {
    var resultB = f(b);
    return min(f(a), resultB) === resultB ? b : a;
  });

  /**
   * Makes a shallow clone of an object, applying the given fn to the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @private
   * @param {String|Number} prop The property name to set
   * @param {Function} fn The function to apply to the property
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original except for the changed property.
   */

  function _modify(prop, fn, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop] = fn(arr[prop]);
      return arr;
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    result[prop] = fn(result[prop]);
    return result;
  }

  /**
   * Creates a shallow clone of the passed object by applying an `fn` function
   * to the value at the given path.
   *
   * The function will not be invoked, and the object will not change
   * if its corresponding path does not exist in the object.
   * All non-primitive properties are copied to the new object by reference.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig [Idx] -> (v -> v) -> {k: v} -> {k: v}
   * @param {Array} path The path to be modified.
   * @param {Function} fn The function to apply to the path.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const person = {name: 'James', address: { zipCode: '90216' }};
   *      R.modifyPath(['address', 'zipCode'], R.reverse, person); //=> {name: 'James', address: { zipCode: '61209' }}
   *
   *      // Can handle arrays too
   *      const person = {name: 'James', addresses: [{ zipCode: '90216' }]};
   *      R.modifyPath(['addresses', 0, 'zipCode'], R.reverse, person); //=> {name: 'James', addresses: [{ zipCode: '61209' }]}
   */

  var modifyPath =
  /*#__PURE__*/
  _curry3(function modifyPath(path, fn, object) {
    if (!_isObject(object) && !_isArray(object)) {
      return object;
    }

    if (path.length === 0) {
      return fn(object);
    }

    var idx = path[0];

    if (!_has(idx, object)) {
      return object;
    }

    if (path.length === 1) {
      return _modify(idx, fn, object);
    }

    var val = modifyPath(Array.prototype.slice.call(path, 1), fn, object[idx]);

    if (val === object[idx]) {
      return object;
    }

    return _assoc(idx, val, object);
  });

  /**
   * Creates a copy of the passed object by applying an `fn` function to the given `prop` property.
   *
   * The function will not be invoked, and the object will not change
   * if its corresponding property does not exist in the object.
   * All non-primitive properties are copied to the new object by reference.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig Idx -> (v -> v) -> {k: v} -> {k: v}
   * @param {String|Number} prop The property to be modified.
   * @param {Function} fn The function to apply to the property.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const person = {name: 'James', age: 20, pets: ['dog', 'cat']};
   *      R.modify('age', R.add(1), person); //=> {name: 'James', age: 21, pets: ['dog', 'cat']}
   *      R.modify('pets', R.append('turtle'), person); //=> {name: 'James', age: 20, pets: ['dog', 'cat', 'turtle']}
   */

  var modify =
  /*#__PURE__*/
  _curry3(function modify(prop, fn, object) {
    return modifyPath([prop], fn, object);
  });

  /**
   * Divides the first parameter by the second and returns the remainder. Note
   * that this function preserves the JavaScript-style behavior for modulo. For
   * mathematical modulo see [`mathMod`](#mathMod).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The value to the divide.
   * @param {Number} b The pseudo-modulus
   * @return {Number} The result of `b % a`.
   * @see R.mathMod
   * @example
   *
   *      R.modulo(17, 3); //=> 2
   *      // JS behavior:
   *      R.modulo(-17, 3); //=> -2
   *      R.modulo(17, -3); //=> 2
   *
   *      const isOdd = R.modulo(R.__, 2);
   *      isOdd(42); //=> 0
   *      isOdd(21); //=> 1
   */

  var modulo =
  /*#__PURE__*/
  _curry2(function modulo(a, b) {
    return a % b;
  });

  /**
   * Move an item, at index `from`, to index `to`, in a list of elements.
   * A new list will be created containing the new elements order.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} from The source index
   * @param {Number} to The destination index
   * @param {Array} list The list which will serve to realise the move
   * @return {Array} The new list reordered
   * @example
   *
   *      R.move(0, 2, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['b', 'c', 'a', 'd', 'e', 'f']
   *      R.move(-1, 0, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['f', 'a', 'b', 'c', 'd', 'e'] list rotation
   */

  var move =
  /*#__PURE__*/
  _curry3(function (from, to, list) {
    var length = list.length;
    var result = list.slice();
    var positiveFrom = from < 0 ? length + from : from;
    var positiveTo = to < 0 ? length + to : to;
    var item = result.splice(positiveFrom, 1);
    return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
  });

  /**
   * Multiplies two numbers. Equivalent to `a * b` but curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a * b`.
   * @see R.divide
   * @example
   *
   *      const double = R.multiply(2);
   *      const triple = R.multiply(3);
   *      double(3);       //=>  6
   *      triple(4);       //=> 12
   *      R.multiply(2, 5);  //=> 10
   */

  var multiply =
  /*#__PURE__*/
  _curry2(function multiply(a, b) {
    return a * b;
  });

  /**
   * Takes a function `f` and an object, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the object
   * provided initially merged deeply (right) with the object provided as an argument to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig (({ a, b, c, ..., n }) -> x) -> { a, b, c, ...} -> ({ d, e, f, ..., n } -> x)
   * @param {Function} f
   * @param {Object} props
   * @return {Function}
   * @see R.partial, R.partialRight, R.curry, R.mergeDeepRight
   * @example
   *
   *      const multiply2 = ({ a, b }) => a * b;
   *      const double = R.partialObject(multiply2, { a: 2 });
   *      double({ b: 2 }); //=> 4
   *
   *      const greet = ({ salutation, title, firstName, lastName }) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const sayHello = R.partialObject(greet, { salutation: 'Hello' });
   *      const sayHelloToMs = R.partialObject(sayHello, { title: 'Ms.' });
   *      sayHelloToMs({ firstName: 'Jane', lastName: 'Jones' }); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialObject(f, { a, b })({ c, d }) = f({ a, b, c, d })
   */

  var partialObject =
  /*#__PURE__*/
  _curry2((f, o) => props => f.call(undefined, mergeDeepRight(o, props)));

  /**
   * Negates its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number}
   * @example
   *
   *      R.negate(42); //=> -42
   */

  var negate =
  /*#__PURE__*/
  _curry1(function negate(n) {
    return -n;
  });

  /**
   * Returns `true` if no elements of the list match the predicate, `false`
   * otherwise.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
   * @see R.all, R.any
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *      const isOdd = n => n % 2 !== 0;
   *
   *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
   *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
   */

  var none =
  /*#__PURE__*/
  _curry2(function none(fn, input) {
    return all(_complement(fn), input);
  });

  /**
   * Returns a function which returns its nth argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig Number -> *... -> *
   * @param {Number} n
   * @return {Function}
   * @example
   *
   *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
   *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
   * @symb R.nthArg(-1)(a, b, c) = c
   * @symb R.nthArg(0)(a, b, c) = a
   * @symb R.nthArg(1)(a, b, c) = b
   */

  var nthArg =
  /*#__PURE__*/
  _curry1(function nthArg(n) {
    var arity = n < 0 ? 1 : n + 1;
    return curryN(arity, function () {
      return nth(n, arguments);
    });
  });

  /**
   * `o` is a curried composition function that returns a unary function.
   * Like [`compose`](#compose), `o` performs right-to-left function composition.
   * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
   * invoked with only one argument. Also, unlike [`compose`](#compose), `o` is
   * limited to accepting only 2 unary functions. The name o was chosen because
   * of its similarity to the mathematical composition operator .
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (b -> c) -> (a -> b) -> a -> c
   * @param {Function} f
   * @param {Function} g
   * @return {Function}
   * @see R.compose, R.pipe
   * @example
   *
   *      const classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
   *      const yellGreeting = R.o(R.toUpper, classyGreeting);
   *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
   *
   * @symb R.o(f, g, x) = f(g(x))
   */

  var o =
  /*#__PURE__*/
  _curry3(function o(f, g, x) {
    return f(g(x));
  });

  /**
   * Given a constructor and a value, returns a new instance of that constructor
   * containing the value.
   *
   * Dispatches to the `fantasy-land/of` method of the constructor first (if present)
   * or to the `of` method last (if present). When neither are present, wraps the
   * value in an array.
   *
   * Note this `of` is different from the ES6 `of`; See
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig (* -> {*}) -> a -> {a}
   * @param {Object} Ctor A constructor
   * @param {*} val any value
   * @return {*} An instance of the `Ctor` wrapping `val`.
   * @example
   *
   *      R.of(Array, 42);   //=> [42]
   *      R.of(Array, [42]); //=> [[42]]
   *      R.of(Maybe, 42);   //=> Maybe.Just(42)
   */

  var of =
  /*#__PURE__*/
  _curry2(function of(Ctor, val) {
    return typeof Ctor['fantasy-land/of'] === 'function' ? Ctor['fantasy-land/of'](val) : typeof Ctor.of === 'function' ? Ctor.of(val) : [val];
  });

  /**
   * Returns a partial copy of an object omitting the keys specified.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [String] -> {String: *} -> {String: *}
   * @param {Array} names an array of String property names to omit from the new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with properties from `names` not on it.
   * @see R.pick
   * @example
   *
   *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
   */

  var omit =
  /*#__PURE__*/
  _curry2(function omit(names, obj) {
    var result = {};
    var index = {};
    var idx = 0;
    var len = names.length;

    while (idx < len) {
      index[names[idx]] = 1;
      idx += 1;
    }

    for (var prop in obj) {
      if (!index.hasOwnProperty(prop)) {
        result[prop] = obj[prop];
      }
    }

    return result;
  });

  /**
   * Takes a binary function `f`, a unary function `g`, and two values.
   * Applies `g` to each value, then applies the result of each to `f`.
   *
   * Also known as the P combinator.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig ((a, a) -> b) -> (c -> a) -> c -> c -> b
   * @param {Function} f a binary function
   * @param {Function} g a unary function
   * @param {any} a any value
   * @param {any} b any value
   * @return {any} The result of `f`
   * @example
   *
   *      const eqBy = R.on((a, b) => a === b);
   *      eqBy(R.prop('a'), {b:0, a:1}, {a:1}) //=> true;
   *
   *      const containsInsensitive = R.on(R.includes, R.toLower);
   *      containsInsensitive('o', 'FOO'); //=> true
   * @symb R.on(f, g, a, b) = f(g(a), g(b))
   */

  var on$1 =
  /*#__PURE__*/
  _curryN(4, [], function on(f, g, a, b) {
    return f(g(a), g(b));
  });

  /**
   * Accepts a function `fn` and returns a function that guards invocation of
   * `fn` such that `fn` can only ever be called once, no matter how many times
   * the returned function is invoked. The first value calculated is returned in
   * subsequent invocations.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a... -> b) -> (a... -> b)
   * @param {Function} fn The function to wrap in a call-only-once wrapper.
   * @return {Function} The wrapped function.
   * @example
   *
   *      const addOneOnce = R.once(x => x + 1);
   *      addOneOnce(10); //=> 11
   *      addOneOnce(addOneOnce(50)); //=> 11
   */

  var once =
  /*#__PURE__*/
  _curry1(function once(fn) {
    var called = false;
    var result;
    return _arity(fn.length, function () {
      if (called) {
        return result;
      }

      called = true;
      result = fn.apply(this, arguments);
      return result;
    });
  });

  function _assertPromise(name, p) {
    if (p == null || !_isFunction(p.then)) {
      throw new TypeError('`' + name + '` expected a Promise, received ' + _toString(p, []));
    }
  }

  /**
   * Returns the result of applying the onFailure function to the value inside
   * a failed promise. This is useful for handling rejected promises
   * inside function compositions.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig (e -> b) -> (Promise e a) -> (Promise e b)
   * @sig (e -> (Promise f b)) -> (Promise e a) -> (Promise f b)
   * @param {Function} onFailure The function to apply. Can return a value or a promise of a value.
   * @param {Promise} p
   * @return {Promise} The result of calling `p.then(null, onFailure)`
   * @see R.andThen
   * @example
   *
   *      const failedFetch = id => Promise.reject('bad ID');
   *      const useDefault = () => ({ firstName: 'Bob', lastName: 'Loblaw' });
   *
   *      //recoverFromFailure :: String -> Promise ({ firstName, lastName })
   *      const recoverFromFailure = R.pipe(
   *        failedFetch,
   *        R.otherwise(useDefault),
   *        R.andThen(R.pick(['firstName', 'lastName'])),
   *      );
   *      recoverFromFailure(12345).then(console.log);
   */

  var otherwise =
  /*#__PURE__*/
  _curry2(function otherwise(f, p) {
    _assertPromise('otherwise', p);

    return p.then(null, f);
  });

  // transforms the held value with the provided function.

  var Identity = function (x) {
    return {
      value: x,
      map: function (f) {
        return Identity(f(x));
      }
    };
  };
  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the result of applying the given function to
   * the focused value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> (a -> a) -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.view, R.set, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const headLens = R.lensIndex(0);
   *
   *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
   */


  var over =
  /*#__PURE__*/
  _curry3(function over(lens, f, x) {
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    return lens(function (y) {
      return Identity(f(y));
    })(x).value;
  });

  /**
   * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category List
   * @sig a -> b -> (a,b)
   * @param {*} fst
   * @param {*} snd
   * @return {Array}
   * @see R.objOf, R.of
   * @example
   *
   *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
   */

  var pair =
  /*#__PURE__*/
  _curry2(function pair(fst, snd) {
    return [fst, snd];
  });

  function _createPartialApplicator(concat) {
    return _curry2(function (fn, args) {
      return _arity(Math.max(0, fn.length - args.length), function () {
        return fn.apply(this, concat(args, arguments));
      });
    });
  }

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided initially followed by the arguments provided to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partialRight, R.curry
   * @example
   *
   *      const multiply2 = (a, b) => a * b;
   *      const double = R.partial(multiply2, [2]);
   *      double(3); //=> 6
   *
   *      const greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const sayHello = R.partial(greet, ['Hello']);
   *      const sayHelloToMs = R.partial(sayHello, ['Ms.']);
   *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
   */

  var partial =
  /*#__PURE__*/
  _createPartialApplicator(_concat);

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided to `g` followed by the arguments provided initially.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partial
   * @example
   *
   *      const greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
   *
   *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
   */

  var partialRight =
  /*#__PURE__*/
  _createPartialApplicator(
  /*#__PURE__*/
  flip(_concat));

  /**
   * Takes a predicate and a list or other `Filterable` object and returns the
   * pair of filterable objects of the same type of elements which do and do not
   * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
   * @param {Function} pred A predicate to determine which side the element belongs to.
   * @param {Array} filterable the list (or other filterable) to partition.
   * @return {Array} An array, containing first the subset of elements that satisfy the
   *         predicate, and second the subset of elements that do not satisfy.
   * @see R.filter, R.reject
   * @example
   *
   *      R.partition(R.includes('s'), ['sss', 'ttt', 'foo', 'bars']);
   *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
   *
   *      R.partition(R.includes('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
   *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
   */

  var partition =
  /*#__PURE__*/
  juxt([filter, reject]);

  /**
   * Determines whether a nested path on an object has a specific value, in
   * [`R.equals`](#equals) terms. Most likely used to filter a list.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Relation
   * @typedefn Idx = String | Int | Symbol
   * @sig a -> [Idx] -> {a} -> Boolean
   * @param {*} val The value to compare the nested property with
   * @param {Array} path The path of the nested property to use
   * @param {Object} obj The object to check the nested property in
   * @return {Boolean} `true` if the value equals the nested object property,
   *         `false` otherwise.
   * @see R.whereEq, R.propEq, R.pathSatisfies, R.equals
   * @example
   *
   *      const user1 = { address: { zipCode: 90210 } };
   *      const user2 = { address: { zipCode: 55555 } };
   *      const user3 = { name: 'Bob' };
   *      const users = [ user1, user2, user3 ];
   *      const isFamous = R.pathEq(90210, ['address', 'zipCode']);
   *      R.filter(isFamous, users); //=> [ user1 ]
   */

  var pathEq =
  /*#__PURE__*/
  _curry3(function pathEq(val, _path, obj) {
    return equals(path(_path, obj), val);
  });

  /**
   * If the given, non-null object has a value at the given path, returns the
   * value at that path. Otherwise returns the provided default value.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig a -> [Idx] -> {a} -> a
   * @param {*} d The default value.
   * @param {Array} p The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path` of the supplied object or the default value.
   * @example
   *
   *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
   */

  var pathOr =
  /*#__PURE__*/
  _curry3(function pathOr(d, p, obj) {
    return defaultTo(d, path(p, obj));
  });

  /**
   * Returns `true` if the specified object property at given path satisfies the
   * given predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Logic
   * @typedefn Idx = String | Int | Symbol
   * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
   * @param {Function} pred
   * @param {Array} propPath
   * @param {*} obj
   * @return {Boolean}
   * @see R.propSatisfies, R.path
   * @example
   *
   *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
   *      R.pathSatisfies(R.is(Object), [], {x: {y: 2}}); //=> true
   */

  var pathSatisfies =
  /*#__PURE__*/
  _curry3(function pathSatisfies(pred, propPath, obj) {
    return pred(path(propPath, obj));
  });

  /**
   * Returns a partial copy of an object containing only the keys specified. If
   * the key does not exist, the property is ignored.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.omit, R.props
   * @example
   *
   *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
   */

  var pick =
  /*#__PURE__*/
  _curry2(function pick(names, obj) {
    var result = {};
    var idx = 0;

    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }

      idx += 1;
    }

    return result;
  });

  /**
   * Similar to `pick` except that this one includes a `key: undefined` pair for
   * properties that don't exist.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.pick
   * @example
   *
   *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
   */

  var pickAll =
  /*#__PURE__*/
  _curry2(function pickAll(names, obj) {
    var result = {};
    var idx = 0;
    var len = names.length;

    while (idx < len) {
      var name = names[idx];
      result[name] = obj[name];
      idx += 1;
    }

    return result;
  });

  /**
   * Returns a partial copy of an object containing only the keys that satisfy
   * the supplied predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
   * @param {Function} pred A predicate to determine whether or not a key
   *        should be included on the output object.
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties that satisfy `pred`
   *         on it.
   * @see R.pick, R.filter
   * @example
   *
   *      const isUpperCase = (val, key) => key.toUpperCase() === key;
   *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
   */

  var pickBy =
  /*#__PURE__*/
  _curry2(function pickBy(test, obj) {
    var result = {};

    for (var prop in obj) {
      if (test(obj[prop], prop, obj)) {
        result[prop] = obj[prop];
      }
    }

    return result;
  });

  /**
   * Returns a new list with the given element at the front, followed by the
   * contents of the list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The item to add to the head of the output list.
   * @param {Array} list The array to add to the tail of the output list.
   * @return {Array} A new array.
   * @see R.append
   * @example
   *
   *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
   */

  var prepend =
  /*#__PURE__*/
  _curry2(function prepend(el, list) {
    return _concat([el], list);
  });

  /**
   * Multiplies together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The product of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.product([2,4,6,8,100,1]); //=> 38400
   */

  var product =
  /*#__PURE__*/
  reduce(multiply, 1);

  /**
   * Accepts a function `fn` and a list of transformer functions and returns a
   * new curried function. When the new function is invoked, it calls the
   * function `fn` with parameters consisting of the result of calling each
   * supplied handler on successive arguments to the new function.
   *
   * If more arguments are passed to the returned function than transformer
   * functions, those arguments are passed directly to `fn` as additional
   * parameters. If you expect additional arguments that don't need to be
   * transformed, although you can ignore them, it's best to pass an identity
   * function so that the new function reports the correct arity.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} fn The function to wrap.
   * @param {Array} transformers A list of transformer functions
   * @return {Function} The wrapped function.
   * @see R.converge
   * @example
   *
   *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
   *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
   *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
   *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
   * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
   */

  var useWith =
  /*#__PURE__*/
  _curry2(function useWith(fn, transformers) {
    return curryN(transformers.length, function () {
      var args = [];
      var idx = 0;

      while (idx < transformers.length) {
        args.push(transformers[idx].call(this, arguments[idx]));
        idx += 1;
      }

      return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
    });
  });

  /**
   * Reasonable analog to SQL `select` statement.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @category Relation
   * @sig [k] -> [{k: v}] -> [{k: v}]
   * @param {Array} props The property names to project
   * @param {Array} objs The objects to query
   * @return {Array} An array of objects with just the `props` properties.
   * @see R.pluck, R.props, R.prop
   * @example
   *
   *      const abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
   *      const fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
   *      const kids = [abby, fred];
   *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
   */

  var project =
  /*#__PURE__*/
  useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity

  function _promap(f, g, profunctor) {
    return function (x) {
      return g(profunctor(f(x)));
    };
  }

  var XPromap =
  /*#__PURE__*/
  function () {
    function XPromap(f, g, xf) {
      this.xf = xf;
      this.f = f;
      this.g = g;
    }

    XPromap.prototype['@@transducer/init'] = _xfBase.init;
    XPromap.prototype['@@transducer/result'] = _xfBase.result;

    XPromap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, _promap(this.f, this.g, input));
    };

    return XPromap;
  }();

  function _xpromap(f, g) {
    return function (xf) {
      return new XPromap(f, g, xf);
    };
  }

  /**
   * Takes two functions as pre- and post- processors respectively for a third function,
   * i.e. `promap(f, g, h)(x) === g(h(f(x)))`.
   *
   * Dispatches to the `promap` method of the third argument, if present,
   * according to the [FantasyLand Profunctor spec](https://github.com/fantasyland/fantasy-land#profunctor).
   *
   * Acts as a transducer if a transformer is given in profunctor position.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
   * @sig Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
   * @param {Function} f The preprocessor function, a -> b
   * @param {Function} g The postprocessor function, c -> d
   * @param {Profunctor} profunctor The profunctor instance to be promapped, e.g. b -> c
   * @return {Profunctor} The new profunctor instance, e.g. a -> d
   * @see R.transduce
   * @example
   *
   *      const decodeChar = R.promap(s => s.charCodeAt(), String.fromCharCode, R.add(-8))
   *      const decodeString = R.promap(R.split(''), R.join(''), R.map(decodeChar))
   *      decodeString("ziuli") //=> "ramda"
   *
   * @symb R.promap(f, g, h) = x => g(h(f(x)))
   * @symb R.promap(f, g, profunctor) = profunctor.promap(f, g)
   */

  var promap =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/promap', 'promap'], _xpromap, _promap));

  /**
   * Returns `true` if the specified object property is equal, in
   * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
   * You can test multiple properties with [`R.whereEq`](#whereEq),
   * and test nested path property with [`R.pathEq`](#pathEq).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig a -> String -> Object -> Boolean
   * @param {*} val The value to compare the property with
   * @param {String} name the specified object property's key
   * @param {*} obj The object to check the property in
   * @return {Boolean} `true` if the value equals the specified object property,
   *         `false` otherwise.
   * @see R.whereEq, R.pathEq, R.propSatisfies, R.equals
   * @example
   *
   *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
   *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
   *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
   *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
   *      const kids = [abby, fred, rusty, alois];
   *      const hasBrownHair = R.propEq('brown', 'hair');
   *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
   */

  var propEq =
  /*#__PURE__*/
  _curry3(function propEq(val, name, obj) {
    return equals(val, prop(name, obj));
  });

  /**
   * Returns `true` if the specified object property is of the given type;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Type
   * @sig Type -> String -> Object -> Boolean
   * @param {Function} type
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.is, R.propSatisfies
   * @example
   *
   *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
   *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
   *      R.propIs(Number, 'x', {});            //=> false
   */

  var propIs =
  /*#__PURE__*/
  _curry3(function propIs(type, name, obj) {
    return is(type, prop(name, obj));
  });

  /**
   * Return the specified property of the given non-null object if the property
   * is present and it's value is not `null`, `undefined` or `NaN`.
   *
   * Otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Object
   * @sig a -> String -> Object -> a
   * @param {*} val The default value.
   * @param {String} p The name of the property to return.
   * @param {Object} obj The object to query.
   * @return {*} The value of given property of the supplied object or the default value.
   * @example
   *
   *      const alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      const favorite = R.prop('favoriteLibrary');
   *      const favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
   *
   *      favorite(alice);  //=> undefined
   *      favoriteWithDefault(alice);  //=> 'Ramda'
   */

  var propOr =
  /*#__PURE__*/
  _curry3(function propOr(val, p, obj) {
    return defaultTo(val, prop(p, obj));
  });

  /**
   * Returns `true` if the specified object property satisfies the given
   * predicate; `false` otherwise. You can test multiple properties with
   * [`R.where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Logic
   * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
   * @param {Function} pred
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.where, R.propEq, R.propIs
   * @example
   *
   *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
   */

  var propSatisfies =
  /*#__PURE__*/
  _curry3(function propSatisfies(pred, name, obj) {
    return pred(prop(name, obj));
  });

  /**
   * Acts as multiple `prop`: array of keys in, array of values out. Preserves
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> [v]
   * @param {Array} ps The property names to fetch
   * @param {Object} obj The object to query
   * @return {Array} The corresponding values or partially applied function.
   * @see R.prop, R.pluck, R.project
   * @example
   *
   *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
   *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
   *
   *      const fullName = R.compose(R.join(' '), R.props(['first', 'last']));
   *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
   */

  var props =
  /*#__PURE__*/
  _curry2(function props(ps, obj) {
    return ps.map(function (p) {
      return path([p], obj);
    });
  });

  /**
   * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> Number -> [Number]
   * @param {Number} from The first number in the list.
   * @param {Number} to One more than the last number in the list.
   * @return {Array} The list of numbers in the set `[a, b)`.
   * @example
   *
   *      R.range(1, 5);    //=> [1, 2, 3, 4]
   *      R.range(50, 53);  //=> [50, 51, 52]
   */

  var range =
  /*#__PURE__*/
  _curry2(function range(from, to) {
    if (!(_isNumber(from) && _isNumber(to))) {
      throw new TypeError('Both arguments to range must be numbers');
    }

    var result = [];
    var n = from;

    while (n < to) {
      result.push(n);
      n += 1;
    }

    return result;
  });

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * Similar to [`reduce`](#reduce), except moves through the input list from the
   * right to the left.
   *
   * The iterator function receives two values: *(value, acc)*, while the arguments'
   * order of `reduce`'s iterator function is *(acc, value)*. `reduceRight` may use [`reduced`](#reduced)
   * to short circuit the iteration.
   *
   * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
   *
   * Be cautious of mutating and returning the accumulator. If you reuse it across
   * invocations, it will continue to accumulate onto the same value. The general
   * recommendation is to always return a new value. If you can't do so for
   * performance reasons, then be sure to reinitialize the accumulator on each
   * invocation.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> b) -> b -> [a] -> b
   * @param {Function} fn The iterator function. Receives two values, the current element from the array
   *        and the accumulator.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.addIndex, R.reduced
   * @example
   *
   *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
   *      //    -               -2
   *      //   / \              / \
   *      //  1   -            1   3
   *      //     / \              / \
   *      //    2   -     ==>    2  -1
   *      //       / \              / \
   *      //      3   -            3   4
   *      //         / \              / \
   *      //        4   0            4   0
   *
   * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
   */

  var reduceRight =
  /*#__PURE__*/
  _curry3(function reduceRight(fn, acc, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      acc = fn(list[idx], acc);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx -= 1;
    }

    return acc;
  });

  /**
   * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
   * through the list, successively calling the iterator function. `reduceWhile`
   * also takes a predicate that is evaluated before each step. If the predicate
   * returns `false`, it "short-circuits" the iteration and returns the current
   * value of the accumulator. `reduceWhile` may alternatively be short-circuited
   * via [`reduced`](#reduced).
   *
   * @func
   * @memberOf R
   * @since v0.22.0
   * @category List
   * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} pred The predicate. It is passed the accumulator and the
   *        current element.
   * @param {Function} fn The iterator function. Receives two values, the
   *        accumulator and the current element.
   * @param {*} a The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced
   * @example
   *
   *      const isOdd = (acc, x) => x % 2 !== 0;
   *      const xs = [1, 3, 5, 60, 777, 800];
   *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
   *
   *      const ys = [2, 4, 6]
   *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
   */

  var reduceWhile =
  /*#__PURE__*/
  _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
    var xf = _xwrap(function (acc, x) {
      return pred(acc, x) ? fn(acc, x) : _reduced(acc);
    });

    return _xReduce(xf, a, list);
  });

  /**
   * Returns a value wrapped to indicate that it is the final value of the reduce
   * and transduce functions. The returned value should be considered a black
   * box: the internal structure is not guaranteed to be stable.
   *
   * This optimization is available to the below functions:
   * - [`reduce`](#reduce)
   * - [`reduceWhile`](#reduceWhile)
   * - [`reduceBy`](#reduceBy)
   * - [`reduceRight`](#reduceRight)
   * - [`transduce`](#transduce)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category List
   * @sig a -> *
   * @param {*} x The final value of the reduce.
   * @return {*} The wrapped value.
   * @see R.reduce, R.reduceWhile, R.reduceBy, R.reduceRight, R.transduce
   * @example
   *
   *     R.reduce(
   *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
   *       [],
   *       [1, 2, 3, 4, 5]) // [1, 2, 3]
   */

  var reduced =
  /*#__PURE__*/
  _curry1(_reduced);

  /**
   * Calls an input function `n` times, returning an array containing the results
   * of those function calls.
   *
   * `fn` is passed one argument: The current value of `n`, which begins at `0`
   * and is gradually incremented to `n - 1`.
   *
   * @func
   * @memberOf R
   * @since v0.2.3
   * @category List
   * @sig (Number -> a) -> Number -> [a]
   * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
   * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
   * @return {Array} An array containing the return values of all calls to `fn`.
   * @see R.repeat
   * @example
   *
   *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
   * @symb R.times(f, 0) = []
   * @symb R.times(f, 1) = [f(0)]
   * @symb R.times(f, 2) = [f(0), f(1)]
   */

  var times =
  /*#__PURE__*/
  _curry2(function times(fn, n) {
    var len = Number(n);
    var idx = 0;
    var list;

    if (len < 0 || isNaN(len)) {
      throw new RangeError('n must be a non-negative number');
    }

    list = [];

    while (idx < len) {
      list.push(fn(idx));
      idx += 1;
    }

    return list;
  });

  /**
   * Returns a fixed list of size `n` containing a specified identical value.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig a -> n -> [a]
   * @param {*} value The value to repeat.
   * @param {Number} n The desired size of the output list.
   * @return {Array} A new array containing `n` `value`s.
   * @see R.times
   * @example
   *
   *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
   *
   *      const obj = {};
   *      const repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
   *      repeatedObjs[0] === repeatedObjs[1]; //=> true
   * @symb R.repeat(a, 0) = []
   * @symb R.repeat(a, 1) = [a]
   * @symb R.repeat(a, 2) = [a, a]
   */

  var repeat =
  /*#__PURE__*/
  _curry2(function repeat(value, n) {
    return times(always(value), n);
  });

  /**
   * Replace a substring or regex match in a string with a replacement.
   *
   * The first two parameters correspond to the parameters of the
   * `String.prototype.replace()` function, so the second parameter can also be a
   * function.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category String
   * @sig RegExp|String -> String -> String -> String
   * @param {RegExp|String} pattern A regular expression or a substring to match.
   * @param {String} replacement The string to replace the matches with.
   * @param {String} str The String to do the search and replacement in.
   * @return {String} The result.
   * @example
   *
   *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *
   *      // Use the "g" (global) flag to replace all occurrences:
   *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
   */

  var replace =
  /*#__PURE__*/
  _curry3(function replace(regex, replacement, str) {
    return str.replace(regex, replacement);
  });

  var tInit = '@@transducer/init';
  var tStep = '@@transducer/step';

  var XScan =
  /*#__PURE__*/
  function () {
    function XScan(reducer, acc, xf) {
      this.xf = xf;
      this.f = reducer;
      this.acc = acc;
    }

    XScan.prototype[tInit] = function () {
      return this.xf[tStep](this.xf[tInit](), this.acc);
    };

    XScan.prototype['@@transducer/result'] = _xfBase.result;

    XScan.prototype[tStep] = function (result, input) {
      if (result['@@transducer/reduced']) {
        return result;
      }

      this.acc = this.f(this.acc, input);
      return this.xf[tStep](result, this.acc);
    };

    return XScan;
  }();

  var _xscan =
  /*#__PURE__*/
  _curry3(function _xscan(reducer, acc, xf) {
    return new XScan(reducer, acc, xf);
  });

  /**
   * Scan is similar to [`reduce`](#reduce), but returns a list of successively
   * reduced values from the left.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> [a]
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {Array} A list of all intermediately reduced values.
   * @see R.reduce, R.mapAccum
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
   * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
   */

  var scan =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _dispatchable([], _xscan, function scan(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [acc];

    while (idx < len) {
      acc = fn(acc, list[idx]);
      result[idx + 1] = acc;
      idx += 1;
    }

    return result;
  }));

  /**
   * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
   * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
   * Applicative of Traversable.
   *
   * Dispatches to the `"fantasy-land/traverse"` or the `traverse` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig fantasy-land/of :: TypeRep f => f ~> a -> f a
   * @sig (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)
   * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
   * @param {Object|Function} TypeRepresentative with an `of` or `fantasy-land/of` method
   * @param {*} traversable
   * @return {*}
   * @see R.traverse
   * @example
   *
   *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
   *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
   *
   *      R.sequence(R.of(Array), Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
   *      R.sequence(R.of(Array), Nothing());       //=> [Nothing()]
   */

  var sequence =
  /*#__PURE__*/
  _curry2(function sequence(F, traversable) {
    var of = typeof F['fantasy-land/of'] === 'function' ? F['fantasy-land/of'] : typeof F.of === 'function' ? F.of : F;
    var TypeRep = {
      'fantasy-land/of': of
    };
    return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](TypeRep, _identity) : typeof traversable.traverse === 'function' ? traversable.traverse(TypeRep, _identity) : reduceRight(function (x, acc) {
      return ap(map(prepend, x), acc);
    }, of([]), traversable);
  });

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the given value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> a -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.view, R.over, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
   *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
   */

  var set =
  /*#__PURE__*/
  _curry3(function set(lens, v, x) {
    return over(lens, always(v), x);
  });

  /**
   * Returns a copy of the list, sorted according to the comparator function,
   * which should accept two values at a time and return a negative number if the
   * first value is smaller, a positive number if it's larger, and zero if they
   * are equal. Please note that this is a **copy** of the list. It does not
   * modify the original.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, a) -> Number) -> [a] -> [a]
   * @param {Function} comparator A sorting function :: a -> b -> Int
   * @param {Array} list The list to sort
   * @return {Array} a new array with its elements sorted by the comparator function.
   * @see R.ascend, R.descend
   * @example
   *
   *      const diff = function(a, b) { return a - b; };
   *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
   */

  var sort =
  /*#__PURE__*/
  _curry2(function sort(comparator, list) {
    return Array.prototype.slice.call(list, 0).sort(comparator);
  });

  /**
   * Sorts the list according to the supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord b => (a -> b) -> [a] -> [a]
   * @param {Function} fn
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted by the keys generated by `fn`.
   * @example
   *
   *      const sortByFirstItem = R.sortBy(R.prop(0));
   *      const pairs = [[-1, 1], [-2, 2], [-3, 3]];
   *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
   *
   *      const sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
   *      const alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      const bob = {
   *        name: 'Bob',
   *        age: -10
   *      };
   *      const clara = {
   *        name: 'clara',
   *        age: 314.159
   *      };
   *      const people = [clara, bob, alice];
   *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
   */

  var sortBy =
  /*#__PURE__*/
  _curry2(function sortBy(fn, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
  });

  /**
   * Sorts a list according to a list of comparators.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Relation
   * @sig [(a, a) -> Number] -> [a] -> [a]
   * @param {Array} functions A list of comparator functions.
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted according to the comarator functions.
   * @see R.ascend, R.descend
   * @example
   *
   *      const alice = {
   *        name: 'alice',
   *        age: 40
   *      };
   *      const bob = {
   *        name: 'bob',
   *        age: 30
   *      };
   *      const clara = {
   *        name: 'clara',
   *        age: 40
   *      };
   *      const people = [clara, bob, alice];
   *      const ageNameSort = R.sortWith([
   *        R.descend(R.prop('age')),
   *        R.ascend(R.prop('name'))
   *      ]);
   *      ageNameSort(people); //=> [alice, clara, bob]
   */

  var sortWith =
  /*#__PURE__*/
  _curry2(function sortWith(fns, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var result = 0;
      var i = 0;

      while (result === 0 && i < fns.length) {
        result = fns[i](a, b);
        i += 1;
      }

      return result;
    });
  });

  /**
   * Splits a string into an array of strings based on the given
   * separator.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig (String | RegExp) -> String -> [String]
   * @param {String|RegExp} sep The pattern.
   * @param {String} str The string to separate into an array.
   * @return {Array} The array of strings from `str` separated by `sep`.
   * @see R.join
   * @example
   *
   *      const pathComponents = R.split('/');
   *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
   *
   *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
   */

  var split =
  /*#__PURE__*/
  invoker(1, 'split');

  /**
   * Splits a given list or string at a given index.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig Number -> [a] -> [[a], [a]]
   * @sig Number -> String -> [String, String]
   * @param {Number} index The index where the array/string is split.
   * @param {Array|String} array The array/string to be split.
   * @return {Array}
   * @example
   *
   *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
   *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
   *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
   */

  var splitAt =
  /*#__PURE__*/
  _curry2(function splitAt(index, array) {
    return [slice(0, index, array), slice(index, length(array), array)];
  });

  /**
   * Splits a collection into slices of the specified length.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @sig Number -> String -> [String]
   * @param {Number} n
   * @param {Array} list
   * @return {Array}
   * @example
   *
   *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
   *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
   */

  var splitEvery =
  /*#__PURE__*/
  _curry2(function splitEvery(n, list) {
    if (n <= 0) {
      throw new Error('First argument to splitEvery must be a positive integer');
    }

    var result = [];
    var idx = 0;

    while (idx < list.length) {
      result.push(slice(idx, idx += n, list));
    }

    return result;
  });

  /**
   * Takes a list and a predicate and returns a pair of lists with the following properties:
   *
   *  - the result of concatenating the two output lists is equivalent to the input list;
   *  - none of the elements of the first output list satisfies the predicate; and
   *  - if the second output list is non-empty, its first element satisfies the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a], [a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
   */

  var splitWhen =
  /*#__PURE__*/
  _curry2(function splitWhen(pred, list) {
    var idx = 0;
    var len = list.length;
    var prefix = [];

    while (idx < len && !pred(list[idx])) {
      prefix.push(list[idx]);
      idx += 1;
    }

    return [prefix, Array.prototype.slice.call(list, idx)];
  });

  /**
   * Splits an array into slices on every occurrence of a value.
   *
   * @func
   * @memberOf R
   * @since v0.26.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhenever(R.equals(2), [1, 2, 3, 2, 4, 5, 2, 6, 7]); //=> [[1], [3], [4, 5], [6, 7]]
   */

  var splitWhenever =
  /*#__PURE__*/
  _curryN(2, [], function splitWhenever(pred, list) {
    var acc = [];
    var curr = [];

    for (var i = 0; i < list.length; i = i + 1) {
      if (!pred(list[i])) {
        curr.push(list[i]);
      }

      if ((i < list.length - 1 && pred(list[i + 1]) || i === list.length - 1) && curr.length > 0) {
        acc.push(curr);
        curr = [];
      }
    }

    return acc;
  });

  /**
   * Checks if a list starts with the provided sublist.
   *
   * Similarly, checks if a string starts with the provided substring.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> [a] -> Boolean
   * @sig String -> String -> Boolean
   * @param {*} prefix
   * @param {*} list
   * @return {Boolean}
   * @see R.endsWith
   * @example
   *
   *      R.startsWith('a', 'abc')                //=> true
   *      R.startsWith('b', 'abc')                //=> false
   *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
   *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
   */

  var startsWith =
  /*#__PURE__*/
  _curry2(function (prefix, list) {
    return equals(take(prefix.length, list), prefix);
  });

  /**
   * Subtracts its second argument from its first argument.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a - b`.
   * @see R.add
   * @example
   *
   *      R.subtract(10, 8); //=> 2
   *
   *      const minus5 = R.subtract(R.__, 5);
   *      minus5(17); //=> 12
   *
   *      const complementaryAngle = R.subtract(90);
   *      complementaryAngle(30); //=> 60
   *      complementaryAngle(72); //=> 18
   */

  var subtract =
  /*#__PURE__*/
  _curry2(function subtract(a, b) {
    return Number(a) - Number(b);
  });

  var swapObject = function (indexA, indexB, o) {
    var copy = clone$1(o);
    var properties = Object.getOwnPropertyNames(copy);

    if (properties.includes(indexA) && properties.includes(indexB)) {
      var tmp = copy[indexA];
      copy[indexA] = copy[indexB];
      copy[indexB] = tmp;
    }

    return copy;
  };

  var swapList = function (indexA, indexB, list) {
    var length = list.length;
    var result = list.slice();
    var positiveIndexA = indexA < 0 ? length + indexA : indexA;
    var positiveIndexB = indexB < 0 ? length + indexB : indexB;
    var positiveMin = Math.min(positiveIndexA, positiveIndexB);
    var positiveMax = Math.max(positiveIndexA, positiveIndexB);

    if (positiveIndexA < 0 || positiveIndexA > length) {
      return result;
    }

    if (positiveIndexB < 0 || positiveIndexB > length) {
      return result;
    }

    if (positiveIndexA === positiveIndexB) {
      return result;
    }

    result = [].concat(result.slice(0, positiveMin)).concat([result[positiveMax]]).concat(result.slice(positiveMin + 1, positiveMax)).concat([result[positiveMin]]).concat(result.slice(positiveMax + 1, length));
    return result;
  };

  var swapString = function (indexA, indexB, s) {
    var result = swapList(indexA, indexB, s);
    return _isArray(result) ? result.join('') : result;
  };
  /**
   * Swap an item, at index `indexA` with another item, at index `indexB`, in an object or a list of elements.
   * A new result will be created containing the new elements order.
   *
   * @func
   * @memberOf R
   * @since v0.29.0
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number|string|Object} indexA The first index
   * @param {Number|string|Object} indexB The second index
   * @param {Array|Object} o Either the object or list which will serve to realise the swap
   * @return {Array|Object} The new object or list reordered
   * @example
   *
   *      R.swap(0, 2, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['c', 'b', 'a', 'd', 'e', 'f']
   *      R.swap(-1, 0, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['f', 'b', 'c', 'd', 'e', 'a']
   *      R.swap('a', 'b', {a: 1, b: 2}); //=> {a: 2, b: 1}
   *      R.swap(0, 2, 'foo'); //=> 'oof'
   */


  var swap =
  /*#__PURE__*/
  _curry3(function (indexA, indexB, o) {
    if (_isArray(o)) {
      return swapList(indexA, indexB, o);
    } else if (_isString(o)) {
      return swapString(indexA, indexB, o);
    } else {
      return swapObject(indexA, indexB, o);
    }
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
   * @example
   *
   *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
   *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
   */

  var symmetricDifference =
  /*#__PURE__*/
  _curry2(function symmetricDifference(list1, list2) {
    return concat(difference(list1, list2), difference(list2, list1));
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both. Duplication is determined according to the value
   * returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifference, R.difference, R.differenceWith
   * @example
   *
   *      const eqA = R.eqBy(R.prop('a'));
   *      const l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
   *      const l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
   *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
   */

  var symmetricDifferenceWith =
  /*#__PURE__*/
  _curry3(function symmetricDifferenceWith(pred, list1, list2) {
    return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
  });

  /**
   * Returns a new list containing the last `n` elements of a given list, passing
   * each value to the supplied predicate function, and terminating when the
   * predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropLastWhile, R.addIndex
   * @example
   *
   *      const isNotOne = x => x !== 1;
   *
   *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
   *
   *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
   */

  var takeLastWhile =
  /*#__PURE__*/
  _curry2(function takeLastWhile(fn, xs) {
    var idx = xs.length - 1;

    while (idx >= 0 && fn(xs[idx])) {
      idx -= 1;
    }

    return slice(idx + 1, Infinity, xs);
  });

  var XTakeWhile =
  /*#__PURE__*/
  function () {
    function XTakeWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
    XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;

    XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
    };

    return XTakeWhile;
  }();

  function _xtakeWhile(f) {
    return function (xf) {
      return new XTakeWhile(f, xf);
    };
  }

  /**
   * Returns a new list containing the first `n` elements of a given list,
   * passing each value to the supplied predicate function, and terminating when
   * the predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * Dispatches to the `takeWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropWhile, R.transduce, R.addIndex
   * @example
   *
   *      const isNotFour = x => x !== 4;
   *
   *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
   *
   *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
   */

  var takeWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, xs) {
    var idx = 0;
    var len = xs.length;

    while (idx < len && fn(xs[idx])) {
      idx += 1;
    }

    return slice(0, idx, xs);
  }));

  var XTap =
  /*#__PURE__*/
  function () {
    function XTap(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XTap.prototype['@@transducer/init'] = _xfBase.init;
    XTap.prototype['@@transducer/result'] = _xfBase.result;

    XTap.prototype['@@transducer/step'] = function (result, input) {
      this.f(input);
      return this.xf['@@transducer/step'](result, input);
    };

    return XTap;
  }();

  function _xtap(f) {
    return function (xf) {
      return new XTap(f, xf);
    };
  }

  /**
   * Runs the given function with the supplied object, then returns the object.
   *
   * Acts as a transducer if a transformer is given as second parameter.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a -> *) -> a -> a
   * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
   * @param {*} x
   * @return {*} `x`.
   * @example
   *
   *      const sayX = x => console.log('x is ' + x);
   *      R.tap(sayX, 100); //=> 100
   *      // logs 'x is 100'
   * @symb R.tap(f, a) = (f(a), a)
   */

  var tap =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xtap, function tap(fn, x) {
    fn(x);
    return x;
  }));

  function _isRegExp(x) {
    return Object.prototype.toString.call(x) === '[object RegExp]';
  }

  /**
   * Determines whether a given string matches a given regular expression.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category String
   * @sig RegExp -> String -> Boolean
   * @param {RegExp} pattern
   * @param {String} str
   * @return {Boolean}
   * @see R.match
   * @example
   *
   *      R.test(/^x/, 'xyz'); //=> true
   *      R.test(/^y/, 'xyz'); //=> false
   */

  var test =
  /*#__PURE__*/
  _curry2(function test(pattern, str) {
    if (!_isRegExp(pattern)) {
      throw new TypeError('test requires a value of type RegExp as its first argument; received ' + toString(pattern));
    }

    return _cloneRegExp(pattern).test(str);
  });

  /**
   * Returns the result of applying the onSuccess function to the value inside
   * a successfully resolved promise. This is useful for working with promises
   * inside function compositions.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Function
   * @sig (a -> b) -> (Promise e a) -> (Promise e b)
   * @sig (a -> (Promise e b)) -> (Promise e a) -> (Promise e b)
   * @param {Function} onSuccess The function to apply. Can return a value or a promise of a value.
   * @param {Promise} p
   * @return {Promise} The result of calling `p.then(onSuccess)`
   * @see R.otherwise
   * @example
   *
   *      const makeQuery = email => ({ query: { email }});
   *      const fetchMember = request =>
   *        Promise.resolve({ firstName: 'Bob', lastName: 'Loblaw', id: 42 });
   *
   *      //getMemberName :: String -> Promise ({ firstName, lastName })
   *      const getMemberName = R.pipe(
   *        makeQuery,
   *        fetchMember,
   *        R.andThen(R.pick(['firstName', 'lastName']))
   *      );
   *
   *      getMemberName('bob@gmail.com').then(console.log);
   */

  var andThen =
  /*#__PURE__*/
  _curry2(function andThen(f, p) {
    _assertPromise('andThen', p);

    return p.then(f);
  });

  /**
   * The lower case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to lower case.
   * @return {String} The lower case version of `str`.
   * @see R.toUpper
   * @example
   *
   *      R.toLower('XYZ'); //=> 'xyz'
   */

  var toLower =
  /*#__PURE__*/
  invoker(0, 'toLowerCase');

  /**
   * Converts an object into an array of key, value arrays. Only the object's
   * own properties are used.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own properties.
   * @see R.fromPairs, R.keys, R.values
   * @example
   *
   *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
   */

  var toPairs =
  /*#__PURE__*/
  _curry1(function toPairs(obj) {
    var pairs = [];

    for (var prop in obj) {
      if (_has(prop, obj)) {
        pairs[pairs.length] = [prop, obj[prop]];
      }
    }

    return pairs;
  });

  /**
   * Converts an object into an array of key, value arrays. The object's own
   * properties and prototype properties are used. Note that the order of the
   * output array is not guaranteed to be consistent across different JS
   * platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own
   *         and prototype properties.
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
   */

  var toPairsIn =
  /*#__PURE__*/
  _curry1(function toPairsIn(obj) {
    var pairs = [];

    for (var prop in obj) {
      pairs[pairs.length] = [prop, obj[prop]];
    }

    return pairs;
  });

  /**
   * The upper case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to upper case.
   * @return {String} The upper case version of `str`.
   * @see R.toLower
   * @example
   *
   *      R.toUpper('abc'); //=> 'ABC'
   */

  var toUpper =
  /*#__PURE__*/
  invoker(0, 'toUpperCase');

  /**
   * Initializes a transducer using supplied iterator function. Returns a single
   * item by iterating through the list, successively calling the transformed
   * iterator function and passing it an accumulator value and the current value
   * from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It will be
   * wrapped as a transformer to initialize the transducer. A transformer can be
   * passed directly in place of an iterator function. In both cases, iteration
   * may be stopped early with the [`R.reduced`](#reduced) function.
   *
   * A transducer is a function that accepts a transformer and returns a
   * transformer and can be composed directly.
   *
   * A transformer is an object that provides a 2-arity reducing iterator
   * function, step, 0-arity initial value function, init, and 1-arity result
   * extraction function, result. The step function is used as the iterator
   * function in reduce. The result function is used to convert the final
   * accumulator into the return type and in most cases is
   * [`R.identity`](#identity). The init function can be used to provide an
   * initial accumulator, but is ignored by transduce.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array. Wrapped as transformer, if necessary, and used to
   *        initialize the transducer
   * @param {*} acc The initial accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced, R.into
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
   *
   *      const isOdd = (x) => x % 2 !== 0;
   *      const firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
   *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
   */

  var transduce =
  /*#__PURE__*/
  curryN(4, function transduce(xf, fn, acc, list) {
    return _xReduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
  });

  /**
   * Transposes the rows and columns of a 2D list.
   * When passed a list of `n` lists of length `x`,
   * returns a list of `x` lists of length `n`.
   *
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [[a]] -> [[a]]
   * @param {Array} list A 2D list
   * @return {Array} A 2D list
   * @example
   *
   *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
   *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   *
   *      // If some of the rows are shorter than the following rows, their elements are skipped:
   *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
   * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
   * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
   * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
   */

  var transpose =
  /*#__PURE__*/
  _curry1(function transpose(outerlist) {
    var i = 0;
    var result = [];

    while (i < outerlist.length) {
      var innerlist = outerlist[i];
      var j = 0;

      while (j < innerlist.length) {
        if (typeof result[j] === 'undefined') {
          result[j] = [];
        }

        result[j].push(innerlist[j]);
        j += 1;
      }

      i += 1;
    }

    return result;
  });

  /**
   * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
   * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
   * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
   * into an Applicative of Traversable.
   *
   * Dispatches to the `traverse` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig fantasy-land/of :: TypeRep f => f ~> a -> f a
   * @sig (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)
   * @sig (Applicative f, Traversable t) => (b -> f b) -> (a -> f b) -> t a -> f (t b)
   * @param {Object|Function} TypeRepresentative with an `of` or `fantasy-land/of` method
   * @param {Function} f
   * @param {*} traversable
   * @return {*}
   * @see R.sequence
   * @example
   *
   *      // Returns `Maybe.Nothing` if the given divisor is `0`
   *      const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)
   *
   *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Maybe.Just([5, 2.5, 2])
   *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Maybe.Nothing
   *
   *      // Using a Type Representative
   *      R.traverse(Maybe, safeDiv(10), Right(4)); //=> Just(Right(2.5))
   *      R.traverse(Maybe, safeDiv(10), Right(0)); //=> Nothing
   *      R.traverse(Maybe, safeDiv(10), Left("X")); //=> Just(Left("X"))
   */

  var traverse =
  /*#__PURE__*/
  _curry3(function traverse(F, f, traversable) {
    var of = typeof F['fantasy-land/of'] === 'function' ? F['fantasy-land/of'] : typeof F.of === 'function' ? F.of : F;
    var TypeRep = {
      'fantasy-land/of': of
    };
    return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](TypeRep, f) : typeof traversable.traverse === 'function' ? traversable.traverse(TypeRep, f) : sequence(TypeRep, map(f, traversable));
  });

  var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
  var zeroWidth = '\u200b';
  var hasProtoTrim = typeof String.prototype.trim === 'function';
  /**
   * Removes (strips) whitespace from both ends of the string.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to trim.
   * @return {String} Trimmed version of `str`.
   * @example
   *
   *      R.trim('   xyz  '); //=> 'xyz'
   *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
   */

  var trim = !hasProtoTrim ||
  /*#__PURE__*/
  ws.trim() || !
  /*#__PURE__*/
  zeroWidth.trim() ?
  /*#__PURE__*/
  _curry1(function trim(str) {
    var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
    var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
    return str.replace(beginRx, '').replace(endRx, '');
  }) :
  /*#__PURE__*/
  _curry1(function trim(str) {
    return str.trim();
  });

  /**
   * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
   * function evaluates the `tryer`; if it does not throw, it simply returns the
   * result. If the `tryer` *does* throw, the returned function evaluates the
   * `catcher` function and returns its result. Note that for effective
   * composition with this function, both the `tryer` and `catcher` functions
   * must return the same type of results.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
   * @param {Function} tryer The function that may throw.
   * @param {Function} catcher The function that will be evaluated if `tryer` throws.
   * @return {Function} A new function that will catch exceptions and send them to the catcher.
   * @example
   *
   *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
   *      R.tryCatch(() => { throw 'foo'}, R.always('caught'))('bar') // =>
   *      'caught'
   *      R.tryCatch(R.times(R.identity), R.always([]))('s') // => []
   *      R.tryCatch(() => { throw 'this is not a valid value'}, (err, value)=>({error : err,  value }))('bar') // => {'error': 'this is not a valid value', 'value': 'bar'}
   */

  var tryCatch =
  /*#__PURE__*/
  _curry2(function _tryCatch(tryer, catcher) {
    return _arity(tryer.length, function () {
      try {
        return tryer.apply(this, arguments);
      } catch (e) {
        return catcher.apply(this, _concat([e], arguments));
      }
    });
  });

  /**
   * Takes a function `fn`, which takes a single array argument, and returns a
   * function which:
   *
   *   - takes any number of positional arguments;
   *   - passes these arguments to `fn` as an array; and
   *   - returns the result.
   *
   * In other words, `R.unapply` derives a variadic function from a function which
   * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Function
   * @sig ([*...] -> a) -> (*... -> a)
   * @param {Function} fn
   * @return {Function}
   * @see R.apply
   * @example
   *
   *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
   * @symb R.unapply(f)(a, b) = f([a, b])
   */

  var unapply =
  /*#__PURE__*/
  _curry1(function unapply(fn) {
    return function () {
      return fn(Array.prototype.slice.call(arguments, 0));
    };
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 1 parameter. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (a -> b -> c -> ... -> z) -> (a -> z)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 1.
   * @see R.binary, R.nAry
   * @example
   *
   *      const takesTwoArgs = function(a, b) {
   *        return [a, b];
   *      };
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      const takesOneArg = R.unary(takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only 1 argument is passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.unary(f)(a, b, c) = f(a)
   */

  var unary =
  /*#__PURE__*/
  _curry1(function unary(fn) {
    return nAry(1, fn);
  });

  /**
   * Returns a function of arity `n` from a (manually) curried function.
   * Note that, the returned function is actually a ramda style
   * curryied function, which can accept one or more arguments in each
   * function calling.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Function
   * @sig Number -> (a -> b -> c ... -> z) -> ((a -> b -> c ...) -> z)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to uncurry.
   * @return {Function} A new function.
   * @see R.curry, R.curryN
   * @example
   *
   *      const addFour = a => b => c => d => a + b + c + d;
   *
   *      const uncurriedAddFour = R.uncurryN(4, addFour);
   *      uncurriedAddFour(1, 2, 3, 4); //=> 10
   */

  var uncurryN =
  /*#__PURE__*/
  _curry2(function uncurryN(depth, fn) {
    return curryN(depth, function () {
      var currentDepth = 1;
      var value = fn;
      var idx = 0;
      var endIdx;

      while (currentDepth <= depth && typeof value === 'function') {
        endIdx = currentDepth === depth ? arguments.length : idx + value.length;
        value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
        currentDepth += 1;
        idx = endIdx;
      }

      return value;
    });
  });

  /**
   * Builds a list from a seed value. Accepts an iterator function, which returns
   * either false to stop iteration or an array of length 2 containing the value
   * to add to the resulting list and the seed to be used in the next call to the
   * iterator function.
   *
   * The iterator function receives one argument: *(seed)*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (a -> [b]) -> * -> [b]
   * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
   *        either false to quit iteration or an array of length two to proceed. The element
   *        at index 0 of this array will be added to the resulting array, and the element
   *        at index 1 will be passed to the next call to `fn`.
   * @param {*} seed The seed value.
   * @return {Array} The final list.
   * @example
   *
   *      const f = n => n > 50 ? false : [-n, n + 10];
   *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
   * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
   */

  var unfold =
  /*#__PURE__*/
  _curry2(function unfold(fn, seed) {
    var pair = fn(seed);
    var result = [];

    while (pair && pair.length) {
      result[result.length] = pair[0];
      pair = fn(pair[1]);
    }

    return result;
  });

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @example
   *
   *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
   */

  var union =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  compose(uniq, _concat));

  var XUniqWith =
  /*#__PURE__*/
  function () {
    function XUniqWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.items = [];
    }

    XUniqWith.prototype['@@transducer/init'] = _xfBase.init;
    XUniqWith.prototype['@@transducer/result'] = _xfBase.result;

    XUniqWith.prototype['@@transducer/step'] = function (result, input) {
      if (_includesWith(this.pred, input, this.items)) {
        return result;
      } else {
        this.items.push(input);
        return this.xf['@@transducer/step'](result, input);
      }
    };

    return XUniqWith;
  }();

  function _xuniqWith(pred) {
    return function (xf) {
      return new XUniqWith(pred, xf);
    };
  }

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied predicate to
   * two list elements. Prefers the first item if two items compare equal based
   * on the predicate.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      const strEq = R.eqBy(String);
   *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
   *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
   *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
   *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
   */

  var uniqWith =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xuniqWith, function (pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;

    while (idx < len) {
      item = list[idx];

      if (!_includesWith(pred, item, result)) {
        result[result.length] = item;
      }

      idx += 1;
    }

    return result;
  }));

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list. Duplication is determined according to the value returned by
   * applying the supplied predicate to two list elements. If an element exists
   * in both lists, the first element from the first list will be used.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @see R.union
   * @example
   *
   *      const l1 = [{a: 1}, {a: 2}];
   *      const l2 = [{a: 1}, {a: 4}];
   *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
   */

  var unionWith =
  /*#__PURE__*/
  _curry3(function unionWith(pred, list1, list2) {
    return uniqWith(pred, _concat(list1, list2));
  });

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is not satisfied, the function will return the result of
   * calling the `whenFalseFn` function with the same argument. If the predicate
   * is satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> b) -> a -> a | b
   * @param {Function} pred        A predicate function
   * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
   *                               to a falsy value.
   * @param {*}        x           An object to test with the `pred` function and
   *                               pass to `whenFalseFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
   * @see R.ifElse, R.when, R.cond
   * @example
   *
   *      let safeInc = R.unless(R.isNil, R.inc);
   *      safeInc(null); //=> null
   *      safeInc(1); //=> 2
   */

  var unless =
  /*#__PURE__*/
  _curry3(function unless(pred, whenFalseFn, x) {
    return pred(x) ? x : whenFalseFn(x);
  });

  /**
   * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
   * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain c => c (c a) -> c a
   * @param {*} list
   * @return {*}
   * @see R.flatten, R.chain
   * @example
   *
   *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
   *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
   */

  var unnest =
  /*#__PURE__*/
  chain(_identity);

  /**
   * Takes a predicate, a transformation function, and an initial value,
   * and returns a value of the same type as the initial value.
   * It does so by applying the transformation until the predicate is satisfied,
   * at which point it returns the satisfactory value.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred A predicate function
   * @param {Function} fn The iterator function
   * @param {*} init Initial value
   * @return {*} Final value that satisfies predicate
   * @example
   *
   *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
   */

  var until =
  /*#__PURE__*/
  _curry3(function until(pred, fn, init) {
    var val = init;

    while (!pred(val)) {
      val = fn(val);
    }

    return val;
  });

  /**
   *
   * Deconstructs an array field from the input documents to output a document for each element.
   * Each output document is the input document with the value of the array field replaced by the element.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig String -> {k: [v]} -> [{k: v}]
   * @param {String} key The key to determine which property of the object should be unwind
   * @param {Object} object The object containing list under property named as key which is to unwind
   * @return {List} A new list of object containing the value of input key having list replaced by each element in the object.
   * @example
   *
   * R.unwind('hobbies', {
   *   name: 'alice',
   *   hobbies: ['Golf', 'Hacking'],
   *   colors: ['red', 'green'],
   * });
   * // [
   * //   { name: 'alice', hobbies: 'Golf', colors: ['red', 'green'] },
   * //   { name: 'alice', hobbies: 'Hacking', colors: ['red', 'green'] }
   * // ]
   */

  var unwind =
  /*#__PURE__*/
  _curry2(function (key, object) {
    // If key is not in object or key is not as a list in object
    if (!(key in object && _isArray(object[key]))) {
      return [object];
    } // Map over object[key] which is a list and assoc each element with key


    return _map(function (item) {
      return _assoc(key, item, object);
    }, object[key]);
  });

  /**
   * Returns a list of all the properties, including prototype properties, of the
   * supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own and prototype properties.
   * @see R.values, R.keysIn
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.valuesIn(f); //=> ['X', 'Y']
   */

  var valuesIn =
  /*#__PURE__*/
  _curry1(function valuesIn(obj) {
    var prop;
    var vs = [];

    for (prop in obj) {
      vs[vs.length] = obj[prop];
    }

    return vs;
  });

  var Const = function (x) {
    return {
      value: x,
      'fantasy-land/map': function () {
        return this;
      }
    };
  };
  /**
   * Returns a "view" of the given data structure, determined by the given lens.
   * The lens's focus determines which portion of the data structure is visible.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> s -> a
   * @param {Lens} lens
   * @param {*} x
   * @return {*}
   * @see R.set, R.over, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});  //=> 1
   *      R.view(xLens, {x: 4, y: 2});  //=> 4
   */


  var view =
  /*#__PURE__*/
  _curry2(function view(lens, x) {
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    return lens(Const)(x).value;
  });

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is satisfied, the function will return the result of calling
   * the `whenTrueFn` function with the same argument. If the predicate is not
   * satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> b) -> a -> a | b
   * @param {Function} pred       A predicate function
   * @param {Function} whenTrueFn A function to invoke when the `condition`
   *                              evaluates to a truthy value.
   * @param {*}        x          An object to test with the `pred` function and
   *                              pass to `whenTrueFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
   * @see R.ifElse, R.unless, R.cond
   * @example
   *
   *      // truncate :: String -> String
   *      const truncate = R.when(
   *        R.propSatisfies(R.gt(R.__, 10), 'length'),
   *        R.pipe(R.take(10), R.append(''), R.join(''))
   *      );
   *      truncate('12345');         //=> '12345'
   *      truncate('0123456789ABC'); //=> '0123456789'
   */

  var when =
  /*#__PURE__*/
  _curry3(function when(pred, whenTrueFn, x) {
    return pred(x) ? whenTrueFn(x) : x;
  });

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec. Each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `where` returns true if all the predicates return true, false
   * otherwise.
   *
   * `where` is well suited to declaratively expressing constraints for other
   * functions such as [`filter`](#filter) and [`find`](#find).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propSatisfies, R.whereEq
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.where({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('bar')),
   *        x: R.gt(R.__, 10),
   *        y: R.lt(R.__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
   */

  var where =
  /*#__PURE__*/
  _curry2(function where(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && !spec[prop](testObj[prop])) {
        return false;
      }
    }

    return true;
  });

  /**
   * Takes a spec object and a test object; each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `whereAny` returns true if at least one of the predicates return true,
   * false otherwise.
   *
   * `whereAny` is well suited to declaratively expressing constraints for other
   * functions such as [`filter`](#filter) and [`find`](#find).
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propSatisfies, R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.whereAny({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('xxx')),
   *        x: R.gt(R.__, 10),
   *        y: R.lt(R.__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 8, y: 34}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 9, y: 21}); //=> false
   *      pred({a: 'bar', b: 'xxx', x: 10, y: 20}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 10, y: 20}); //=> true
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> true
   */

  var whereAny =
  /*#__PURE__*/
  _curry2(function whereAny(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && spec[prop](testObj[prop])) {
        return true;
      }
    }

    return false;
  });

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec, false otherwise. An object satisfies the spec if, for each of the
   * spec's own properties, accessing that property of the object gives the same
   * value (in [`R.equals`](#equals) terms) as accessing that property of the
   * spec.
   *
   * `whereEq` is a specialization of [`where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @sig {String: *} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propEq, R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.whereEq({a: 1, b: 2});
   *
   *      pred({a: 1});              //=> false
   *      pred({a: 1, b: 2});        //=> true
   *      pred({a: 1, b: 2, c: 3});  //=> true
   *      pred({a: 1, b: 1});        //=> false
   */

  var whereEq =
  /*#__PURE__*/
  _curry2(function whereEq(spec, testObj) {
    return where(map(equals, spec), testObj);
  });

  /**
   * Returns a new list without values in the first argument.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @param {Array} list1 The values to be removed from `list2`.
   * @param {Array} list2 The array to remove values from.
   * @return {Array} The new array without values in `list1`.
   * @see R.transduce, R.difference, R.remove
   * @example
   *
   *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
   */

  var without =
  /*#__PURE__*/
  _curry2(function without(xs, list) {
    var toRemove = new _Set();

    for (var i = 0; i < xs.length; i += 1) {
      toRemove.add(xs[i]);
    }

    return reject(toRemove.has.bind(toRemove), list);
  });

  /**
   * Exclusive disjunction logical operation.
   * Returns `true` if one of the arguments is truthy and the other is falsy.
   * Otherwise, it returns `false`.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Logic
   * @sig a -> b -> Boolean
   * @param {Any} a
   * @param {Any} b
   * @return {Boolean} true if one of the arguments is truthy and the other is falsy
   * @see R.or, R.and
   * @example
   *
   *      R.xor(true, true); //=> false
   *      R.xor(true, false); //=> true
   *      R.xor(false, true); //=> true
   *      R.xor(false, false); //=> false
   */

  var xor =
  /*#__PURE__*/
  _curry2(function xor(a, b) {
    return Boolean(!a ^ !b);
  });

  /**
   * Creates a new list out of the two supplied by creating each possible pair
   * from the lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The list made by combining each possible pair from
   *         `as` and `bs` into pairs (`[a, b]`).
   * @example
   *
   *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
   * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
   */

  var xprod =
  /*#__PURE__*/
  _curry2(function xprod(a, b) {
    // = xprodWith(prepend); (takes about 3 times as long...)
    var idx = 0;
    var ilen = a.length;
    var j;
    var jlen = b.length;
    var result = [];

    while (idx < ilen) {
      j = 0;

      while (j < jlen) {
        result[result.length] = [a[idx], b[j]];
        j += 1;
      }

      idx += 1;
    }

    return result;
  });

  /**
   * Creates a new list out of the two supplied by pairing up equally-positioned
   * items from both lists. The returned list is truncated to the length of the
   * shorter of the two input lists.
   * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
   * @example
   *
   *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
   */

  var zip =
  /*#__PURE__*/
  _curry2(function zip(a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);

    while (idx < len) {
      rv[idx] = [a[idx], b[idx]];
      idx += 1;
    }

    return rv;
  });

  /**
   * Creates a new object out of a list of keys and a list of values.
   * Key/value pairing is truncated to the length of the shorter of the two lists.
   * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [String] -> [*] -> {String: *}
   * @param {Array} keys The array that will be properties on the output object.
   * @param {Array} values The list of values on the output object.
   * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
   * @example
   *
   *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
   */

  var zipObj =
  /*#__PURE__*/
  _curry2(function zipObj(keys, values) {
    var idx = 0;
    var len = Math.min(keys.length, values.length);
    var out = {};

    while (idx < len) {
      out[keys[idx]] = values[idx];
      idx += 1;
    }

    return out;
  });

  /**
   * Creates a new list out of the two supplied by applying the function to each
   * equally-positioned pair in the lists. The returned list is truncated to the
   * length of the shorter of the two input lists.
   *
   * @function
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
   * @param {Function} fn The function used to combine the two elements into one value.
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
   *         using `fn`.
   * @example
   *
   *      const f = (x, y) => {
   *        // ...
   *      };
   *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
   *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
   * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
   */

  var zipWith =
  /*#__PURE__*/
  _curry3(function zipWith(fn, a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);

    while (idx < len) {
      rv[idx] = fn(a[idx], b[idx]);
      idx += 1;
    }

    return rv;
  });

  /**
   * Creates a thunk out of a function. A thunk delays a calculation until
   * its result is needed, providing lazy evaluation of arguments.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((a, b, ..., j) -> k) -> (a, b, ..., j) -> (() -> k)
   * @param {Function} fn A function to wrap in a thunk
   * @return {Function} Expects arguments for `fn` and returns a new function
   *  that, when called, applies those arguments to `fn`.
   * @see R.partial, R.partialRight
   * @example
   *
   *      R.thunkify(R.identity)(42)(); //=> 42
   *      R.thunkify((a, b) => a + b)(25, 17)(); //=> 42
   */

  var thunkify =
  /*#__PURE__*/
  _curry1(function thunkify(fn) {
    return curryN(fn.length, function createThunk() {
      var fnArgs = arguments;
      return function invokeThunk() {
        return fn.apply(this, fnArgs);
      };
    });
  });

  var ramda = /*#__PURE__*/Object.freeze({
    __proto__: null,
    F: F$1,
    T: T,
    __: __,
    add: add,
    addIndex: addIndex,
    addIndexRight: addIndexRight,
    adjust: adjust,
    all: all,
    allPass: allPass,
    always: always,
    and: and,
    andThen: andThen,
    any: any,
    anyPass: anyPass,
    ap: ap,
    aperture: aperture,
    append: append,
    apply: apply,
    applySpec: applySpec,
    applyTo: applyTo,
    ascend: ascend,
    assoc: assoc,
    assocPath: assocPath,
    binary: binary,
    bind: bind,
    both: both,
    call: call,
    chain: chain,
    clamp: clamp,
    clone: clone$1,
    collectBy: collectBy,
    comparator: comparator,
    complement: complement,
    compose: compose,
    composeWith: composeWith,
    concat: concat,
    cond: cond,
    construct: construct,
    constructN: constructN,
    converge: converge,
    count: count,
    countBy: countBy,
    curry: curry,
    curryN: curryN,
    dec: dec,
    defaultTo: defaultTo,
    descend: descend,
    difference: difference,
    differenceWith: differenceWith,
    dissoc: dissoc,
    dissocPath: dissocPath,
    divide: divide,
    drop: drop$1,
    dropLast: dropLast,
    dropLastWhile: dropLastWhile,
    dropRepeats: dropRepeats,
    dropRepeatsBy: dropRepeatsBy,
    dropRepeatsWith: dropRepeatsWith,
    dropWhile: dropWhile,
    either: either,
    empty: empty,
    endsWith: endsWith,
    eqBy: eqBy,
    eqProps: eqProps,
    equals: equals,
    evolve: evolve,
    filter: filter,
    find: find$1,
    findIndex: findIndex,
    findLast: findLast,
    findLastIndex: findLastIndex,
    flatten: flatten,
    flip: flip,
    forEach: forEach,
    forEachObjIndexed: forEachObjIndexed,
    fromPairs: fromPairs,
    groupBy: groupBy,
    groupWith: groupWith,
    gt: gt,
    gte: gte,
    has: has,
    hasIn: hasIn,
    hasPath: hasPath,
    head: head,
    identical: identical,
    identity: identity,
    ifElse: ifElse,
    inc: inc,
    includes: includes,
    indexBy: indexBy,
    indexOf: indexOf,
    init: init,
    innerJoin: innerJoin,
    insert: insert,
    insertAll: insertAll,
    intersection: intersection,
    intersperse: intersperse,
    into: into,
    invert: invert,
    invertObj: invertObj,
    invoker: invoker,
    is: is,
    isEmpty: isEmpty,
    isNil: isNil,
    isNotNil: isNotNil,
    join: join,
    juxt: juxt,
    keys: keys,
    keysIn: keysIn,
    last: last,
    lastIndexOf: lastIndexOf,
    length: length,
    lens: lens,
    lensIndex: lensIndex,
    lensPath: lensPath,
    lensProp: lensProp,
    lift: lift,
    liftN: liftN,
    lt: lt,
    lte: lte,
    map: map,
    mapAccum: mapAccum,
    mapAccumRight: mapAccumRight,
    mapObjIndexed: mapObjIndexed,
    match: match,
    mathMod: mathMod,
    max: max,
    maxBy: maxBy,
    mean: mean,
    median: median,
    memoizeWith: memoizeWith,
    mergeAll: mergeAll,
    mergeDeepLeft: mergeDeepLeft,
    mergeDeepRight: mergeDeepRight,
    mergeDeepWith: mergeDeepWith,
    mergeDeepWithKey: mergeDeepWithKey,
    mergeLeft: mergeLeft,
    mergeRight: mergeRight,
    mergeWith: mergeWith,
    mergeWithKey: mergeWithKey,
    min: min,
    minBy: minBy,
    modify: modify,
    modifyPath: modifyPath,
    modulo: modulo,
    move: move,
    multiply: multiply,
    nAry: nAry,
    negate: negate,
    none: none,
    not: not,
    nth: nth,
    nthArg: nthArg,
    o: o,
    objOf: objOf,
    of: of,
    omit: omit,
    on: on$1,
    once: once,
    or: or,
    otherwise: otherwise,
    over: over,
    pair: pair,
    partial: partial,
    partialObject: partialObject,
    partialRight: partialRight,
    partition: partition,
    path: path,
    pathEq: pathEq,
    pathOr: pathOr,
    pathSatisfies: pathSatisfies,
    paths: paths,
    pick: pick,
    pickAll: pickAll,
    pickBy: pickBy,
    pipe: pipe,
    pipeWith: pipeWith,
    pluck: pluck,
    prepend: prepend,
    product: product,
    project: project,
    promap: promap,
    prop: prop,
    propEq: propEq,
    propIs: propIs,
    propOr: propOr,
    propSatisfies: propSatisfies,
    props: props,
    range: range,
    reduce: reduce,
    reduceBy: reduceBy,
    reduceRight: reduceRight,
    reduceWhile: reduceWhile,
    reduced: reduced,
    reject: reject,
    remove: remove,
    repeat: repeat,
    replace: replace,
    reverse: reverse,
    scan: scan,
    sequence: sequence,
    set: set,
    slice: slice,
    sort: sort,
    sortBy: sortBy,
    sortWith: sortWith,
    split: split,
    splitAt: splitAt,
    splitEvery: splitEvery,
    splitWhen: splitWhen,
    splitWhenever: splitWhenever,
    startsWith: startsWith,
    subtract: subtract,
    sum: sum,
    swap: swap,
    symmetricDifference: symmetricDifference,
    symmetricDifferenceWith: symmetricDifferenceWith,
    tail: tail,
    take: take,
    takeLast: takeLast,
    takeLastWhile: takeLastWhile,
    takeWhile: takeWhile,
    tap: tap,
    test: test,
    thunkify: thunkify,
    times: times,
    toLower: toLower,
    toPairs: toPairs,
    toPairsIn: toPairsIn,
    toString: toString,
    toUpper: toUpper,
    transduce: transduce,
    transpose: transpose,
    traverse: traverse,
    trim: trim,
    tryCatch: tryCatch,
    type: type,
    unapply: unapply,
    unary: unary,
    uncurryN: uncurryN,
    unfold: unfold,
    union: union,
    unionWith: unionWith,
    uniq: uniq,
    uniqBy: uniqBy,
    uniqWith: uniqWith,
    unless: unless,
    unnest: unnest,
    until: until,
    unwind: unwind,
    update: update,
    useWith: useWith,
    values: values,
    valuesIn: valuesIn,
    view: view,
    when: when,
    where: where,
    whereAny: whereAny,
    whereEq: whereEq,
    without: without,
    xor: xor,
    xprod: xprod,
    zip: zip,
    zipObj: zipObj,
    zipWith: zipWith
  });

  function defaultFormatter(value) {
      if (value === null || value === undefined)
          return '';
      return `${value}`;
  }

  function numberFormatter(opts = {}) {
      const { separator, decimals } = opts;
      if (separator) {
          if (decimals) {
              return (value) => value.toFixed(decimals).replace('.', separator);
          }
          return (value) => `${value}`.replace('.', separator);
      }
      if (decimals) {
          return (value) => value.toFixed(decimals);
      }
      return (value) => `${value}`;
  }

  function stringFormatter(opts = {}) {
      const quote = typeof opts.quote === 'string' ? opts.quote : '"';
      const escapedQuote = typeof opts.escapedQuote === 'string'
          ? opts.escapedQuote
          : `${quote}${quote}`;
      if (!quote || quote === escapedQuote) {
          return (value) => value;
      }
      const quoteRegExp = new RegExp(quote, 'g');
      return (value) => {
          if (value.includes(quote)) {
              value = value.replace(quoteRegExp, escapedQuote);
          }
          return `${quote}${value}${quote}`;
      };
  }

  function symbolFormatter(opts = { stringFormatter: stringFormatter() }) {
      return (value) => opts.stringFormatter(value.toString().slice(7, -1));
  }

  function objectFormatter(opts = { stringFormatter: stringFormatter() }) {
      return (value) => {
          if (value === null)
              return '';
          let stringifiedValue = JSON.stringify(value);
          if (stringifiedValue === undefined)
              return '';
          if (stringifiedValue[0] === '"')
              stringifiedValue = stringifiedValue.replace(/^"(.+)"$/, '$1');
          return opts.stringFormatter(stringifiedValue);
      };
  }

  const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  '[^.[\\]]+' +
      '|' +
      // Or match property names within brackets.
      '\\[(?:' +
      // Match a non-string expression.
      '([^"\'][^[]*)' +
      '|' +
      // Or match strings (supports escaping characters).
      '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
      ')\\]' +
      '|' +
      // Or match "" as the space between consecutive dots or empty brackets.
      '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))', 'g');
  function castPath(value) {
      var _a, _b, _c;
      const result = [];
      let match;
      while ((match = rePropName.exec(value))) {
          result.push((_c = (_a = match[3]) !== null && _a !== void 0 ? _a : (_b = match[1]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : match[0]);
      }
      return result;
  }
  function getProp(obj, path, defaultValue) {
      if (path in obj) {
          const value = obj[path];
          return value === undefined ? defaultValue : value;
      }
      const processedPath = Array.isArray(path) ? path : castPath(path);
      let currentValue = obj;
      for (const key of processedPath) {
          currentValue = currentValue === null || currentValue === void 0 ? void 0 : currentValue[key];
          if (currentValue === undefined)
              return defaultValue;
      }
      return currentValue;
  }
  function flattenReducer(acc, arr) {
      try {
          // This is faster but susceptible to `RangeError: Maximum call stack size exceeded`
          Array.isArray(arr) ? acc.push(...arr) : acc.push(arr);
          return acc;
      }
      catch (err) {
          // Fallback to a slower but safer option
          return acc.concat(arr);
      }
  }
  function fastJoin(arr, separator) {
      let isFirst = true;
      return arr.reduce((acc, elem) => {
          if (elem === null || elem === undefined) {
              elem = '';
          }
          if (isFirst) {
              isFirst = false;
              return `${elem}`;
          }
          return `${acc}${separator}${elem}`;
      }, '');
  }

  var FormatterTypes;
  (function (FormatterTypes) {
      FormatterTypes["header"] = "header";
      FormatterTypes["undefined"] = "undefined";
      FormatterTypes["boolean"] = "boolean";
      FormatterTypes["number"] = "number";
      FormatterTypes["bigint"] = "bigint";
      FormatterTypes["string"] = "string";
      FormatterTypes["symbol"] = "symbol";
      FormatterTypes["function"] = "function";
      FormatterTypes["object"] = "object";
  })(FormatterTypes || (FormatterTypes = {}));
  class JSON2CSVBase {
      constructor(opts) {
          this.opts = this.preprocessOpts(opts);
      }
      /**
       * Check passing opts and set defaults.
       *
       * @param {Json2CsvOptions} opts Options object containing fields,
       * delimiter, default value, header, etc.
       */
      preprocessOpts(opts) {
          const processedOpts = Object.assign({}, opts);
          if (processedOpts.fields) {
              processedOpts.fields = this.preprocessFieldsInfo(processedOpts.fields, processedOpts.defaultValue);
          }
          processedOpts.transforms = processedOpts.transforms || [];
          const stringFormatter$1 = (processedOpts.formatters && processedOpts.formatters['string']) ||
              stringFormatter();
          const objectFormatter$1 = objectFormatter({ stringFormatter: stringFormatter$1 });
          const defaultFormatters = {
              header: stringFormatter$1,
              undefined: defaultFormatter,
              boolean: defaultFormatter,
              number: numberFormatter(),
              bigint: defaultFormatter,
              string: stringFormatter$1,
              symbol: symbolFormatter({ stringFormatter: stringFormatter$1 }),
              function: objectFormatter$1,
              object: objectFormatter$1,
          };
          processedOpts.formatters = Object.assign(Object.assign({}, defaultFormatters), processedOpts.formatters);
          processedOpts.delimiter = processedOpts.delimiter || ',';
          processedOpts.eol = processedOpts.eol || '\n';
          processedOpts.header = processedOpts.header !== false;
          processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;
          processedOpts.withBOM = processedOpts.withBOM || false;
          return processedOpts;
      }
      /**
       * Check and normalize the fields configuration.
       *
       * @param {(string|object)[]} fields Fields configuration provided by the user
       * or inferred from the data
       * @returns {object[]} preprocessed FieldsInfo array
       */
      preprocessFieldsInfo(fields, globalDefaultValue) {
          return fields.map((fieldInfo) => {
              if (typeof fieldInfo === 'string') {
                  return {
                      label: fieldInfo,
                      value: (row) => getProp(row, fieldInfo, globalDefaultValue),
                  };
              }
              if (typeof fieldInfo === 'object') {
                  const defaultValue = 'default' in fieldInfo ? fieldInfo.default : globalDefaultValue;
                  if (typeof fieldInfo.value === 'string') {
                      const fieldPath = fieldInfo.value;
                      return {
                          label: fieldInfo.label || fieldInfo.value,
                          value: (row) => getProp(row, fieldPath, defaultValue),
                      };
                  }
                  if (typeof fieldInfo.value === 'function') {
                      const label = fieldInfo.label || fieldInfo.value.name || '';
                      const field = { label, default: defaultValue };
                      const valueGetter = fieldInfo.value;
                      return {
                          label,
                          value(row) {
                              const value = valueGetter(row, field);
                              return value === undefined ? defaultValue : value;
                          },
                      };
                  }
              }
              throw new Error('Invalid field info option. ' + JSON.stringify(fieldInfo));
          });
      }
      /**
       * Create the title row with all the provided fields as column headings
       *
       * @returns {String} titles as a string
       */
      getHeader() {
          return fastJoin(this.opts.fields.map((fieldInfo) => this.opts.formatters.header(fieldInfo.label)), this.opts.delimiter);
      }
      /**
       * Preprocess each object according to the given transforms (unwind, flatten, etc.).
       * @param {Object} row JSON object to be converted in a CSV row
       */
      preprocessRow(row) {
          return this.opts.transforms.reduce((rows, transform) => rows.map((row) => transform(row)).reduce(flattenReducer, []), [row]);
      }
      /**
       * Create the content of a specific CSV row
       *
       * @param {Object} row JSON object to be converted in a CSV row
       * @returns {String} CSV string (row)
       */
      processRow(row) {
          if (!row) {
              return undefined;
          }
          const processedRow = this.opts.fields.map((fieldInfo) => this.processCell(row, fieldInfo));
          if (!this.opts.includeEmptyRows &&
              processedRow.every((field) => field === '')) {
              return undefined;
          }
          return fastJoin(processedRow, this.opts.delimiter);
      }
      /**
       * Create the content of a specfic CSV row cell
       *
       * @param {Object} row JSON object representing the  CSV row that the cell belongs to
       * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell
       * @returns {String} CSV string (cell)
       */
      processCell(row, fieldInfo) {
          return this.processValue(fieldInfo.value(row));
      }
      /**
       * Create the content of a specfic CSV row cell
       *
       * @param {T} value Value to be included in a CSV cell
       * @returns {String} Value stringified and processed
       */
      processValue(value) {
          const formatter = this.opts.formatters[typeof value];
          return formatter(value);
      }
  }

  class JSON2CSVParser extends JSON2CSVBase {
      constructor(opts) {
          super(opts);
      }
      /**
       * Main function that converts json to csv.
       *
       * @param {Array|Object} data Array of JSON objects to be converted to CSV
       * @returns {String} The CSV formated data as a string
       */
      parse(data) {
          const preprocessedData = this.preprocessData(data);
          this.opts.fields =
              this.opts.fields ||
                  this.preprocessFieldsInfo(preprocessedData.reduce((fields, item) => {
                      Object.keys(item).forEach((field) => {
                          if (!fields.includes(field)) {
                              fields.push(field);
                          }
                      });
                      return fields;
                  }, []), this.opts.defaultValue);
          const header = this.opts.header ? this.getHeader() : '';
          const rows = this.processData(preprocessedData);
          const csv = (this.opts.withBOM ? '\ufeff' : '') +
              header +
              (header && rows ? this.opts.eol : '') +
              rows;
          return csv;
      }
      /**
       * Preprocess the data according to the give opts (unwind, flatten, etc.)
        and calculate the fields and field names if they are not provided.
       *
       * @param {Array|Object} data Array or object to be converted to CSV
       */
      preprocessData(data) {
          const processedData = Array.isArray(data) ? data : [data];
          if (!this.opts.fields) {
              if (data === undefined || data === null || processedData.length === 0) {
                  throw new Error('Data should not be empty or the "fields" option should be included');
              }
              if (typeof processedData[0] !== 'object') {
                  throw new Error('Data items should be objects or the "fields" option should be included');
              }
          }
          if (this.opts.transforms.length === 0)
              return processedData;
          return processedData
              .map((row) => this.preprocessRow(row))
              .reduce(flattenReducer, []);
      }
      /**
       * Create the content row by row below the header
       *
       * @param {Array} data Array of JSON objects to be converted to CSV
       * @returns {String} CSV string (body)
       */
      processData(data) {
          return fastJoin(data.map((row) => this.processRow(row)).filter((row) => row), // Filter empty rows
          this.opts.eol);
      }
  }

  var charset;
  (function (charset) {
      charset[charset["BACKSPACE"] = 8] = "BACKSPACE";
      charset[charset["FORM_FEED"] = 12] = "FORM_FEED";
      charset[charset["NEWLINE"] = 10] = "NEWLINE";
      charset[charset["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
      charset[charset["TAB"] = 9] = "TAB";
      charset[charset["SPACE"] = 32] = "SPACE";
      charset[charset["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
      charset[charset["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
      charset[charset["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
      charset[charset["DOLLAR_SIGN"] = 36] = "DOLLAR_SIGN";
      charset[charset["PERCENT_SIGN"] = 37] = "PERCENT_SIGN";
      charset[charset["AMPERSAND"] = 38] = "AMPERSAND";
      charset[charset["APOSTROPHE"] = 39] = "APOSTROPHE";
      charset[charset["LEFT_PARENTHESIS"] = 40] = "LEFT_PARENTHESIS";
      charset[charset["RIGHT_PARENTHESIS"] = 41] = "RIGHT_PARENTHESIS";
      charset[charset["ASTERISK"] = 42] = "ASTERISK";
      charset[charset["PLUS_SIGN"] = 43] = "PLUS_SIGN";
      charset[charset["COMMA"] = 44] = "COMMA";
      charset[charset["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
      charset[charset["FULL_STOP"] = 46] = "FULL_STOP";
      charset[charset["SOLIDUS"] = 47] = "SOLIDUS";
      charset[charset["DIGIT_ZERO"] = 48] = "DIGIT_ZERO";
      charset[charset["DIGIT_ONE"] = 49] = "DIGIT_ONE";
      charset[charset["DIGIT_TWO"] = 50] = "DIGIT_TWO";
      charset[charset["DIGIT_THREE"] = 51] = "DIGIT_THREE";
      charset[charset["DIGIT_FOUR"] = 52] = "DIGIT_FOUR";
      charset[charset["DIGIT_FIVE"] = 53] = "DIGIT_FIVE";
      charset[charset["DIGIT_SIX"] = 54] = "DIGIT_SIX";
      charset[charset["DIGIT_SEVEN"] = 55] = "DIGIT_SEVEN";
      charset[charset["DIGIT_EIGHT"] = 56] = "DIGIT_EIGHT";
      charset[charset["DIGIT_NINE"] = 57] = "DIGIT_NINE";
      charset[charset["COLON"] = 58] = "COLON";
      charset[charset["SEMICOLON"] = 59] = "SEMICOLON";
      charset[charset["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
      charset[charset["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
      charset[charset["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
      charset[charset["QUESTION_MARK"] = 63] = "QUESTION_MARK";
      charset[charset["COMMERCIAL_AT"] = 64] = "COMMERCIAL_AT";
      charset[charset["LATIN_CAPITAL_LETTER_A"] = 65] = "LATIN_CAPITAL_LETTER_A";
      charset[charset["LATIN_CAPITAL_LETTER_B"] = 66] = "LATIN_CAPITAL_LETTER_B";
      charset[charset["LATIN_CAPITAL_LETTER_C"] = 67] = "LATIN_CAPITAL_LETTER_C";
      charset[charset["LATIN_CAPITAL_LETTER_D"] = 68] = "LATIN_CAPITAL_LETTER_D";
      charset[charset["LATIN_CAPITAL_LETTER_E"] = 69] = "LATIN_CAPITAL_LETTER_E";
      charset[charset["LATIN_CAPITAL_LETTER_F"] = 70] = "LATIN_CAPITAL_LETTER_F";
      charset[charset["LATIN_CAPITAL_LETTER_G"] = 71] = "LATIN_CAPITAL_LETTER_G";
      charset[charset["LATIN_CAPITAL_LETTER_H"] = 72] = "LATIN_CAPITAL_LETTER_H";
      charset[charset["LATIN_CAPITAL_LETTER_I"] = 73] = "LATIN_CAPITAL_LETTER_I";
      charset[charset["LATIN_CAPITAL_LETTER_J"] = 74] = "LATIN_CAPITAL_LETTER_J";
      charset[charset["LATIN_CAPITAL_LETTER_K"] = 75] = "LATIN_CAPITAL_LETTER_K";
      charset[charset["LATIN_CAPITAL_LETTER_L"] = 76] = "LATIN_CAPITAL_LETTER_L";
      charset[charset["LATIN_CAPITAL_LETTER_M"] = 77] = "LATIN_CAPITAL_LETTER_M";
      charset[charset["LATIN_CAPITAL_LETTER_N"] = 78] = "LATIN_CAPITAL_LETTER_N";
      charset[charset["LATIN_CAPITAL_LETTER_O"] = 79] = "LATIN_CAPITAL_LETTER_O";
      charset[charset["LATIN_CAPITAL_LETTER_P"] = 80] = "LATIN_CAPITAL_LETTER_P";
      charset[charset["LATIN_CAPITAL_LETTER_Q"] = 81] = "LATIN_CAPITAL_LETTER_Q";
      charset[charset["LATIN_CAPITAL_LETTER_R"] = 82] = "LATIN_CAPITAL_LETTER_R";
      charset[charset["LATIN_CAPITAL_LETTER_S"] = 83] = "LATIN_CAPITAL_LETTER_S";
      charset[charset["LATIN_CAPITAL_LETTER_T"] = 84] = "LATIN_CAPITAL_LETTER_T";
      charset[charset["LATIN_CAPITAL_LETTER_U"] = 85] = "LATIN_CAPITAL_LETTER_U";
      charset[charset["LATIN_CAPITAL_LETTER_V"] = 86] = "LATIN_CAPITAL_LETTER_V";
      charset[charset["LATIN_CAPITAL_LETTER_W"] = 87] = "LATIN_CAPITAL_LETTER_W";
      charset[charset["LATIN_CAPITAL_LETTER_X"] = 88] = "LATIN_CAPITAL_LETTER_X";
      charset[charset["LATIN_CAPITAL_LETTER_Y"] = 89] = "LATIN_CAPITAL_LETTER_Y";
      charset[charset["LATIN_CAPITAL_LETTER_Z"] = 90] = "LATIN_CAPITAL_LETTER_Z";
      charset[charset["LEFT_SQUARE_BRACKET"] = 91] = "LEFT_SQUARE_BRACKET";
      charset[charset["REVERSE_SOLIDUS"] = 92] = "REVERSE_SOLIDUS";
      charset[charset["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
      charset[charset["CIRCUMFLEX_ACCENT"] = 94] = "CIRCUMFLEX_ACCENT";
      charset[charset["LOW_LINE"] = 95] = "LOW_LINE";
      charset[charset["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
      charset[charset["LATIN_SMALL_LETTER_A"] = 97] = "LATIN_SMALL_LETTER_A";
      charset[charset["LATIN_SMALL_LETTER_B"] = 98] = "LATIN_SMALL_LETTER_B";
      charset[charset["LATIN_SMALL_LETTER_C"] = 99] = "LATIN_SMALL_LETTER_C";
      charset[charset["LATIN_SMALL_LETTER_D"] = 100] = "LATIN_SMALL_LETTER_D";
      charset[charset["LATIN_SMALL_LETTER_E"] = 101] = "LATIN_SMALL_LETTER_E";
      charset[charset["LATIN_SMALL_LETTER_F"] = 102] = "LATIN_SMALL_LETTER_F";
      charset[charset["LATIN_SMALL_LETTER_G"] = 103] = "LATIN_SMALL_LETTER_G";
      charset[charset["LATIN_SMALL_LETTER_H"] = 104] = "LATIN_SMALL_LETTER_H";
      charset[charset["LATIN_SMALL_LETTER_I"] = 105] = "LATIN_SMALL_LETTER_I";
      charset[charset["LATIN_SMALL_LETTER_J"] = 106] = "LATIN_SMALL_LETTER_J";
      charset[charset["LATIN_SMALL_LETTER_K"] = 107] = "LATIN_SMALL_LETTER_K";
      charset[charset["LATIN_SMALL_LETTER_L"] = 108] = "LATIN_SMALL_LETTER_L";
      charset[charset["LATIN_SMALL_LETTER_M"] = 109] = "LATIN_SMALL_LETTER_M";
      charset[charset["LATIN_SMALL_LETTER_N"] = 110] = "LATIN_SMALL_LETTER_N";
      charset[charset["LATIN_SMALL_LETTER_O"] = 111] = "LATIN_SMALL_LETTER_O";
      charset[charset["LATIN_SMALL_LETTER_P"] = 112] = "LATIN_SMALL_LETTER_P";
      charset[charset["LATIN_SMALL_LETTER_Q"] = 113] = "LATIN_SMALL_LETTER_Q";
      charset[charset["LATIN_SMALL_LETTER_R"] = 114] = "LATIN_SMALL_LETTER_R";
      charset[charset["LATIN_SMALL_LETTER_S"] = 115] = "LATIN_SMALL_LETTER_S";
      charset[charset["LATIN_SMALL_LETTER_T"] = 116] = "LATIN_SMALL_LETTER_T";
      charset[charset["LATIN_SMALL_LETTER_U"] = 117] = "LATIN_SMALL_LETTER_U";
      charset[charset["LATIN_SMALL_LETTER_V"] = 118] = "LATIN_SMALL_LETTER_V";
      charset[charset["LATIN_SMALL_LETTER_W"] = 119] = "LATIN_SMALL_LETTER_W";
      charset[charset["LATIN_SMALL_LETTER_X"] = 120] = "LATIN_SMALL_LETTER_X";
      charset[charset["LATIN_SMALL_LETTER_Y"] = 121] = "LATIN_SMALL_LETTER_Y";
      charset[charset["LATIN_SMALL_LETTER_Z"] = 122] = "LATIN_SMALL_LETTER_Z";
      charset[charset["LEFT_CURLY_BRACKET"] = 123] = "LEFT_CURLY_BRACKET";
      charset[charset["VERTICAL_LINE"] = 124] = "VERTICAL_LINE";
      charset[charset["RIGHT_CURLY_BRACKET"] = 125] = "RIGHT_CURLY_BRACKET";
      charset[charset["TILDE"] = 126] = "TILDE";
  })(charset || (charset = {}));
  ({
      [charset.QUOTATION_MARK]: charset.QUOTATION_MARK,
      [charset.REVERSE_SOLIDUS]: charset.REVERSE_SOLIDUS,
      [charset.SOLIDUS]: charset.SOLIDUS,
      [charset.LATIN_SMALL_LETTER_B]: charset.BACKSPACE,
      [charset.LATIN_SMALL_LETTER_F]: charset.FORM_FEED,
      [charset.LATIN_SMALL_LETTER_N]: charset.NEWLINE,
      [charset.LATIN_SMALL_LETTER_R]: charset.CARRIAGE_RETURN,
      [charset.LATIN_SMALL_LETTER_T]: charset.TAB,
  });

  var TokenType;
  (function (TokenType) {
      TokenType[TokenType["LEFT_BRACE"] = 0] = "LEFT_BRACE";
      TokenType[TokenType["RIGHT_BRACE"] = 1] = "RIGHT_BRACE";
      TokenType[TokenType["LEFT_BRACKET"] = 2] = "LEFT_BRACKET";
      TokenType[TokenType["RIGHT_BRACKET"] = 3] = "RIGHT_BRACKET";
      TokenType[TokenType["COLON"] = 4] = "COLON";
      TokenType[TokenType["COMMA"] = 5] = "COMMA";
      TokenType[TokenType["TRUE"] = 6] = "TRUE";
      TokenType[TokenType["FALSE"] = 7] = "FALSE";
      TokenType[TokenType["NULL"] = 8] = "NULL";
      TokenType[TokenType["STRING"] = 9] = "STRING";
      TokenType[TokenType["NUMBER"] = 10] = "NUMBER";
      TokenType[TokenType["SEPARATOR"] = 11] = "SEPARATOR";
  })(TokenType || (TokenType = {}));

  // Tokenizer States
  var TokenizerStates;
  (function (TokenizerStates) {
      TokenizerStates[TokenizerStates["START"] = 0] = "START";
      TokenizerStates[TokenizerStates["ENDED"] = 1] = "ENDED";
      TokenizerStates[TokenizerStates["ERROR"] = 2] = "ERROR";
      TokenizerStates[TokenizerStates["TRUE1"] = 3] = "TRUE1";
      TokenizerStates[TokenizerStates["TRUE2"] = 4] = "TRUE2";
      TokenizerStates[TokenizerStates["TRUE3"] = 5] = "TRUE3";
      TokenizerStates[TokenizerStates["FALSE1"] = 6] = "FALSE1";
      TokenizerStates[TokenizerStates["FALSE2"] = 7] = "FALSE2";
      TokenizerStates[TokenizerStates["FALSE3"] = 8] = "FALSE3";
      TokenizerStates[TokenizerStates["FALSE4"] = 9] = "FALSE4";
      TokenizerStates[TokenizerStates["NULL1"] = 10] = "NULL1";
      TokenizerStates[TokenizerStates["NULL2"] = 11] = "NULL2";
      TokenizerStates[TokenizerStates["NULL3"] = 12] = "NULL3";
      TokenizerStates[TokenizerStates["STRING_DEFAULT"] = 13] = "STRING_DEFAULT";
      TokenizerStates[TokenizerStates["STRING_AFTER_BACKSLASH"] = 14] = "STRING_AFTER_BACKSLASH";
      TokenizerStates[TokenizerStates["STRING_UNICODE_DIGIT_1"] = 15] = "STRING_UNICODE_DIGIT_1";
      TokenizerStates[TokenizerStates["STRING_UNICODE_DIGIT_2"] = 16] = "STRING_UNICODE_DIGIT_2";
      TokenizerStates[TokenizerStates["STRING_UNICODE_DIGIT_3"] = 17] = "STRING_UNICODE_DIGIT_3";
      TokenizerStates[TokenizerStates["STRING_UNICODE_DIGIT_4"] = 18] = "STRING_UNICODE_DIGIT_4";
      TokenizerStates[TokenizerStates["STRING_INCOMPLETE_CHAR"] = 19] = "STRING_INCOMPLETE_CHAR";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_INITIAL_MINUS"] = 20] = "NUMBER_AFTER_INITIAL_MINUS";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_INITIAL_ZERO"] = 21] = "NUMBER_AFTER_INITIAL_ZERO";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_INITIAL_NON_ZERO"] = 22] = "NUMBER_AFTER_INITIAL_NON_ZERO";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_FULL_STOP"] = 23] = "NUMBER_AFTER_FULL_STOP";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_DECIMAL"] = 24] = "NUMBER_AFTER_DECIMAL";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_E"] = 25] = "NUMBER_AFTER_E";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_E_AND_SIGN"] = 26] = "NUMBER_AFTER_E_AND_SIGN";
      TokenizerStates[TokenizerStates["NUMBER_AFTER_E_AND_DIGIT"] = 27] = "NUMBER_AFTER_E_AND_DIGIT";
      TokenizerStates[TokenizerStates["SEPARATOR"] = 28] = "SEPARATOR";
      TokenizerStates[TokenizerStates["BOM_OR_START"] = 29] = "BOM_OR_START";
      TokenizerStates[TokenizerStates["BOM"] = 30] = "BOM";
  })(TokenizerStates || (TokenizerStates = {}));

  var TokenParserMode;
  (function (TokenParserMode) {
      TokenParserMode[TokenParserMode["OBJECT"] = 0] = "OBJECT";
      TokenParserMode[TokenParserMode["ARRAY"] = 1] = "ARRAY";
  })(TokenParserMode || (TokenParserMode = {}));

  // Parser States
  var TokenParserState;
  (function (TokenParserState) {
      TokenParserState[TokenParserState["VALUE"] = 0] = "VALUE";
      TokenParserState[TokenParserState["KEY"] = 1] = "KEY";
      TokenParserState[TokenParserState["COLON"] = 2] = "COLON";
      TokenParserState[TokenParserState["COMMA"] = 3] = "COMMA";
      TokenParserState[TokenParserState["ENDED"] = 4] = "ENDED";
      TokenParserState[TokenParserState["ERROR"] = 5] = "ERROR";
      TokenParserState[TokenParserState["SEPARATOR"] = 6] = "SEPARATOR";
  })(TokenParserState || (TokenParserState = {}));

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z$3 = ":root{--sans-font:-apple-system,BlinkMacSystemFont,\"Avenir Next\",Avenir,\"Nimbus Sans L\",Roboto,\"Noto Sans\",\"Segoe UI\",Arial,Helvetica,\"Helvetica Neue\",sans-serif;--mono-font:Consolas,Menlo,Monaco,\"Andale Mono\",\"Ubuntu Mono\",monospace;--standard-border-radius:5px;--border-width:1px;--bg:#fff;--accent-bg:#f5f7ff;--text:#212121;--text-light:#585858;--border:#898ea4;--accent:#0d47a1;--accent-hover:#1266e2;--accent-text:var(--bg);--code:#d81b60;--preformatted:#444;--marked:#fd3;--disabled:#efefef}@media (prefers-color-scheme:dark){.demo-tools :root{--bg:#212121;--accent-bg:#2b2b2b;--text:#dcdcdc;--text-light:#ababab;--accent:#ffb300;--accent-hover:#ffe099;--accent-text:var(--bg);--code:#f06292;--preformatted:#ccc;--disabled:#111;color-scheme:dark}.demo-tools img,.demo-tools video{opacity:.8}}.demo-tools *,.demo-tools :after,.demo-tools :before{box-sizing:border-box}.demo-tools input,.demo-tools progress,.demo-tools select,.demo-tools textarea{appearance:none;-webkit-appearance:none;-moz-appearance:none}.demo-tools header{background-color:var(--accent-bg);border-bottom:var(--border-width) solid var(--border);grid-column:-1;padding:0 .5rem 2rem;text-align:center}.demo-tools header>:only-child{margin-block-start:2rem}.demo-tools header h1{margin:1rem auto;max-width:1200px}.demo-tools header p{margin:1rem auto;max-width:40rem}.demo-tools main{padding-top:1.5rem}.demo-tools footer{border-top:var(--border-width) solid var(--border);color:var(--text-light);font-size:.9rem;margin-top:4rem;padding:2rem 1rem 1.5rem;text-align:center}.demo-tools h1{font-size:3rem}.demo-tools h2{font-size:2.6rem;margin-top:3rem}.demo-tools h3{font-size:2rem;margin-top:3rem}.demo-tools h4{font-size:1.44rem}.demo-tools h5{font-size:1.15rem}.demo-tools h6{font-size:.96rem}.demo-tools p{margin:1.5rem 0}.demo-tools h1,.demo-tools h2,.demo-tools h3,.demo-tools h4,.demo-tools h5,.demo-tools h6,.demo-tools p{overflow-wrap:break-word}.demo-tools h1,.demo-tools h2,.demo-tools h3{line-height:1.1}@media only screen and (max-width:720px){.demo-tools h1{font-size:2.5rem}.demo-tools h2{font-size:2.1rem}.demo-tools h3{font-size:1.75rem}.demo-tools h4{font-size:1.25rem}}.demo-tools a,.demo-tools a:visited{color:var(--accent)}.demo-tools a:hover{text-decoration:none}.demo-tools .button,.demo-tools a.button,.demo-tools button,.demo-tools input[type=button],.demo-tools input[type=reset],.demo-tools input[type=submit]{background-color:var(--accent);border:var(--border-width) solid var(--accent);color:var(--accent-text);line-height:normal;padding:.5em;text-decoration:none}.demo-tools .button[aria-disabled=true],.demo-tools button[disabled],.demo-tools input:disabled,.demo-tools select:disabled,.demo-tools textarea:disabled{background-color:var(--disabled);border-color:var(--disabled);color:var(--text-light);cursor:not-allowed}.demo-tools input[type=range]{padding:0}.demo-tools abbr[title]{cursor:help;text-decoration-line:underline;text-decoration-style:dotted}.demo-tools .button:not([aria-disabled=true]):hover,.demo-tools button:enabled:hover,.demo-tools input[type=button]:enabled:hover,.demo-tools input[type=reset]:enabled:hover,.demo-tools input[type=submit]:enabled:hover{background-color:var(--accent-hover);border-color:var(--accent-hover);cursor:pointer}.demo-tools .button:focus-visible,.demo-tools button:focus-visible:where(:enabled),.demo-tools input:enabled:focus-visible:where([type=submit],[type=reset],[type=button]){outline:2px solid var(--accent);outline-offset:1px}.demo-tools header nav{font-size:1rem;line-height:2;padding:1rem 0 0}.demo-tools header nav ol,.demo-tools header nav ul{align-content:space-around;align-items:center;display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center;list-style-type:none;margin:0;padding:0}.demo-tools header nav ol li,.demo-tools header nav ul li{display:inline-block}.demo-tools header nav a,.demo-tools header nav a:visited{border:var(--border-width) solid var(--border);border-radius:var(--standard-border-radius);color:var(--text);display:inline-block;margin:0 .5rem 1rem;padding:.1rem 1rem;text-decoration:none}.demo-tools header nav a.current,.demo-tools header nav a:hover,.demo-tools header nav a[aria-current=page],.demo-tools header nav a[aria-current=true]{background:var(--bg);border-color:var(--accent);color:var(--accent);cursor:pointer}@media only screen and (max-width:720px){.demo-tools header nav a{border:none;line-height:1;padding:0;text-decoration:underline}.demo-tools header nav a.current{background:none}}.demo-tools aside,.demo-tools details,.demo-tools pre,.demo-tools progress{background-color:var(--accent-bg);border:var(--border-width) solid var(--border);border-radius:var(--standard-border-radius);margin-bottom:1rem}.demo-tools aside{float:right;font-size:1rem;margin-inline-start:15px;padding:0 15px;width:30%}.demo-tools [dir=rtl] aside{float:left}@media only screen and (max-width:720px){.demo-tools aside{float:none;margin-inline-start:0;width:100%}}.demo-tools article,.demo-tools dialog,.demo-tools fieldset{border:var(--border-width) solid var(--border);border-radius:var(--standard-border-radius);margin-bottom:1rem;padding:1rem}.demo-tools article h2:first-child,.demo-tools article h3:first-child,.demo-tools section h2:first-child,.demo-tools section h3:first-child{margin-top:1rem}.demo-tools section{border-bottom:var(--border-width) solid var(--border);border-top:var(--border-width) solid var(--border);margin:3rem 0;padding:2rem 1rem}.demo-tools section+section,.demo-tools section:first-child{border-top:0;padding-top:0}.demo-tools section+section{margin-top:0}.demo-tools section:last-child{border-bottom:0;padding-bottom:0}.demo-tools details{padding:.7rem 1rem}.demo-tools summary{cursor:pointer;font-weight:700;margin:-.7rem -1rem;padding:.7rem 1rem;word-break:break-all}.demo-tools details[open]>summary+*{margin-top:0}.demo-tools details[open]>summary{margin-bottom:.5rem}.demo-tools details[open]>:last-child{margin-bottom:0}.demo-tools table{border-collapse:collapse;margin:1.5rem 0}.demo-tools figure>table{margin:0;width:max-content}.demo-tools td,.demo-tools th{border:var(--border-width) solid var(--border);padding:.5rem;text-align:start}.demo-tools th{font-weight:700}.demo-tools th,.demo-tools tr:nth-child(2n){background-color:var(--accent-bg)}.demo-tools table caption{font-weight:700;margin-bottom:.5rem}.demo-tools .button,.demo-tools button,.demo-tools input,.demo-tools select,.demo-tools textarea{border-radius:var(--standard-border-radius);box-shadow:none;display:inline-block;font-family:inherit;font-size:inherit;margin-bottom:.5rem;max-width:100%;padding:.5em}.demo-tools input,.demo-tools select,.demo-tools textarea{background-color:var(--bg);border:var(--border-width) solid var(--border);color:var(--text)}.demo-tools label{display:block}.demo-tools textarea:not([cols]){width:100%}.demo-tools select:not([multiple]){background-image:linear-gradient(45deg,transparent 49%,var(--text) 51%),linear-gradient(135deg,var(--text) 51%,transparent 49%);background-position:calc(100% - 15px),calc(100% - 10px);background-repeat:no-repeat;background-size:5px 5px,5px 5px;padding-inline-end:25px}.demo-tools [dir=rtl] select:not([multiple]){background-position:10px,15px}.demo-tools input[type=checkbox],.demo-tools input[type=radio]{position:relative;vertical-align:middle;width:min-content}.demo-tools input[type=checkbox]+label,.demo-tools input[type=radio]+label{display:inline-block}.demo-tools input[type=radio]{border-radius:100%}.demo-tools input[type=checkbox]:checked,.demo-tools input[type=radio]:checked{background-color:var(--accent)}.demo-tools input[type=checkbox]:checked:after{background-color:transparent;border-bottom:.08em solid var(--bg);border-radius:0;border-right:.08em solid var(--bg);content:\" \";font-size:1.8em;height:.4em;left:.18em;position:absolute;top:.04em;transform:rotate(45deg);width:.2em}.demo-tools input[type=radio]:checked:after{background-color:var(--bg);border-radius:100%;content:\" \";font-size:1.8em;height:.3em;left:.125em;position:absolute;top:.125em;width:.3em}@media only screen and (max-width:720px){.demo-tools input,.demo-tools select,.demo-tools textarea{width:100%}}.demo-tools input[type=color]{height:2.5rem;padding:.2rem}.demo-tools input[type=file]{border:0}.demo-tools hr{background:var(--border);border:none;height:var(--border-width);margin:1rem auto}.demo-tools mark{background-color:var(--marked);border-radius:var(--standard-border-radius);color:#000;padding:2px 5px}.demo-tools mark a{color:#0d47a1}.demo-tools img,.demo-tools video{border-radius:var(--standard-border-radius);height:auto;max-width:100%}.demo-tools figure{display:block;margin:0;overflow-x:auto}.demo-tools figure>img,.demo-tools figure>picture>img{display:block;margin-inline:auto}.demo-tools figcaption{color:var(--text-light);font-size:.9rem;left:0;margin-block:1rem;position:sticky;text-align:center}.demo-tools blockquote{border-inline-start:.35rem solid var(--accent);color:var(--text-light);font-style:italic;margin-block:2rem;margin-inline-end:0;margin-inline-start:2rem;padding:.4rem .8rem}.demo-tools cite{font-size:.9rem;font-style:normal}.demo-tools cite,.demo-tools dt{color:var(--text-light)}.demo-tools code,.demo-tools kbd,.demo-tools pre,.demo-tools pre span,.demo-tools samp{color:var(--code);font-family:var(--mono-font)}.demo-tools kbd{border:var(--border-width) solid var(--preformatted);border-bottom:3px solid var(--preformatted);border-radius:var(--standard-border-radius);color:var(--preformatted);padding:.1rem .4rem}.demo-tools pre{color:var(--preformatted);max-width:100%;overflow:auto;padding:1rem 1.4rem}.demo-tools pre code{background:none;color:var(--preformatted);margin:0;padding:0}.demo-tools progress{width:100%}.demo-tools progress:indeterminate{background-color:var(--accent-bg)}.demo-tools progress::-webkit-progress-bar{background-color:var(--accent-bg);border-radius:var(--standard-border-radius)}.demo-tools progress::-webkit-progress-value{background-color:var(--accent);border-radius:var(--standard-border-radius)}.demo-tools progress::-moz-progress-bar{background-color:var(--accent);border-radius:var(--standard-border-radius);transition-duration:.3s;transition-property:width}.demo-tools progress:indeterminate::-moz-progress-bar{background-color:var(--accent-bg)}.demo-tools dialog{background-color:var(--bg);margin:auto;max-width:40rem}.demo-tools dialog::backdrop{background-color:var(--bg);opacity:.8}@media only screen and (max-width:720px){.demo-tools dialog{max-width:calc(100vw - 2rem)}}.demo-tools sub,.demo-tools sup{position:relative;vertical-align:baseline}.demo-tools sup{top:-.4em}.demo-tools sub{top:.3em}.demo-tools .notice{background:var(--accent-bg);border:var(--border-width) solid var(--border);border-radius:var(--standard-border-radius);margin:2rem 0;padding:1.5rem}.demo-tools div.notice p:first-of-type{margin-top:0}.demo-tools div.notice p:last-of-type{margin-bottom:0}@media print{@page{margin:1cm}.demo-tools header{background-color:unset}.demo-tools footer,.demo-tools header nav{display:none}.demo-tools article{border:none;padding:0}.demo-tools a[href^=http]:after{content:\" <\" attr(href) \">\"}.demo-tools abbr[title]:after{content:\" (\" attr(title) \")\"}.demo-tools a{text-decoration:none}.demo-tools p{orphans:3;widows:3}.demo-tools hr{border-top:var(--border-width) solid var(--border)}.demo-tools mark{border:var(--border-width) solid var(--border)}.demo-tools figure,.demo-tools img,.demo-tools pre,.demo-tools svg,.demo-tools table{break-inside:avoid}.demo-tools pre code{white-space:pre-wrap}}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVybmFsL3N0eWxlLmxlc3MiLCJzdHlsZS5sZXNzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE1BRUUsMkpBQUEsQ0FHQSx1RUFBQSxDQUNBLDRCQUFBLENBQ0Esa0JBQUEsQ0FHQSxTQUFBLENBQ0EsbUJBQUEsQ0FDQSxjQUFBLENBQ0Esb0JBQUEsQ0FDQSxnQkFBQSxDQUNBLGdCQUFBLENBQ0Esc0JBQUEsQ0FDQSx1QkFBQSxDQUNBLGNBQUEsQ0FDQSxtQkFBQSxDQUNBLGFBQUEsQ0FDQSxrQkNERixDRE9FLG1DQUFBLGtCQUdJLFlBQUEsQ0FDQSxtQkFBQSxDQUNBLGNBQUEsQ0FDQSxvQkFBQSxDQUNBLGdCQUFBLENBQ0Esc0JBQUEsQ0FDQSx1QkFBQSxDQUNBLGNBQUEsQ0FDQSxtQkFBQSxDQUNBLGVBQUEsQ0FWQSxpQkM2Q0osQ0QvQ0Esa0NBa0JJLFVDaUNKLENBQ0YsQ0R2REEscURBNEJJLHFCQ2dDSixDRDVEQSwrRUFxQ0ksZUFBQSxDQUNBLHVCQUFBLENBQ0Esb0JDNkJKLENEcEVBLG1CQThDSSxpQ0FBQSxDQUNBLHFEQUFBLENBR0EsY0FBQSxDQURBLG9CQUFBLENBREEsaUJDMkJKLENEM0VBLCtCQXNESSx1QkN3QkosQ0Q5RUEsc0JBMkRJLGdCQUFBLENBREEsZ0JDd0JKLENEbEZBLHFCQWdFSSxnQkFBQSxDQURBLGVDdUJKLENEdEZBLGlCQXNFSSxrQkNtQkosQ0R6RkEsbUJBK0VJLGtEQUFBLENBSEEsdUJBQUEsQ0FDQSxlQUFBLENBSEEsZUFBQSxDQUNBLHdCQUFBLENBR0EsaUJDbUJKLENEakdBLGVBcUZJLGNDZUosQ0RwR0EsZUF5RkksZ0JBQUEsQ0FDQSxlQ2NKLENEeEdBLGVBOEZJLGNBQUEsQ0FDQSxlQ2FKLENENUdBLGVBbUdJLGlCQ1lKLENEL0dBLGVBdUdJLGlCQ1dKLENEbEhBLGVBMkdJLGdCQ1VKLENEckhBLGNBK0dJLGVDU0osQ0R4SEEsd0dBcUhJLHdCQ1lKLENEaklBLDZDQTZISSxlQ1NKLENETEUseUNBQUEsZUFFSSxnQkNPSixDRFRBLGVBTUksZ0JDTUosQ0RaQSxlQVVJLGlCQ0tKLENEZkEsZUFjSSxpQkNJSixDQUNGLENEcEpBLG9DQXVKSSxtQkNDSixDRHhKQSxvQkEySkksb0JDQUosQ0QzSkEsd0pBcUtJLDhCQUFBLENBREEsOENBQUEsQ0FFQSx3QkFBQSxDQUdBLGtCQUFBLENBRkEsWUFBQSxDQUNBLG9CQ0FKLENEeEtBLDBKQWtMSSxnQ0FBQSxDQUNBLDRCQUFBLENBQ0EsdUJBQUEsQ0FIQSxrQkNDSixDRGxMQSw4QkF3TEksU0NISixDRHJMQSx3QkE4TEksV0FBQSxDQUNBLDhCQUFBLENBQ0EsNEJDTkosQ0QxTEEsMk5Bd01JLG9DQUFBLENBQ0EsZ0NBQUEsQ0FDQSxjQ1BKLENEbk1BLDJLQW9OSSwrQkFBQSxDQUNBLGtCQ1JKLENEN01BLHVCQTJOSSxjQUFBLENBQ0EsYUFBQSxDQUNBLGdCQ1hKLENEbE5BLG9EQW9PSSwwQkFBQSxDQUNBLGtCQUFBLENBQ0EsWUFBQSxDQUNBLGtCQUFBLENBQ0EsY0FBQSxDQUNBLHNCQUFBLENBQ0Esb0JBQUEsQ0FDQSxRQUFBLENBQ0EsU0NkSixDRDlOQSwwREFtUEksb0JDakJKLENEbE9BLDBEQXlQSSw4Q0FBQSxDQUNBLDJDQUFBLENBQ0EsaUJBQUEsQ0FDQSxvQkFBQSxDQUpBLG1CQUFBLENBS0Esa0JBQUEsQ0FDQSxvQkNsQkosQ0Q1T0Esd0pBcVFJLG9CQUFBLENBQ0EsMEJBQUEsQ0FDQSxtQkFBQSxDQUNBLGNDbkJKLENEdUJFLHlDQUFBLHlCQUVJLFdBQUEsQ0FHQSxhQUFBLENBRkEsU0FBQSxDQUNBLHlCQ3BCSixDRGdCQSxpQ0FTSSxlQ3RCSixDQUNGLENEaFFBLDJFQTRSSSxpQ0FBQSxDQUNBLDhDQUFBLENBQ0EsMkNBQUEsQ0FDQSxrQkN0QkosQ0R6UUEsa0JBdVNJLFdBQUEsQ0FKQSxjQUFBLENBR0Esd0JBQUEsQ0FEQSxjQUFBLENBREEsU0NwQkosQ0RoUkEsNEJBMlNJLFVDeEJKLENENEJFLHlDQUFBLGtCQUdJLFVBQUEsQ0FDQSxxQkFBQSxDQUZBLFVDeEJKLENBQ0YsQ0QxUkEsNERBd1RJLDhDQUFBLENBRUEsMkNBQUEsQ0FDQSxrQkFBQSxDQUZBLFlDdkJKLENEbFNBLDRJQWtVSSxlQzFCSixDRHhTQSxvQkF1VUkscURBQUEsQ0FEQSxrREFBQSxDQUdBLGFBQUEsQ0FEQSxpQkMxQkosQ0Q5U0EsNERBZ1ZJLFlBQUEsQ0FDQSxhQzlCSixDRG5UQSw0QkFxVkksWUMvQkosQ0R0VEEsK0JBeVZJLGVBQUEsQ0FDQSxnQkNoQ0osQ0QxVEEsb0JBOFZJLGtCQ2pDSixDRDdUQSxvQkFrV0ksY0FBQSxDQUNBLGVBQUEsQ0FFQSxtQkFBQSxDQURBLGtCQUFBLENBRUEsb0JDbENKLENEcFVBLG9DQTBXSSxZQ25DSixDRHZVQSxrQ0E4V0ksbUJDcENKLENEMVVBLHNDQWtYSSxlQ3JDSixDRDdVQSxrQkF3WEksd0JBQUEsQ0FDQSxlQ3hDSixDRGpWQSx5QkE4WEksUUFBQSxDQURBLGlCQ3hDSixDRHJWQSw4QkFtWUksOENBQUEsQ0FFQSxhQUFBLENBREEsZ0JDekNKLENEM1ZBLGVBMFlJLGVDM0NKLENEL1ZBLDRDQXlZSSxpQ0N0Q0osQ0RuV0EsMEJBbVpJLGVBQUEsQ0FDQSxtQkM3Q0osQ0R2V0EsaUdBa2FJLDJDQUFBLENBQ0EsZUFBQSxDQUVBLG9CQUFBLENBTkEsbUJBQUEsQ0FEQSxpQkFBQSxDQUdBLG1CQUFBLENBR0EsY0FBQSxDQUpBLFlDM0NKLENEclhBLDBEQTRhSSwwQkFBQSxDQUNBLDhDQUFBLENBRkEsaUJDL0NKLENENVhBLGtCQWliSSxhQ2xESixDRC9YQSxpQ0FxYkksVUNuREosQ0RsWUEsbUNBMmJJLCtIQUFBLENBRUEsdURBQUEsQ0FFQSwyQkFBQSxDQURBLCtCQUFBLENBRUEsdUJDdkRKLENEellBLDZDQW9jSSw2QkN4REosQ0Q1WUEsK0RBNGNJLGlCQUFBLENBREEscUJBQUEsQ0FFQSxpQkMzREosQ0RsWkEsMkVBa2RJLG9CQzVESixDRHRaQSw4QkFzZEksa0JDN0RKLENEelpBLCtFQTJkSSw4QkM5REosQ0Q3WkEsK0NBdWVJLDRCQUFBLENBRUEsbUNBQUEsQ0FOQSxlQUFBLENBS0Esa0NBQUEsQ0FSQSxXQUFBLENBVUEsZUFBQSxDQVJBLFdBQUEsQ0FJQSxVQUFBLENBRkEsaUJBQUEsQ0FDQSxTQUFBLENBTUEsdUJBQUEsQ0FWQSxVQ3JESixDRDVhQSw0Q0FzZkksMEJBQUEsQ0FIQSxrQkFBQSxDQUhBLFdBQUEsQ0FRQSxlQUFBLENBTkEsV0FBQSxDQUtBLFdBQUEsQ0FIQSxpQkFBQSxDQUNBLFVBQUEsQ0FKQSxVQ3pESixDRG9FRSx5Q0FBQSwwREFJSSxVQ2xFSixDQUNGLENEL2JBLDhCQXVnQkksYUFBQSxDQUNBLGFDckVKLENEbmNBLDZCQThnQkksUUN4RUosQ0R0Y0EsZUFzaEJJLHdCQUFBLENBRkEsV0FBQSxDQUNBLDBCQUFBLENBRUEsZ0JDM0VKLENENWNBLGlCQTZoQkksOEJBQUEsQ0FEQSwyQ0FBQSxDQUVBLFVBQUEsQ0FIQSxlQ3pFSixDRGxkQSxtQkFraUJJLGFDN0VKLENEcmRBLGtDQXlpQkksMkNBQUEsQ0FEQSxXQUFBLENBREEsY0M1RUosQ0QzZEEsbUJBOGlCSSxhQUFBLENBREEsUUFBQSxDQUVBLGVDL0VKLENEaGVBLHNEQW9qQkksYUFBQSxDQUNBLGtCQ2hGSixDRHJlQSx1QkE2akJJLHVCQUFBLENBREEsZUFBQSxDQUZBLE1BQUEsQ0FJQSxpQkFBQSxDQUxBLGVBQUEsQ0FFQSxpQkM5RUosQ0Q3ZUEsdUJBc2tCSSw4Q0FBQSxDQUNBLHVCQUFBLENBQ0EsaUJBQUEsQ0FKQSxpQkFBQSxDQURBLG1CQUFBLENBREEsd0JBQUEsQ0FHQSxtQkMvRUosQ0R0ZkEsaUJBNGtCSSxlQUFBLENBRUEsaUJDbkZKLENEM2ZBLGdDQTZrQkksdUJDL0VKLENEOWZBLHVGQTZsQkksaUJBQUEsQ0FEQSw0QkN0RkosQ0R0Z0JBLGdCQWttQkksb0RBQUEsQ0FDQSwyQ0FBQSxDQUNBLDJDQUFBLENBSEEseUJBQUEsQ0FJQSxtQkN4RkosQ0Q3Z0JBLGdCQTRtQkkseUJBQUEsQ0FGQSxjQUFBLENBQ0EsYUFBQSxDQUZBLG1CQ3RGSixDRG5oQkEscUJBbW5CSSxlQUFBLENBREEseUJBQUEsQ0FFQSxRQUFBLENBQ0EsU0M1RkosQ0R6aEJBLHFCQTZuQkksVUNqR0osQ0Q1aEJBLG1DQWlvQkksaUNDbEdKLENEL2hCQSwyQ0Fzb0JJLGlDQUFBLENBREEsMkNDbEdKLENEbmlCQSw2Q0Eyb0JJLDhCQUFBLENBREEsMkNDbkdKLENEdmlCQSx3Q0FncEJJLDhCQUFBLENBREEsMkNBQUEsQ0FHQSx1QkFBQSxDQURBLHlCQ3BHSixDRDdpQkEsc0RBc3BCSSxpQ0N0R0osQ0RoakJBLG1CQTBwQkksMEJBQUEsQ0FFQSxXQUFBLENBREEsZUN0R0osQ0RyakJBLDZCQWdxQkksMEJBQUEsQ0FDQSxVQ3hHSixDRDJHRSx5Q0FBQSxtQkFFSSw0QkN6R0osQ0FDRixDRDlqQkEsZ0NBK3FCSSxpQkFBQSxDQURBLHVCQzNHSixDRG5rQkEsZ0JBbXJCSSxTQzdHSixDRHRrQkEsZ0JBdXJCSSxRQzlHSixDRHprQkEsb0JBNnJCSSwyQkFBQSxDQUNBLDhDQUFBLENBQ0EsMkNBQUEsQ0FFQSxhQUFBLENBREEsY0NoSEosQ0RobEJBLHVDQXFzQkksWUNsSEosQ0RubEJBLHNDQXlzQkksZUNuSEosQ0R1SEUsYUFDRSxNQUNFLFVDckhKLENEbUhBLG1CQU1JLHNCQ3RISixDRGdIQSwwQ0FXSSxZQ3ZISixDRDRHQSxvQkFlSSxXQUFBLENBQ0EsU0N4SEosQ0R3R0EsZ0NBb0JJLDJCQ3pISixDRHFHQSw4QkF3QkksNEJDMUhKLENEa0dBLGNBNEJJLG9CQzNISixDRCtGQSxjQWlDSSxTQUFBLENBREEsUUMzSEosQ0QyRkEsZUFxQ0ksa0RDN0hKLENEd0ZBLGlCQXlDSSw4Q0M5SEosQ0RxRkEscUZBNkNJLGtCQzNISixDRDhFQSxxQkFpREksb0JDNUhKLENBQ0YiLCJmaWxlIjoic3R5bGUubGVzcyJ9 */";
  styleInject(css_248z$3);

  function diff$1(obj1 = {}, obj2 = {}, exclude) {
      var r = {};
      if (!exclude)
          exclude = [];
      for (var prop in obj1) {
          if (obj1.hasOwnProperty(prop) && prop != '__proto__') {
              if (exclude.indexOf(obj1[prop]) == -1) {
                  if (!obj2.hasOwnProperty(prop))
                      r[prop] = obj1[prop];
                  else if (obj1[prop] === Object(obj1[prop])) {
                      var difference = diff$1(obj1[prop], obj2[prop]);
                      if (Object.keys(difference).length > 0)
                          r[prop] = difference;
                  }
                  else if (obj1[prop] !== obj2[prop]) {
                      if (obj1[prop] === undefined)
                          r[prop] = 'undefined';
                      if (obj1[prop] === null)
                          r[prop] = null;
                      else if (typeof obj1[prop] === 'function')
                          r[prop] = 'function';
                      else if (typeof obj1[prop] === 'object')
                          r[prop] = 'object';
                      else
                          r[prop] = obj1[prop];
                  }
              }
          }
      }
      return r;
  }

  class Logger {
      constructor(options = {}) {
          this.values = [[]];
          this.options = Object.assign(Object.assign({}, Logger.defaultOptions), options);
      }
      setOptions(options) {
          this.options = Object.assign(Object.assign({}, this.options), options);
      }
      log() {
          if (isEmpty(arguments)) {
              return;
          }
          let record;
          if (this.options.diff) {
              record = [...values(arguments), ...values(arguments).map((argument, i) => diff$1(argument || {}, this.values[this.values.length - 1][i] || {}))];
          }
          else {
              record = [...values(arguments)];
          }
          this.values.push(record);
      }
      print() {
          console.table(this.values);
      }
      reset() {
          this.values = [[]];
      }
      getValues() {
          return this.values;
      }
  }
  Logger.defaultOptions = {
      diff: true
  };

  class Statistics {
      static getTotalValidations(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          return values === null || values === void 0 ? void 0 : values.length;
      }
      static getAverageDuration(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          return Statistics.getTotalDuration(values) / Statistics.getTotalValidations(values);
      }
      static getMinDuration(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          return Math.min(...values.map(e => e.duration));
      }
      static getMaxDuration(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          return Math.max(...values.map(e => e.duration));
      }
      static getTotalDuration(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          return values.reduce((sum, e) => sum + e.duration, 0);
      }
      static getDurationStandardDeviation(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          const mean = values.reduce((sum, e) => sum + e.duration, 0) / 2;
          const squaredDifferences = values.map(e => Math.pow((e.duration - mean), 2));
          const variance = squaredDifferences.reduce((sum, e) => sum + e, 0) / values.length;
          return Math.sqrt(variance);
      }
      static getDurationMediana(values = []) {
          if (!Statistics.validateValues(values)) {
              return 0;
          }
          const sortedValues = values.sort((a, b) => a.duration - b.duration);
          const middle = Math.floor(sortedValues.length / 2);
          if (sortedValues.length % 2 === 0) {
              return (sortedValues[middle - 1].duration + sortedValues[middle].duration) / 2;
          }
          else {
              return sortedValues[middle].duration;
          }
      }
      static validateValues(values = []) {
          if (!values || values.length === 0) {
              return false;
          }
          return true;
      }
      static getBasicStats(values = []) {
          return {
              totalValidations: Statistics.getTotalValidations(values),
              totalDuration: Statistics.getTotalDuration(values),
              minDuration: Statistics.getMinDuration(values),
              maxDuration: Statistics.getMaxDuration(values),
              avgDuration: Statistics.getAverageDuration(values),
              durationMediana: Statistics.getDurationMediana(values),
              durationStandardDeviation: Statistics.getDurationStandardDeviation(values),
          };
      }
  }

  class SanitizerEvent {
      constructor(params) {
          this.date = new Date();
          this.interfaceName = String(params.interfaceName);
          this.object = params.object;
          this.eventType = params.eventType;
          this.extra = params.extra || {};
      }
  }

  var SanitizerEventTypes = {
      VALIDATION_START: 'VALIDATION_START',
      SCHEMA_NOT_FOUND: 'SCHEMA_NOT_FOUND',
      VALIDATION_ERROR: 'VALIDATION_ERROR',
      VALIDATION_SUCCESS: 'VALIDATION_SUCCESS',
  };

  const logger = new Logger();
  logger.setOptions({ diff: false });
  class Diagnostics {
      static enable() {
          Diagnostics.reset();
          Diagnostics.enabled = true;
      }
      static disable() {
          Diagnostics.reset();
          Diagnostics.enabled = false;
      }
      static log(params) {
          if (!Diagnostics.enabled) {
              return;
          }
          logger.log(new SanitizerEvent(params));
      }
      static values(params) {
          if (!Diagnostics.enabled) {
              return [];
          }
          const values = !(params === null || params === void 0 ? void 0 : params.filter) ? flatten(logger.getValues()) : Diagnostics.filter(params === null || params === void 0 ? void 0 : params.filter);
          return Diagnostics.output({ format: params === null || params === void 0 ? void 0 : params.format, data: values });
      }
      static reset() {
          logger.reset();
      }
      static errors(params) {
          if (!Diagnostics.enabled) {
              return [];
          }
          const errors = Diagnostics.filter(Object.assign(Object.assign({}, (params === null || params === void 0 ? void 0 : params.filter) || {}), { eventType: [SanitizerEventTypes.VALIDATION_ERROR, SanitizerEventTypes.SCHEMA_NOT_FOUND] }));
          const mappedErrors = (params === null || params === void 0 ? void 0 : params.mapFn) ? errors.map(params === null || params === void 0 ? void 0 : params.mapFn) : errors;
          return Diagnostics.output({ format: params === null || params === void 0 ? void 0 : params.format, data: mappedErrors });
      }
      static getAmendments(params) {
          if (!Diagnostics.enabled) {
              return null;
          }
          const pairs = Diagnostics.getPairs({ filter: Object.assign({ eventType: [SanitizerEventTypes.VALIDATION_START, SanitizerEventTypes.VALIDATION_SUCCESS] }, params === null || params === void 0 ? void 0 : params.filter) });
          const diffs = map((pair) => {
              var _a, _b, _c, _d, _e, _f;
              return (params === null || params === void 0 ? void 0 : params.shorthand) === true ?
                  {
                      interfaceName: pair[0].interfaceName,
                      diff: diff((_a = pair[1]) === null || _a === void 0 ? void 0 : _a.object, (_b = pair[0]) === null || _b === void 0 ? void 0 : _b.object),
                      startDate: pair[0].date,
                      endDate: pair[1].date,
                      get duration() { return pair[1].date.getTime() - pair[0].date.getTime(); },
                      result: pair[1].eventType,
                  } :
                  {
                      originalObject: (_c = pair[0]) === null || _c === void 0 ? void 0 : _c.object,
                      amendedObject: (_d = pair[1]) === null || _d === void 0 ? void 0 : _d.object,
                      diff: diff((_e = pair[1]) === null || _e === void 0 ? void 0 : _e.object, (_f = pair[0]) === null || _f === void 0 ? void 0 : _f.object),
                      startDate: pair[0].date,
                      endDate: pair[1].date,
                      get duration() { return pair[1].date.getTime() - pair[0].date.getTime(); },
                      result: pair[1].eventType,
                  };
          }, pairs);
          return Diagnostics.output({ format: params === null || params === void 0 ? void 0 : params.format, data: diffs });
      }
      static diff(params) {
          return Diagnostics.getAmendments({ filter: Object.assign({ eventType: [SanitizerEventTypes.VALIDATION_START, SanitizerEventTypes.VALIDATION_SUCCESS] }, params === null || params === void 0 ? void 0 : params.filter) });
      }
      static validations(params) {
          return Diagnostics.getAmendments(Object.assign({ filter: Object.assign({ eventType: undefined }, params === null || params === void 0 ? void 0 : params.filter) }, params));
      }
      static getPairs(params) {
          const events = Diagnostics.filter(params === null || params === void 0 ? void 0 : params.filter);
          const pairs = events.reduce((acc, event) => {
              var _a, _b;
              if (event.eventType === SanitizerEventTypes.VALIDATION_START) {
                  acc.push([]);
                  acc[acc.length - 1].push(event);
              }
              else if (((_a = acc[acc.length - 1][0]) === null || _a === void 0 ? void 0 : _a.interfaceName) === event.interfaceName && acc[acc.length - 1].length === 1) {
                  acc[acc.length - 1].push(event);
              }
              else if (((_b = acc[acc.length - 1][0]) === null || _b === void 0 ? void 0 : _b.interfaceName) !== event.interfaceName && acc[acc.length - 1].length === 1) {
                  acc.pop();
              }
              return acc;
          }, []);
          return filter((pair) => pair.length === 2, pairs);
      }
      static filter(filter) {
          if (filter) {
              return (Diagnostics.values() || []).filter((event) => {
                  const conditions = [];
                  if (filter.interfaceName) {
                      conditions.push(event.interfaceName === filter.interfaceName);
                  }
                  if (filter.eventType) {
                      conditions.push(is(String, filter.eventType) && event.eventType === filter.eventType ||
                          is(Array, filter.eventType) && filter.eventType.includes(event.eventType));
                  }
                  return all(equals(true))(conditions);
              });
          }
          else {
              return Diagnostics.values();
          }
      }
      static output(params) {
          if ((params === null || params === void 0 ? void 0 : params.format) === 'csv') {
              csvParser.opts.fields = null;
              return csvParser.parse(params === null || params === void 0 ? void 0 : params.data);
          }
          return (params === null || params === void 0 ? void 0 : params.data) || [];
      }
      static getStats(params) {
          return Diagnostics.output({ data: Statistics.getBasicStats(Diagnostics.validations()), format: params === null || params === void 0 ? void 0 : params.format });
      }
  }
  Diagnostics.enabled = false;
  Diagnostics.formatDuration = (duration) => (`${new Date(duration).getMinutes()}:${new Date(duration).getSeconds()}:${new Date(duration).getMilliseconds()}`);

  const isPrimitive = value => {
    if (value === null) {
      return true
    }

    if (typeof value === 'object' || typeof value === 'function') {
      return false
    }

    return true
  };

  function isFunctionLikeString(s) {
    // Heuristic: common function source patterns
    // - function foo(...) { ... }
    // - (args) => ...
    // - args => ...
    // - async function ...
    // - class methods are not considered
    // We'll consider it function-like if it contains 'function' keyword at start,
    // or contains '=>' token, or starts with '(' and contains '=>'
    if (typeof s !== 'string') return false;
    const trimmed = s.trim();

    if (trimmed.length === 0) return false;
    if (/^function\b/.test(trimmed)) return true;           // function declaration/expression
    if (/^async function\b/.test(trimmed)) return true;     // async function
    if (trimmed.includes('=>')) return true;                // arrow function
    // some engines output "function name() { [native code] }" or similar; treat as function-like
    if (/^\[native code\]$/.test(trimmed)) return true;

    return false;
  }

  function isNumber(string) {
    return /^[0-9\.]+$/.test(String(string))
  }

  function isBoolean(string) {
    return String(string).toLowerCase() === 'true' || String(string).toLowerCase() === 'false'
  }

  function isObject(string) {
    try {
      const obj = JSON.parse(string);
      return obj !== null && typeof obj === 'object'
    } catch {
      return false
    }
  }

  const setOnLoad = (fn) => {
    setVar('onLoad', String(fn));
  };

  const getElementByXPath = (xpath) => {
    if (isEmpty(xpath) || !is(String, xpath)) {
      return null
    }
    let result;
    let xpath1 = xpath;
    do {
      // 1. Evaluate the XPath expression
      result = document.evaluate(
        xpath1,                            // The XPath string to evaluate
        document,                         // The context node (usually the entire document)
        null,                             // Namespace resolver (not needed for simple HTML)
        XPathResult.FIRST_ORDERED_NODE_TYPE, // Result type: we want the first matching element
        null                              // The result object to reuse (start with null)
      );

      // 2. Extract the element
      // singleNodeValue contains the node found when using FIRST_ORDERED_NODE_TYPE
      if (result.singleNodeValue) {
        return result.singleNodeValue;
      }

      xpath1 = xpath1.substring(0, xpath1.lastIndexOf('/'));
    }while (!isEmpty(xpath1) && !result?.singleNodeValue)
  };

  const localStorageKey = 'dev-tools';

  const reviveVar = (value) => {
    if (isNumber(value)) {
      return Number(value);
    } else if (isBoolean(value)) {
      return String(value).toLowerCase() === 'true'
    } else if (isObject(value) || typeof value === 'object') {
      return mapObjIndexed(reviveVar, isObject(value) ? JSON.parse(value) : value);
    } else if (isFunctionLikeString(value)){
      const wrapped = `(${value})`;
      return eval(wrapped);
    } else {
      return value
    }
  };

  const setVar$1 = (varName, value) => {
    if (!/^[a-z_A-Z0-9]+$/.test(varName)) {
      throw new Error(`${varName} is a not a valid variable name`)
    }

    const vars = localStorage.getItem(localStorageKey);
    const varsObj = JSON.parse(vars) || {};
    let adjustedValue = { type: typeof value };

    if (isPrimitive(value)) {
      adjustedValue = { ...adjustedValue, value: String(value) };
    } if (typeof value === 'function') {
      adjustedValue = { ...adjustedValue, value: value.toString() };
    } else {
      const seen = new WeakSet();

      const replacer = (key, v) => {
        if (typeof v === 'function') {
          return v.toString();
        }
        if (typeof v === 'object' && v !== null) {
          if (seen.has(v)) {
            return '[Circular]';
          }
          seen.add(v);
        }
        return v;
      };

      adjustedValue = { ...adjustedValue, value: JSON.stringify(value, replacer) };
    }

    varsObj[String(varName)] = adjustedValue;
    localStorage.setItem(localStorageKey, JSON.stringify(varsObj));
    window[varName] = value;
  };

  const getVars = () => {
    const vars = localStorage.getItem(localStorageKey);
    const varsObj = JSON.parse(vars);
    const varsParsed = [];

    mapObjIndexed((variable, varName) => {
      switch (variable.type) {
        case 'object':
          varsParsed.push({ name: varName, value: reviveVar(variable.value) });
          break;

        case 'number':
          varsParsed.push({ name: varName, value: Number(variable.value) });
          break;

        case 'boolean':
          varsParsed.push({ name: varName, value: variable.value === 'true' });
          break;
        default:
          varsParsed.push({ name: varName, value: variable.value });
      }
    }, varsObj);

    return varsParsed
  };

  const deleteVar = varName => {
    const vars = localStorage.getItem(localStorageKey);
    const varsObj = JSON.parse(vars);

    delete varsObj[varName];
    localStorage.setItem(localStorageKey, JSON.stringify(varsObj));
    delete window[varName];
  };

  const clearVars = () => {
    const vars = localStorage.getItem(localStorageKey);
    const varsObj = JSON.parse(vars);

    mapObjIndexed((variable, varName) => {
      delete window[varName];
    }, varsObj);
    localStorage.removeItem(localStorageKey);
  };

  var PROJECT_PATH = "D:/Users/m_botezatu/projects/equities-client-2";
  var SRC_PATH = "src";
  var SERVER_PORT = "8080";

  const stub = (path, varName) => {
      return fetch(`http://localhost:${SERVER_PORT}/stub/${encodeURIComponent(`${PROJECT_PATH}/${SRC_PATH}/${path}`)}`)
          .then(result => {
          if (!isNil(result) && !isEmpty(result)) {
              return result.json();
          }
          return null;
      }).then(result => {
          if (!isNil(result) && !isEmpty(result) && !isNil(varName)) {
              setVar$1(String(varName), result);
          }
          return result;
      })
          .catch(e => {
          throw new Error(e);
      });
  };

  class Storage {
      constructor() {
          this.log = (logsKey, value) => {
              return fetch(`http://localhost:${SERVER_PORT}/storage/log/${encodeURIComponent(`${logsKey}`)}`, {
                  method: 'POST',
                  body: JSON.stringify(value),
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  mode: 'no-cors'
              }).then(result => {
                  if (!isNil(result) && !isEmpty(result)) {
                      return result.json();
                  }
                  return null;
              }).then(result => {
                  return result;
              })
                  .catch(e => {
              });
          };
          this.clear = (key) => {
              return fetch(`http://localhost:${SERVER_PORT}/storage/clear/${encodeURIComponent(`${key}`)}`)
                  .then(result => {
                  if (!isNil(result) && !isEmpty(result)) {
                      return result.json();
                  }
                  return null;
              }).then(result => {
                  return result;
              })
                  .catch(e => {
                  throw new Error(e);
              });
          };
          this.get = (logsKey, criteria) => {
              return fetch(`http://localhost:${SERVER_PORT}/storage/get/${encodeURIComponent(`${logsKey}`)}/${encodeURIComponent(`${JSON.stringify(criteria)}`)}`).then(result => {
                  if (!isNil(result) && !isEmpty(result)) {
                      return result.json();
                  }
                  return null;
              }).then(result => {
                  return result;
              })
                  .catch(e => {
                  throw new Error(e);
              });
          };
      }
  }
  var storage = new Storage();

  function findProp(obj, propName) {
      const results = [];
      if (obj == null || typeof propName !== 'string' || propName.length === 0) {
          return results;
      }
      const seen = new WeakSet();
      const stack = [{ current: obj, path: [] }];
      while (stack.length) {
          const { current, path } = stack.pop();
          if (current && (typeof current === 'object' || typeof current === 'function')) {
              if (seen.has(current))
                  continue;
              seen.add(current);
              const entries = Array.isArray(current)
                  ? current.map((v, i) => [String(i), v])
                  : Object.keys(current).map(k => [k, current[k]]);
              for (let i = 0; i < entries.length; i++) {
                  const [key, val] = entries[i];
                  const keyPathSegment = Array.isArray(current) ? Number(key) : key;
                  const newPath = path.concat(keyPathSegment);
                  if (key.toLowerCase().indexOf(propName.toLowerCase()) !== -1) {
                      results.push({
                          key,
                          value: val,
                          path: newPath
                      });
                  }
                  if (val && (typeof val === 'object' || typeof val === 'function')) {
                      stack.push({ current: val, path: newPath });
                  }
              }
          }
      }
      return results;
  }
  const findMatch = (obj1, obj2, path$1 = []) => {
      let result = null;
      const search = (obj, path = []) => {
          if (!is(Object, obj) || isNil(obj))
              return;
          if (whereEq(obj2, obj)) {
              if (!result) {
                  result = { path, value: obj };
                  return;
              }
          }
          forEachObjIndexed((value, key) => {
              if (is(Object, value) && !isNil(value)) {
                  search(value, [...path, key]);
              }
          }, obj);
      };
      search(path(path$1, obj1));
      return result;
  };
  const findMatches = (obj1, obj2) => {
      let results = [];
      const search = (obj, path = []) => {
          if (!is(Object, obj) || isNil(obj))
              return;
          if (whereEq(obj2, obj)) {
              results.push({ path, value: obj });
          }
          forEachObjIndexed((value, key) => {
              if (is(Object, value) && !isNil(value)) {
                  search(value, [...path, isNaN(key) ? key : Number(key)]);
              }
          }, obj);
      };
      search(obj1);
      return results;
  };

  var _$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    diff: diff$1,
    findMatch: findMatch,
    findMatches: findMatches,
    findProp: findProp
  });

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  let z = {}, J;
  function F(e = {}) {
    z = {
      animate: true,
      allowClose: true,
      overlayClickBehavior: "close",
      overlayOpacity: 0.7,
      smoothScroll: false,
      disableActiveInteraction: false,
      showProgress: false,
      stagePadding: 10,
      stageRadius: 5,
      popoverOffset: 10,
      showButtons: ["next", "previous", "close"],
      disableButtons: [],
      overlayColor: "#000",
      ...e
    };
  }
  function s(e) {
    return e ? z[e] : z;
  }
  function le(e) {
    J = e;
  }
  function _() {
    return J;
  }
  let I = {};
  function N(e, o) {
    I[e] = o;
  }
  function L(e) {
    var o;
    (o = I[e]) == null || o.call(I);
  }
  function de() {
    I = {};
  }
  function O(e, o, t, i) {
    return (e /= i / 2) < 1 ? t / 2 * e * e + o : -t / 2 * (--e * (e - 2) - 1) + o;
  }
  function U(e) {
    const o = 'a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input[type="text"]:not([disabled]), input[type="radio"]:not([disabled]), input[type="checkbox"]:not([disabled]), select:not([disabled])';
    return e.flatMap((t) => {
      const i = t.matches(o), d = Array.from(t.querySelectorAll(o));
      return [...i ? [t] : [], ...d];
    }).filter((t) => getComputedStyle(t).pointerEvents !== "none" && ve(t));
  }
  function ee(e) {
    if (!e || ue(e))
      return;
    const o = s("smoothScroll"), t = e.offsetHeight > window.innerHeight;
    e.scrollIntoView({
      // Removing the smooth scrolling for elements which exist inside the scrollable parent
      // This was causing the highlight to not properly render
      behavior: !o || pe(e) ? "auto" : "smooth",
      inline: "center",
      block: t ? "start" : "center"
    });
  }
  function pe(e) {
    if (!e || !e.parentElement)
      return;
    const o = e.parentElement;
    return o.scrollHeight > o.clientHeight;
  }
  function ue(e) {
    const o = e.getBoundingClientRect();
    return o.top >= 0 && o.left >= 0 && o.bottom <= (window.innerHeight || document.documentElement.clientHeight) && o.right <= (window.innerWidth || document.documentElement.clientWidth);
  }
  function ve(e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
  }
  let D = {};
  function k(e, o) {
    D[e] = o;
  }
  function l(e) {
    return e ? D[e] : D;
  }
  function X() {
    D = {};
  }
  function fe(e, o, t, i) {
    let d = l("__activeStagePosition");
    const n = d || t.getBoundingClientRect(), f = i.getBoundingClientRect(), w = O(e, n.x, f.x - n.x, o), r = O(e, n.y, f.y - n.y, o), v = O(e, n.width, f.width - n.width, o), g = O(e, n.height, f.height - n.height, o);
    d = {
      x: w,
      y: r,
      width: v,
      height: g
    }, oe(d), k("__activeStagePosition", d);
  }
  function te(e) {
    if (!e)
      return;
    const o = e.getBoundingClientRect(), t = {
      x: o.x,
      y: o.y,
      width: o.width,
      height: o.height
    };
    k("__activeStagePosition", t), oe(t);
  }
  function he() {
    const e = l("__activeStagePosition"), o = l("__overlaySvg");
    if (!e)
      return;
    if (!o) {
      console.warn("No stage svg found.");
      return;
    }
    const t = window.innerWidth, i = window.innerHeight;
    o.setAttribute("viewBox", `0 0 ${t} ${i}`);
  }
  function ge(e) {
    const o = we(e);
    document.body.appendChild(o), re(o, (t) => {
      t.target.tagName === "path" && L("overlayClick");
    }), k("__overlaySvg", o);
  }
  function oe(e) {
    const o = l("__overlaySvg");
    if (!o) {
      ge(e);
      return;
    }
    const t = o.firstElementChild;
    if ((t == null ? void 0 : t.tagName) !== "path")
      throw new Error("no path element found in stage svg");
    t.setAttribute("d", ie(e));
  }
  function we(e) {
    const o = window.innerWidth, t = window.innerHeight, i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    i.classList.add("driver-overlay", "driver-overlay-animated"), i.setAttribute("viewBox", `0 0 ${o} ${t}`), i.setAttribute("xmlSpace", "preserve"), i.setAttribute("xmlnsXlink", "http://www.w3.org/1999/xlink"), i.setAttribute("version", "1.1"), i.setAttribute("preserveAspectRatio", "xMinYMin slice"), i.style.fillRule = "evenodd", i.style.clipRule = "evenodd", i.style.strokeLinejoin = "round", i.style.strokeMiterlimit = "2", i.style.zIndex = "10000", i.style.position = "fixed", i.style.top = "0", i.style.left = "0", i.style.width = "100%", i.style.height = "100%";
    const d = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return d.setAttribute("d", ie(e)), d.style.fill = s("overlayColor") || "rgb(0,0,0)", d.style.opacity = `${s("overlayOpacity")}`, d.style.pointerEvents = "auto", d.style.cursor = "auto", i.appendChild(d), i;
  }
  function ie(e) {
    const o = window.innerWidth, t = window.innerHeight, i = s("stagePadding") || 0, d = s("stageRadius") || 0, n = e.width + i * 2, f = e.height + i * 2, w = Math.min(d, n / 2, f / 2), r = Math.floor(Math.max(w, 0)), v = e.x - i + r, g = e.y - i, y = n - r * 2, a = f - r * 2;
    return `M${o},0L0,0L0,${t}L${o},${t}L${o},0Z
    M${v},${g} h${y} a${r},${r} 0 0 1 ${r},${r} v${a} a${r},${r} 0 0 1 -${r},${r} h-${y} a${r},${r} 0 0 1 -${r},-${r} v-${a} a${r},${r} 0 0 1 ${r},-${r} z`;
  }
  function me() {
    const e = l("__overlaySvg");
    e && e.remove();
  }
  function ye() {
    const e = document.getElementById("driver-dummy-element");
    if (e)
      return e;
    let o = document.createElement("div");
    return o.id = "driver-dummy-element", o.style.width = "0", o.style.height = "0", o.style.pointerEvents = "none", o.style.opacity = "0", o.style.position = "fixed", o.style.top = "50%", o.style.left = "50%", document.body.appendChild(o), o;
  }
  function j(e) {
    const { element: o } = e;
    let t = typeof o == "function" ? o() : typeof o == "string" ? document.querySelector(o) : o;
    t || (t = ye()), be(t, e);
  }
  function xe() {
    const e = l("__activeElement"), o = l("__activeStep");
    e && (te(e), he(), ae(e, o));
  }
  function be(e, o) {
    var C;
    const i = Date.now(), d = l("__activeStep"), n = l("__activeElement") || e, f = !n || n === e, w = e.id === "driver-dummy-element", r = n.id === "driver-dummy-element", v = s("animate"), g = o.onHighlightStarted || s("onHighlightStarted"), y = (o == null ? void 0 : o.onHighlighted) || s("onHighlighted"), a = (d == null ? void 0 : d.onDeselected) || s("onDeselected"), p = s(), c = l();
    !f && a && a(r ? void 0 : n, d, {
      config: p,
      state: c,
      driver: _()
    }), g && g(w ? void 0 : e, o, {
      config: p,
      state: c,
      driver: _()
    });
    const u = !f && v;
    let h = false;
    _e(), k("previousStep", d), k("previousElement", n), k("activeStep", o), k("activeElement", e);
    const m = () => {
      if (l("__transitionCallback") !== m)
        return;
      const b = Date.now() - i, E = 400 - b <= 400 / 2;
      o.popover && E && !h && u && (Q(e, o), h = true), s("animate") && b < 400 ? fe(b, 400, n, e) : (te(e), y && y(w ? void 0 : e, o, {
        config: s(),
        state: l(),
        driver: _()
      }), k("__transitionCallback", void 0), k("__previousStep", d), k("__previousElement", n), k("__activeStep", o), k("__activeElement", e)), window.requestAnimationFrame(m);
    };
    k("__transitionCallback", m), window.requestAnimationFrame(m), ee(e), !u && o.popover && Q(e, o), n.classList.remove("driver-active-element", "driver-no-interaction"), n.removeAttribute("aria-haspopup"), n.removeAttribute("aria-expanded"), n.removeAttribute("aria-controls"), ((C = o.disableActiveInteraction) != null ? C : s("disableActiveInteraction")) && e.classList.add("driver-no-interaction"), e.classList.add("driver-active-element"), e.setAttribute("aria-haspopup", "dialog"), e.setAttribute("aria-expanded", "true"), e.setAttribute("aria-controls", "driver-popover-content");
  }
  function Ce() {
    var e;
    (e = document.getElementById("driver-dummy-element")) == null || e.remove(), document.querySelectorAll(".driver-active-element").forEach((o) => {
      o.classList.remove("driver-active-element", "driver-no-interaction"), o.removeAttribute("aria-haspopup"), o.removeAttribute("aria-expanded"), o.removeAttribute("aria-controls");
    });
  }
  function M() {
    const e = l("__resizeTimeout");
    e && window.cancelAnimationFrame(e), k("__resizeTimeout", window.requestAnimationFrame(xe));
  }
  function Pe(e) {
    var r;
    if (!l("isInitialized") || !(e.key === "Tab" || e.keyCode === 9))
      return;
    const i = l("__activeElement"), d = (r = l("popover")) == null ? void 0 : r.wrapper, n = U([
      ...d ? [d] : [],
      ...i ? [i] : []
    ]), f = n[0], w = n[n.length - 1];
    if (e.preventDefault(), e.shiftKey) {
      const v = n[n.indexOf(document.activeElement) - 1] || w;
      v == null || v.focus();
    } else {
      const v = n[n.indexOf(document.activeElement) + 1] || f;
      v == null || v.focus();
    }
  }
  function ne(e) {
    var t;
    ((t = s("allowKeyboardControl")) == null || t) && (e.key === "Escape" ? L("escapePress") : e.key === "ArrowRight" ? L("arrowRightPress") : e.key === "ArrowLeft" && L("arrowLeftPress"));
  }
  function re(e, o, t) {
    const i = (n, f) => {
      const w = n.target;
      e.contains(w) && ((!t || t(w)) && (n.preventDefault(), n.stopPropagation(), n.stopImmediatePropagation()), f == null || f(n));
    };
    document.addEventListener("pointerdown", i, true), document.addEventListener("mousedown", i, true), document.addEventListener("pointerup", i, true), document.addEventListener("mouseup", i, true), document.addEventListener(
      "click",
      (n) => {
        i(n, o);
      },
      true
    );
  }
  function ke() {
    window.addEventListener("keyup", ne, false), window.addEventListener("keydown", Pe, false), window.addEventListener("resize", M), window.addEventListener("scroll", M);
  }
  function Se() {
    window.removeEventListener("keyup", ne), window.removeEventListener("resize", M), window.removeEventListener("scroll", M);
  }
  function _e() {
    const e = l("popover");
    e && (e.wrapper.style.display = "none");
  }
  function Q(e, o) {
    var b, P;
    let t = l("popover");
    t && document.body.removeChild(t.wrapper), t = Le(), document.body.appendChild(t.wrapper);
    const {
      title: i,
      description: d,
      showButtons: n,
      disableButtons: f,
      showProgress: w,
      nextBtnText: r = s("nextBtnText") || "Next &rarr;",
      prevBtnText: v = s("prevBtnText") || "&larr; Previous",
      progressText: g = s("progressText") || "{current} of {total}"
    } = o.popover || {};
    t.nextButton.innerHTML = r, t.previousButton.innerHTML = v, t.progress.innerHTML = g, i ? (t.title.innerHTML = i, t.title.style.display = "block") : t.title.style.display = "none", d ? (t.description.innerHTML = d, t.description.style.display = "block") : t.description.style.display = "none";
    const y = n || s("showButtons"), a = w || s("showProgress") || false, p = (y == null ? void 0 : y.includes("next")) || (y == null ? void 0 : y.includes("previous")) || a;
    t.closeButton.style.display = y.includes("close") ? "block" : "none", p ? (t.footer.style.display = "flex", t.progress.style.display = a ? "block" : "none", t.nextButton.style.display = y.includes("next") ? "block" : "none", t.previousButton.style.display = y.includes("previous") ? "block" : "none") : t.footer.style.display = "none";
    const c = f || s("disableButtons") || [];
    c != null && c.includes("next") && (t.nextButton.disabled = true, t.nextButton.classList.add("driver-popover-btn-disabled")), c != null && c.includes("previous") && (t.previousButton.disabled = true, t.previousButton.classList.add("driver-popover-btn-disabled")), c != null && c.includes("close") && (t.closeButton.disabled = true, t.closeButton.classList.add("driver-popover-btn-disabled"));
    const u = t.wrapper;
    u.style.display = "block", u.style.left = "", u.style.top = "", u.style.bottom = "", u.style.right = "", u.id = "driver-popover-content", u.setAttribute("role", "dialog"), u.setAttribute("aria-labelledby", "driver-popover-title"), u.setAttribute("aria-describedby", "driver-popover-description");
    const h = t.arrow;
    h.className = "driver-popover-arrow";
    const m = ((b = o.popover) == null ? void 0 : b.popoverClass) || s("popoverClass") || "";
    u.className = `driver-popover ${m}`.trim(), re(
      t.wrapper,
      (E) => {
        var B, R, W;
        const T = E.target, A = ((B = o.popover) == null ? void 0 : B.onNextClick) || s("onNextClick"), H = ((R = o.popover) == null ? void 0 : R.onPrevClick) || s("onPrevClick"), $ = ((W = o.popover) == null ? void 0 : W.onCloseClick) || s("onCloseClick");
        if (T.closest(".driver-popover-next-btn"))
          return A ? A(e, o, {
            config: s(),
            state: l(),
            driver: _()
          }) : L("nextClick");
        if (T.closest(".driver-popover-prev-btn"))
          return H ? H(e, o, {
            config: s(),
            state: l(),
            driver: _()
          }) : L("prevClick");
        if (T.closest(".driver-popover-close-btn"))
          return $ ? $(e, o, {
            config: s(),
            state: l(),
            driver: _()
          }) : L("closeClick");
      },
      (E) => !(t != null && t.description.contains(E)) && !(t != null && t.title.contains(E)) && typeof E.className == "string" && E.className.includes("driver-popover")
    ), k("popover", t);
    const x = ((P = o.popover) == null ? void 0 : P.onPopoverRender) || s("onPopoverRender");
    x && x(t, {
      config: s(),
      state: l(),
      driver: _()
    }), ae(e, o), ee(u);
    const C = e.classList.contains("driver-dummy-element"), S = U([u, ...C ? [] : [e]]);
    S.length > 0 && S[0].focus();
  }
  function se() {
    const e = l("popover");
    if (!(e != null && e.wrapper))
      return;
    const o = e.wrapper.getBoundingClientRect(), t = s("stagePadding") || 0, i = s("popoverOffset") || 0;
    return {
      width: o.width + t + i,
      height: o.height + t + i,
      realWidth: o.width,
      realHeight: o.height
    };
  }
  function Z(e, o) {
    const { elementDimensions: t, popoverDimensions: i, popoverPadding: d, popoverArrowDimensions: n } = o;
    return e === "start" ? Math.max(
      Math.min(
        t.top - d,
        window.innerHeight - i.realHeight - n.width
      ),
      n.width
    ) : e === "end" ? Math.max(
      Math.min(
        t.top - (i == null ? void 0 : i.realHeight) + t.height + d,
        window.innerHeight - (i == null ? void 0 : i.realHeight) - n.width
      ),
      n.width
    ) : e === "center" ? Math.max(
      Math.min(
        t.top + t.height / 2 - (i == null ? void 0 : i.realHeight) / 2,
        window.innerHeight - (i == null ? void 0 : i.realHeight) - n.width
      ),
      n.width
    ) : 0;
  }
  function G(e, o) {
    const { elementDimensions: t, popoverDimensions: i, popoverPadding: d, popoverArrowDimensions: n } = o;
    return e === "start" ? Math.max(
      Math.min(
        t.left - d,
        window.innerWidth - i.realWidth - n.width
      ),
      n.width
    ) : e === "end" ? Math.max(
      Math.min(
        t.left - (i == null ? void 0 : i.realWidth) + t.width + d,
        window.innerWidth - (i == null ? void 0 : i.realWidth) - n.width
      ),
      n.width
    ) : e === "center" ? Math.max(
      Math.min(
        t.left + t.width / 2 - (i == null ? void 0 : i.realWidth) / 2,
        window.innerWidth - (i == null ? void 0 : i.realWidth) - n.width
      ),
      n.width
    ) : 0;
  }
  function ae(e, o) {
    const t = l("popover");
    if (!t)
      return;
    const { align: i = "start", side: d = "left" } = (o == null ? void 0 : o.popover) || {}, n = i, f = e.id === "driver-dummy-element" ? "over" : d, w = s("stagePadding") || 0, r = se(), v = t.arrow.getBoundingClientRect(), g = e.getBoundingClientRect(), y = g.top - r.height;
    let a = y >= 0;
    const p = window.innerHeight - (g.bottom + r.height);
    let c = p >= 0;
    const u = g.left - r.width;
    let h = u >= 0;
    const m = window.innerWidth - (g.right + r.width);
    let x = m >= 0;
    const C = !a && !c && !h && !x;
    let S = f;
    if (f === "top" && a ? x = h = c = false : f === "bottom" && c ? x = h = a = false : f === "left" && h ? x = a = c = false : f === "right" && x && (h = a = c = false), f === "over") {
      const b = window.innerWidth / 2 - r.realWidth / 2, P = window.innerHeight / 2 - r.realHeight / 2;
      t.wrapper.style.left = `${b}px`, t.wrapper.style.right = "auto", t.wrapper.style.top = `${P}px`, t.wrapper.style.bottom = "auto";
    } else if (C) {
      const b = window.innerWidth / 2 - (r == null ? void 0 : r.realWidth) / 2, P = 10;
      t.wrapper.style.left = `${b}px`, t.wrapper.style.right = "auto", t.wrapper.style.bottom = `${P}px`, t.wrapper.style.top = "auto";
    } else if (h) {
      const b = Math.min(
        u,
        window.innerWidth - (r == null ? void 0 : r.realWidth) - v.width
      ), P = Z(n, {
        elementDimensions: g,
        popoverDimensions: r,
        popoverPadding: w,
        popoverArrowDimensions: v
      });
      t.wrapper.style.left = `${b}px`, t.wrapper.style.top = `${P}px`, t.wrapper.style.bottom = "auto", t.wrapper.style.right = "auto", S = "left";
    } else if (x) {
      const b = Math.min(
        m,
        window.innerWidth - (r == null ? void 0 : r.realWidth) - v.width
      ), P = Z(n, {
        elementDimensions: g,
        popoverDimensions: r,
        popoverPadding: w,
        popoverArrowDimensions: v
      });
      t.wrapper.style.right = `${b}px`, t.wrapper.style.top = `${P}px`, t.wrapper.style.bottom = "auto", t.wrapper.style.left = "auto", S = "right";
    } else if (a) {
      const b = Math.min(
        y,
        window.innerHeight - r.realHeight - v.width
      );
      let P = G(n, {
        elementDimensions: g,
        popoverDimensions: r,
        popoverPadding: w,
        popoverArrowDimensions: v
      });
      t.wrapper.style.top = `${b}px`, t.wrapper.style.left = `${P}px`, t.wrapper.style.bottom = "auto", t.wrapper.style.right = "auto", S = "top";
    } else if (c) {
      const b = Math.min(
        p,
        window.innerHeight - (r == null ? void 0 : r.realHeight) - v.width
      );
      let P = G(n, {
        elementDimensions: g,
        popoverDimensions: r,
        popoverPadding: w,
        popoverArrowDimensions: v
      });
      t.wrapper.style.left = `${P}px`, t.wrapper.style.bottom = `${b}px`, t.wrapper.style.top = "auto", t.wrapper.style.right = "auto", S = "bottom";
    }
    C ? t.arrow.classList.add("driver-popover-arrow-none") : Ee(n, S, e);
  }
  function Ee(e, o, t) {
    const i = l("popover");
    if (!i)
      return;
    const d = t.getBoundingClientRect(), n = se(), f = i.arrow, w = n.width, r = window.innerWidth, v = d.width, g = d.left, y = n.height, a = window.innerHeight, p = d.top, c = d.height;
    f.className = "driver-popover-arrow";
    let u = o, h = e;
    if (o === "top" ? (g + v <= 0 ? (u = "right", h = "end") : g + v - w <= 0 && (u = "top", h = "start"), g >= r ? (u = "left", h = "end") : g + w >= r && (u = "top", h = "end")) : o === "bottom" ? (g + v <= 0 ? (u = "right", h = "start") : g + v - w <= 0 && (u = "bottom", h = "start"), g >= r ? (u = "left", h = "start") : g + w >= r && (u = "bottom", h = "end")) : o === "left" ? (p + c <= 0 ? (u = "bottom", h = "end") : p + c - y <= 0 && (u = "left", h = "start"), p >= a ? (u = "top", h = "end") : p + y >= a && (u = "left", h = "end")) : o === "right" && (p + c <= 0 ? (u = "bottom", h = "start") : p + c - y <= 0 && (u = "right", h = "start"), p >= a ? (u = "top", h = "start") : p + y >= a && (u = "right", h = "end")), !u)
      f.classList.add("driver-popover-arrow-none");
    else {
      f.classList.add(`driver-popover-arrow-side-${u}`), f.classList.add(`driver-popover-arrow-align-${h}`);
      const m = t.getBoundingClientRect(), x = f.getBoundingClientRect(), C = s("stagePadding") || 0, S = m.left - C < window.innerWidth && m.right + C > 0 && m.top - C < window.innerHeight && m.bottom + C > 0;
      o === "bottom" && S && (x.x > m.x && x.x + x.width < m.x + m.width ? i.wrapper.style.transform = "translateY(0)" : (f.classList.remove(`driver-popover-arrow-align-${h}`), f.classList.add("driver-popover-arrow-none"), i.wrapper.style.transform = `translateY(-${C / 2}px)`));
    }
  }
  function Le() {
    const e = document.createElement("div");
    e.classList.add("driver-popover");
    const o = document.createElement("div");
    o.classList.add("driver-popover-arrow");
    const t = document.createElement("header");
    t.id = "driver-popover-title", t.classList.add("driver-popover-title"), t.style.display = "none", t.innerText = "Popover Title";
    const i = document.createElement("div");
    i.id = "driver-popover-description", i.classList.add("driver-popover-description"), i.style.display = "none", i.innerText = "Popover description is here";
    const d = document.createElement("button");
    d.type = "button", d.classList.add("driver-popover-close-btn"), d.setAttribute("aria-label", "Close"), d.innerHTML = "&times;";
    const n = document.createElement("footer");
    n.classList.add("driver-popover-footer");
    const f = document.createElement("span");
    f.classList.add("driver-popover-progress-text"), f.innerText = "";
    const w = document.createElement("span");
    w.classList.add("driver-popover-navigation-btns");
    const r = document.createElement("button");
    r.type = "button", r.classList.add("driver-popover-prev-btn"), r.innerHTML = "&larr; Previous";
    const v = document.createElement("button");
    return v.type = "button", v.classList.add("driver-popover-next-btn"), v.innerHTML = "Next &rarr;", w.appendChild(r), w.appendChild(v), n.appendChild(f), n.appendChild(w), e.appendChild(d), e.appendChild(o), e.appendChild(t), e.appendChild(i), e.appendChild(n), {
      wrapper: e,
      arrow: o,
      title: t,
      description: i,
      footer: n,
      previousButton: r,
      nextButton: v,
      closeButton: d,
      footerButtons: w,
      progress: f
    };
  }
  function Te() {
    var o;
    const e = l("popover");
    e && ((o = e.wrapper.parentElement) == null || o.removeChild(e.wrapper));
  }
  function Ae(e = {}) {
    F(e);
    function o() {
      s("allowClose") && g();
    }
    function t() {
      const a = s("overlayClickBehavior");
      if (s("allowClose") && a === "close") {
        g();
        return;
      }
      a === "nextStep" && i();
    }
    function i() {
      const a = l("activeIndex"), p = s("steps") || [];
      if (typeof a == "undefined")
        return;
      const c = a + 1;
      p[c] ? v(c) : g();
    }
    function d() {
      const a = l("activeIndex"), p = s("steps") || [];
      if (typeof a == "undefined")
        return;
      const c = a - 1;
      p[c] ? v(c) : g();
    }
    function n(a) {
      (s("steps") || [])[a] ? v(a) : g();
    }
    function f() {
      var x;
      if (l("__transitionCallback"))
        return;
      const p = l("activeIndex"), c = l("__activeStep"), u = l("__activeElement");
      if (typeof p == "undefined" || typeof c == "undefined" || typeof l("activeIndex") == "undefined")
        return;
      const m = ((x = c.popover) == null ? void 0 : x.onPrevClick) || s("onPrevClick");
      if (m)
        return m(u, c, {
          config: s(),
          state: l(),
          driver: _()
        });
      d();
    }
    function w() {
      var m;
      if (l("__transitionCallback"))
        return;
      const p = l("activeIndex"), c = l("__activeStep"), u = l("__activeElement");
      if (typeof p == "undefined" || typeof c == "undefined")
        return;
      const h = ((m = c.popover) == null ? void 0 : m.onNextClick) || s("onNextClick");
      if (h)
        return h(u, c, {
          config: s(),
          state: l(),
          driver: _()
        });
      i();
    }
    function r() {
      l("isInitialized") || (k("isInitialized", true), document.body.classList.add("driver-active", s("animate") ? "driver-fade" : "driver-simple"), ke(), N("overlayClick", t), N("escapePress", o), N("arrowLeftPress", f), N("arrowRightPress", w));
    }
    function v(a = 0) {
      var $, B, R, W, V, q, K, Y;
      const p = s("steps");
      if (!p) {
        console.error("No steps to drive through"), g();
        return;
      }
      if (!p[a]) {
        g();
        return;
      }
      k("__activeOnDestroyed", document.activeElement), k("activeIndex", a);
      const c = p[a], u = p[a + 1], h = p[a - 1], m = (($ = c.popover) == null ? void 0 : $.doneBtnText) || s("doneBtnText") || "Done", x = s("allowClose"), C = typeof ((B = c.popover) == null ? void 0 : B.showProgress) != "undefined" ? (R = c.popover) == null ? void 0 : R.showProgress : s("showProgress"), b = (((W = c.popover) == null ? void 0 : W.progressText) || s("progressText") || "{{current}} of {{total}}").replace("{{current}}", `${a + 1}`).replace("{{total}}", `${p.length}`), P = ((V = c.popover) == null ? void 0 : V.showButtons) || s("showButtons"), E = [
        "next",
        "previous",
        ...x ? ["close"] : []
      ].filter((ce) => !(P != null && P.length) || P.includes(ce)), T = ((q = c.popover) == null ? void 0 : q.onNextClick) || s("onNextClick"), A = ((K = c.popover) == null ? void 0 : K.onPrevClick) || s("onPrevClick"), H = ((Y = c.popover) == null ? void 0 : Y.onCloseClick) || s("onCloseClick");
      j({
        ...c,
        popover: {
          showButtons: E,
          nextBtnText: u ? void 0 : m,
          disableButtons: [...h ? [] : ["previous"]],
          showProgress: C,
          progressText: b,
          onNextClick: T || (() => {
            u ? v(a + 1) : g();
          }),
          onPrevClick: A || (() => {
            v(a - 1);
          }),
          onCloseClick: H || (() => {
            g();
          }),
          ...(c == null ? void 0 : c.popover) || {}
        }
      });
    }
    function g(a = true) {
      const p = l("__activeElement"), c = l("__activeStep"), u = l("__activeOnDestroyed"), h = s("onDestroyStarted");
      if (a && h) {
        const C = !p || (p == null ? void 0 : p.id) === "driver-dummy-element";
        h(C ? void 0 : p, c, {
          config: s(),
          state: l(),
          driver: _()
        });
        return;
      }
      const m = (c == null ? void 0 : c.onDeselected) || s("onDeselected"), x = s("onDestroyed");
      if (document.body.classList.remove("driver-active", "driver-fade", "driver-simple"), Se(), Te(), Ce(), me(), de(), X(), p && c) {
        const C = p.id === "driver-dummy-element";
        m && m(C ? void 0 : p, c, {
          config: s(),
          state: l(),
          driver: _()
        }), x && x(C ? void 0 : p, c, {
          config: s(),
          state: l(),
          driver: _()
        });
      }
      u && u.focus();
    }
    const y = {
      isActive: () => l("isInitialized") || false,
      refresh: M,
      drive: (a = 0) => {
        r(), v(a);
      },
      setConfig: F,
      setSteps: (a) => {
        X(), F({
          ...s(),
          steps: a
        });
      },
      getConfig: s,
      getState: l,
      getActiveIndex: () => l("activeIndex"),
      isFirstStep: () => l("activeIndex") === 0,
      isLastStep: () => {
        const a = s("steps") || [], p = l("activeIndex");
        return p !== void 0 && p === a.length - 1;
      },
      getActiveStep: () => l("activeStep"),
      getActiveElement: () => l("activeElement"),
      getPreviousElement: () => l("previousElement"),
      getPreviousStep: () => l("previousStep"),
      moveNext: i,
      movePrevious: d,
      moveTo: n,
      hasNextStep: () => {
        const a = s("steps") || [], p = l("activeIndex");
        return p !== void 0 && !!a[p + 1];
      },
      hasPreviousStep: () => {
        const a = s("steps") || [], p = l("activeIndex");
        return p !== void 0 && !!a[p - 1];
      },
      highlight: (a) => {
        r(), j({
          ...a,
          popover: a.popover ? {
            showButtons: [],
            showProgress: false,
            progressText: "",
            ...a.popover
          } : void 0
        });
      },
      destroy: () => {
        g(false);
      }
    };
    return le(y), y;
  }

  var css_248z$2 = ".driver-active *,.driver-active .driver-overlay{pointer-events:none}.driver-active .driver-active-element,.driver-active .driver-active-element *,.driver-popover,.driver-popover *{pointer-events:auto}@keyframes animate-fade-in{0%{opacity:0}to{opacity:1}}.driver-fade .driver-overlay{animation:animate-fade-in .2s ease-in-out}.driver-fade .driver-popover{animation:animate-fade-in .2s}.driver-popover{all:unset;background-color:#fff;border-radius:5px;box-shadow:0 1px 10px #0006;box-sizing:border-box;color:#2d2d2d;margin:0;max-width:300px;min-width:250px;padding:15px;position:fixed;right:0;top:0;z-index:1000000000}.driver-popover *{font-family:Helvetica Neue,Inter,ui-sans-serif,Apple Color Emoji,Helvetica,Arial,sans-serif}.driver-popover-title{zoom:1;display:block;font:19px/normal sans-serif;font-weight:700;line-height:1.5;margin:0;position:relative}.driver-popover-close-btn{all:unset;color:#d2d2d2;cursor:pointer;font-size:18px;font-weight:500;height:28px;position:absolute;right:0;text-align:center;top:0;transition:color;transition-duration:.2s;width:32px;z-index:1}.driver-popover-close-btn:focus,.driver-popover-close-btn:hover{color:#2d2d2d}.driver-popover-title[style*=block]+.driver-popover-description{margin-top:5px}.driver-popover-description{zoom:1;font:14px/normal sans-serif;font-weight:400;line-height:1.5;margin-bottom:0}.driver-popover-footer{zoom:1;align-items:center;display:flex;justify-content:space-between;margin-top:15px;text-align:right}.driver-popover-progress-text{zoom:1;color:#727272;font-size:13px;font-weight:400}.driver-popover-footer button{zoom:1;all:unset;background-color:#fff;border:1px solid #ccc;border-radius:3px;box-sizing:border-box;color:#2d2d2d;cursor:pointer;display:inline-block;font:12px/normal sans-serif;line-height:1.3;outline:0;padding:3px 7px;text-decoration:none;text-shadow:1px 1px 0 #fff}.driver-popover-footer .driver-popover-btn-disabled{opacity:.5;pointer-events:none}:not(body):has(>.driver-active-element){overflow:hidden!important}.driver-no-interaction,.driver-no-interaction *{pointer-events:none!important}.driver-popover-footer button:focus,.driver-popover-footer button:hover{background-color:#f7f7f7}.driver-popover-navigation-btns{display:flex;flex-grow:1;justify-content:flex-end}.driver-popover-navigation-btns button+button{margin-left:4px}.driver-popover-arrow{border:5px solid #fff;content:\"\";position:absolute}.driver-popover-arrow-side-over{display:none}.driver-popover-arrow-side-left{border-bottom-color:transparent;border-right-color:transparent;border-top-color:transparent;left:100%}.driver-popover-arrow-side-right{border-bottom-color:transparent;border-left-color:transparent;border-top-color:transparent;right:100%}.driver-popover-arrow-side-top{border-bottom-color:transparent;border-left-color:transparent;border-right-color:transparent;top:100%}.driver-popover-arrow-side-bottom{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent;bottom:100%}.driver-popover-arrow-side-center{display:none}.driver-popover-arrow-side-left.driver-popover-arrow-align-start,.driver-popover-arrow-side-right.driver-popover-arrow-align-start{top:15px}.driver-popover-arrow-side-bottom.driver-popover-arrow-align-start,.driver-popover-arrow-side-top.driver-popover-arrow-align-start{left:15px}.driver-popover-arrow-align-end.driver-popover-arrow-side-left,.driver-popover-arrow-align-end.driver-popover-arrow-side-right{bottom:15px}.driver-popover-arrow-side-bottom.driver-popover-arrow-align-end,.driver-popover-arrow-side-top.driver-popover-arrow-align-end{right:15px}.driver-popover-arrow-side-left.driver-popover-arrow-align-center,.driver-popover-arrow-side-right.driver-popover-arrow-align-center{margin-top:-5px;top:50%}.driver-popover-arrow-side-bottom.driver-popover-arrow-align-center,.driver-popover-arrow-side-top.driver-popover-arrow-align-center{left:50%;margin-left:-5px}.driver-popover-arrow-none{display:none}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRyaXZlci5jc3MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0RBQWdELG1CQUFtQixDQUFDLGdIQUFnSCxtQkFBbUIsQ0FBQywyQkFBMkIsR0FBRyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQyw2QkFBNkIseUNBQXlDLENBQUMsNkJBQTZCLDZCQUE2QixDQUFDLGdCQUFnQixTQUFTLENBQXlMLHFCQUFvQixDQUFsSixpQkFBaUIsQ0FBaUMsMkJBQTJCLENBQXZJLHFCQUFxQixDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQWdELGVBQWUsQ0FBL0IsZUFBZSxDQUE5QyxZQUFZLENBQWtHLGNBQWMsQ0FBTyxPQUFPLENBQWIsS0FBSyxDQUF2QyxrQkFBcUUsQ0FBQyxrQkFBa0IsMkZBQTZGLENBQUMsc0JBQWtILE1BQU0sQ0FBdEQsYUFBYSxDQUF6RCwyQkFBMkIsQ0FBQyxlQUFlLENBQWlDLGVBQWUsQ0FBUSxRQUFPLENBQWhELGlCQUFpRCxDQUFDLDBCQUEwQixTQUFTLENBQXNHLGFBQWEsQ0FBM0QsY0FBYyxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQXpELFdBQVcsQ0FBdEQsaUJBQWlCLENBQU8sT0FBTyxDQUE4RixpQkFBaUIsQ0FBNUgsS0FBSyxDQUF3SCxnQkFBZ0IsQ0FBQyx1QkFBc0IsQ0FBdEosVUFBVSxDQUF5RSxTQUFvRSxDQUFDLGdFQUFnRSxhQUFhLENBQUMsZ0VBQWdFLGNBQWMsQ0FBQyw0QkFBd0csTUFBSyxDQUFqRSwyQkFBMkIsQ0FBaUIsZUFBZSxDQUEvQixlQUFlLENBQTNELGVBQWtGLENBQUMsdUJBQXdELE1BQU0sQ0FBYyxrQkFBa0IsQ0FBL0IsWUFBWSxDQUFvQiw2QkFBNEIsQ0FBcEcsZUFBZSxDQUFDLGdCQUFxRixDQUFDLDhCQUEyRSxNQUFLLENBQW5CLGFBQWEsQ0FBNUMsY0FBYyxDQUFDLGVBQW9DLENBQUMsOEJBQTRPLE1BQU0sQ0FBcE4sU0FBUyxDQUE0RyxxQkFBcUIsQ0FBMkYscUJBQXFCLENBQUMsaUJBQWdCLENBQTVPLHFCQUFxQixDQUF1RixhQUFhLENBQTZCLGNBQWMsQ0FBekwsb0JBQW9CLENBQTJILDJCQUEyQixDQUFpQyxlQUFlLENBQWhDLFNBQVMsQ0FBeEosZUFBZSxDQUFDLG9CQUFvQixDQUFDLDBCQUFrTCxDQUFDLG9EQUFvRCxVQUFVLENBQUMsbUJBQW1CLENBQUMsd0NBQXdDLHlCQUF5QixDQUFDLGdEQUFnRCw2QkFBNkIsQ0FBQyx3RUFBd0Usd0JBQXdCLENBQUMsZ0NBQWdDLFlBQVksQ0FBQyxXQUFXLENBQUMsd0JBQXdCLENBQUMsOENBQThDLGVBQWUsQ0FBQyxzQkFBbUQscUJBQW9CLENBQWpELFVBQVUsQ0FBQyxpQkFBdUMsQ0FBQyxnQ0FBZ0MsWUFBWSxDQUFDLGdDQUF5RSwrQkFBK0IsQ0FBOUQsOEJBQThCLENBQWlDLDRCQUEyQixDQUFwRyxTQUFxRyxDQUFDLGlDQUEwRSwrQkFBK0IsQ0FBN0QsNkJBQTZCLENBQWlDLDRCQUEyQixDQUFwRyxVQUFxRyxDQUFDLCtCQUF1RSwrQkFBK0IsQ0FBQyw2QkFBNEIsQ0FBM0YsOEJBQThCLENBQXZDLFFBQXFHLENBQUMsa0NBQThDLDZCQUE2QixDQUE4Qiw4QkFBNkIsQ0FBMUQsNEJBQTRCLENBQXRFLFdBQXFHLENBQUMsa0NBQWtDLFlBQVksQ0FBQyxtSUFBbUksUUFBUSxDQUFDLG1JQUFtSSxTQUFTLENBQUMsK0hBQStILFdBQVcsQ0FBQywrSEFBK0gsVUFBVSxDQUFDLHFJQUE2SSxlQUFjLENBQXRCLE9BQXVCLENBQUMscUlBQXFJLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQywyQkFBMkIsWUFBWSIsImZpbGUiOiJkcml2ZXIuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLmRyaXZlci1hY3RpdmUgLmRyaXZlci1vdmVybGF5LC5kcml2ZXItYWN0aXZlICp7cG9pbnRlci1ldmVudHM6bm9uZX0uZHJpdmVyLWFjdGl2ZSAuZHJpdmVyLWFjdGl2ZS1lbGVtZW50LC5kcml2ZXItYWN0aXZlIC5kcml2ZXItYWN0aXZlLWVsZW1lbnQgKiwuZHJpdmVyLXBvcG92ZXIsLmRyaXZlci1wb3BvdmVyICp7cG9pbnRlci1ldmVudHM6YXV0b31Aa2V5ZnJhbWVzIGFuaW1hdGUtZmFkZS1pbnswJXtvcGFjaXR5OjB9dG97b3BhY2l0eToxfX0uZHJpdmVyLWZhZGUgLmRyaXZlci1vdmVybGF5e2FuaW1hdGlvbjphbmltYXRlLWZhZGUtaW4gLjJzIGVhc2UtaW4tb3V0fS5kcml2ZXItZmFkZSAuZHJpdmVyLXBvcG92ZXJ7YW5pbWF0aW9uOmFuaW1hdGUtZmFkZS1pbiAuMnN9LmRyaXZlci1wb3BvdmVye2FsbDp1bnNldDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Y29sb3I6IzJkMmQyZDttYXJnaW46MDtwYWRkaW5nOjE1cHg7Ym9yZGVyLXJhZGl1czo1cHg7bWluLXdpZHRoOjI1MHB4O21heC13aWR0aDozMDBweDtib3gtc2hhZG93OjAgMXB4IDEwcHggIzAwMDY7ei1pbmRleDoxMDAwMDAwMDAwO3Bvc2l0aW9uOmZpeGVkO3RvcDowO3JpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5kcml2ZXItcG9wb3ZlciAqe2ZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEludGVyLHVpLXNhbnMtc2VyaWYsXCJBcHBsZSBDb2xvciBFbW9qaVwiLEhlbHZldGljYSxBcmlhbCxzYW5zLXNlcmlmfS5kcml2ZXItcG9wb3Zlci10aXRsZXtmb250OjE5cHgvbm9ybWFsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6NzAwO2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7bGluZS1oZWlnaHQ6MS41O3pvb206MTttYXJnaW46MH0uZHJpdmVyLXBvcG92ZXItY2xvc2UtYnRue2FsbDp1bnNldDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO3dpZHRoOjMycHg7aGVpZ2h0OjI4cHg7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjE4cHg7Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOiNkMmQyZDI7ei1pbmRleDoxO3RleHQtYWxpZ246Y2VudGVyO3RyYW5zaXRpb246Y29sb3I7dHJhbnNpdGlvbi1kdXJhdGlvbjouMnN9LmRyaXZlci1wb3BvdmVyLWNsb3NlLWJ0bjpob3ZlciwuZHJpdmVyLXBvcG92ZXItY2xvc2UtYnRuOmZvY3Vze2NvbG9yOiMyZDJkMmR9LmRyaXZlci1wb3BvdmVyLXRpdGxlW3N0eWxlKj1ibG9ja10rLmRyaXZlci1wb3BvdmVyLWRlc2NyaXB0aW9ue21hcmdpbi10b3A6NXB4fS5kcml2ZXItcG9wb3Zlci1kZXNjcmlwdGlvbnttYXJnaW4tYm90dG9tOjA7Zm9udDoxNHB4L25vcm1hbCBzYW5zLXNlcmlmO2xpbmUtaGVpZ2h0OjEuNTtmb250LXdlaWdodDo0MDA7em9vbToxfS5kcml2ZXItcG9wb3Zlci1mb290ZXJ7bWFyZ2luLXRvcDoxNXB4O3RleHQtYWxpZ246cmlnaHQ7em9vbToxO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59LmRyaXZlci1wb3BvdmVyLXByb2dyZXNzLXRleHR7Zm9udC1zaXplOjEzcHg7Zm9udC13ZWlnaHQ6NDAwO2NvbG9yOiM3MjcyNzI7em9vbToxfS5kcml2ZXItcG9wb3Zlci1mb290ZXIgYnV0dG9ue2FsbDp1bnNldDtkaXNwbGF5OmlubGluZS1ibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzozcHggN3B4O3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93OjFweCAxcHggMCAjZmZmO2JhY2tncm91bmQtY29sb3I6I2ZmZjtjb2xvcjojMmQyZDJkO2ZvbnQ6MTJweC9ub3JtYWwgc2Fucy1zZXJpZjtjdXJzb3I6cG9pbnRlcjtvdXRsaW5lOjA7em9vbToxO2xpbmUtaGVpZ2h0OjEuMztib3JkZXI6MXB4IHNvbGlkICNjY2M7Ym9yZGVyLXJhZGl1czozcHh9LmRyaXZlci1wb3BvdmVyLWZvb3RlciAuZHJpdmVyLXBvcG92ZXItYnRuLWRpc2FibGVke29wYWNpdHk6LjU7cG9pbnRlci1ldmVudHM6bm9uZX06bm90KGJvZHkpOmhhcyg+LmRyaXZlci1hY3RpdmUtZWxlbWVudCl7b3ZlcmZsb3c6aGlkZGVuIWltcG9ydGFudH0uZHJpdmVyLW5vLWludGVyYWN0aW9uLC5kcml2ZXItbm8taW50ZXJhY3Rpb24gKntwb2ludGVyLWV2ZW50czpub25lIWltcG9ydGFudH0uZHJpdmVyLXBvcG92ZXItZm9vdGVyIGJ1dHRvbjpob3ZlciwuZHJpdmVyLXBvcG92ZXItZm9vdGVyIGJ1dHRvbjpmb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y3Zjd9LmRyaXZlci1wb3BvdmVyLW5hdmlnYXRpb24tYnRuc3tkaXNwbGF5OmZsZXg7ZmxleC1ncm93OjE7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5kcml2ZXItcG9wb3Zlci1uYXZpZ2F0aW9uLWJ0bnMgYnV0dG9uK2J1dHRvbnttYXJnaW4tbGVmdDo0cHh9LmRyaXZlci1wb3BvdmVyLWFycm93e2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6NXB4IHNvbGlkICNmZmZ9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtb3ZlcntkaXNwbGF5Om5vbmV9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtbGVmdHtsZWZ0OjEwMCU7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudH0uZHJpdmVyLXBvcG92ZXItYXJyb3ctc2lkZS1yaWdodHtyaWdodDoxMDAlO2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudH0uZHJpdmVyLXBvcG92ZXItYXJyb3ctc2lkZS10b3B7dG9wOjEwMCU7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnR9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtYm90dG9te2JvdHRvbToxMDAlO2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kcml2ZXItcG9wb3Zlci1hcnJvdy1zaWRlLWNlbnRlcntkaXNwbGF5Om5vbmV9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtbGVmdC5kcml2ZXItcG9wb3Zlci1hcnJvdy1hbGlnbi1zdGFydCwuZHJpdmVyLXBvcG92ZXItYXJyb3ctc2lkZS1yaWdodC5kcml2ZXItcG9wb3Zlci1hcnJvdy1hbGlnbi1zdGFydHt0b3A6MTVweH0uZHJpdmVyLXBvcG92ZXItYXJyb3ctc2lkZS10b3AuZHJpdmVyLXBvcG92ZXItYXJyb3ctYWxpZ24tc3RhcnQsLmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtYm90dG9tLmRyaXZlci1wb3BvdmVyLWFycm93LWFsaWduLXN0YXJ0e2xlZnQ6MTVweH0uZHJpdmVyLXBvcG92ZXItYXJyb3ctYWxpZ24tZW5kLmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtbGVmdCwuZHJpdmVyLXBvcG92ZXItYXJyb3ctYWxpZ24tZW5kLmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtcmlnaHR7Ym90dG9tOjE1cHh9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtdG9wLmRyaXZlci1wb3BvdmVyLWFycm93LWFsaWduLWVuZCwuZHJpdmVyLXBvcG92ZXItYXJyb3ctc2lkZS1ib3R0b20uZHJpdmVyLXBvcG92ZXItYXJyb3ctYWxpZ24tZW5ke3JpZ2h0OjE1cHh9LmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtbGVmdC5kcml2ZXItcG9wb3Zlci1hcnJvdy1hbGlnbi1jZW50ZXIsLmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtcmlnaHQuZHJpdmVyLXBvcG92ZXItYXJyb3ctYWxpZ24tY2VudGVye3RvcDo1MCU7bWFyZ2luLXRvcDotNXB4fS5kcml2ZXItcG9wb3Zlci1hcnJvdy1zaWRlLXRvcC5kcml2ZXItcG9wb3Zlci1hcnJvdy1hbGlnbi1jZW50ZXIsLmRyaXZlci1wb3BvdmVyLWFycm93LXNpZGUtYm90dG9tLmRyaXZlci1wb3BvdmVyLWFycm93LWFsaWduLWNlbnRlcntsZWZ0OjUwJTttYXJnaW4tbGVmdDotNXB4fS5kcml2ZXItcG9wb3Zlci1hcnJvdy1ub25le2Rpc3BsYXk6bm9uZX1cbiJdfQ== */";
  styleInject(css_248z$2);

  /**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   */
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  var version = "1.15.6";

  function userAgent(pattern) {
    if (typeof window !== 'undefined' && window.navigator) {
      return !! /*@__PURE__*/navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function matches( /**HTMLElement*/el, /**String*/selector) {
    if (!selector) return;
    selector[0] === '>' && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
    if (el) {
      ctx = ctx || document;
      do {
        if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
          return el;
        }
        if (el === ctx) break;
        /* jshint boss:true */
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name, state) {
    if (el && name) {
      if (el.classList) {
        el.classList[state ? 'add' : 'remove'](name);
      } else {
        var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
        el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
      }
    }
  }
  function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, '');
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf('webkit') === -1) {
          prop = '-webkit-' + prop;
        }
        style[prop] = val + (typeof val === 'string' ? '' : 'px');
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = '';
    if (typeof el === 'string') {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, 'transform');
        if (transform && transform !== 'none') {
          appliedTransforms = transform + ' ' + appliedTransforms;
        }
        /* jshint boss:true */
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    /*jshint -W056 */
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx, tagName, iterator) {
    if (ctx) {
      var list = ctx.getElementsByTagName(tagName),
        i = 0,
        n = list.length;
      if (iterator) {
        for (; i < n; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }

  /**
   * Returns the "bounding client rect" of given element
   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
   * @param  {[HTMLElement]} container              The parent the element will be placed in
   * @return {Object}                               The boundingClientRect of el, with specified adjustments
   */
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left, bottom, right, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left = elRect.left;
      bottom = elRect.bottom;
      right = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left = 0;
      bottom = window.innerHeight;
      right = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      // Adjust for translate()
      container = container || el.parentNode;

      // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
      // Not needed on <= IE11
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
            var containerRect = container.getBoundingClientRect();

            // Set relative to edges of padding box of container
            top -= containerRect.top + parseInt(css(container, 'border-top-width'));
            left -= containerRect.left + parseInt(css(container, 'border-left-width'));
            bottom = top + elRect.height;
            right = left + elRect.width;
            break;
          }
          /* jshint boss:true */
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el !== window) {
      // Adjust for scale()
      var elMatrix = matrix(container || el),
        scaleX = elMatrix && elMatrix.a,
        scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY;
        left /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right = left + width;
      }
    }
    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right,
      width: width,
      height: height
    };
  }

  /**
   * Checks if a side of an element is scrolled past a side of its parents
   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
   */
  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true),
      elSideVal = getRect(el)[elSide];

    /* jshint boss:true */
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide],
        visible = void 0;
      {
        visible = elSideVal >= parentSideVal;
      }
      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }

  /**
   * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
   * and non-draggable elements
   * @param  {HTMLElement} el       The parent element
   * @param  {Number} childNum      The index of the child
   * @param  {Object} options       Parent Sortable's options
   * @return {HTMLElement}          The child at index childNum, or null if not found
   */
  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0,
      i = 0,
      children = el.children;
    while (i < children.length) {
      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }

  /**
   * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
   * @param  {HTMLElement} el       Parent element
   * @param  {selector} selector    Any other elements that should be ignored
   * @return {HTMLElement}          The last child, ignoring ghostEl
   */
  function lastChild(el, selector) {
    var last = el.lastElementChild;
    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
      last = last.previousElementSibling;
    }
    return last || null;
  }

  /**
   * Returns the index of an element within its parent for a selected set of
   * elements
   * @param  {HTMLElement} el
   * @param  {selector} selector
   * @return {number}
   */
  function index$1(el, selector) {
    var index = 0;
    if (!el || !el.parentNode) {
      return -1;
    }

    /* jshint boss:true */
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index++;
      }
    }
    return index;
  }

  /**
   * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
   * The value is returned in real pixels.
   * @param  {HTMLElement} el
   * @return {Array}             Offsets in the format of [left, top]
   */
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0,
      offsetTop = 0,
      winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el),
          scaleX = elMatrix.a,
          scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }

  /**
   * Returns the index of the object within the given array
   * @param  {Array} arr   Array that may or may not hold the object
   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
   * @return {Number}      The index of the object in the array, or -1
   */
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    // skip to window
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      // we don't need to get elem css if it isn't even overflowing in the first place (performance)
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
      /* jshint boss:true */
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect2) {
    return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
  }
  var _throttleTimeout;
  function throttle(callback, ms) {
    return function () {
      if (!_throttleTimeout) {
        var args = arguments,
          _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function () {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x, y) {
    el.scrollLeft += x;
    el.scrollTop += y;
  }
  function clone(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container, options, ghostEl) {
    var rect = {};
    Array.from(container.children).forEach(function (child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
      var childRect = getRect(child);
      rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  var expando = 'Sortable' + new Date().getTime();

  function AnimationStateManager() {
    var animationStates = [],
      animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function (child) {
          if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

          // If animating: compensate for current animation
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target: target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === 'function') callback();
          return;
        }
        var animating = false,
          animationTime = 0;
        animationStates.forEach(function (state) {
          var time = 0,
            target = state.target,
            fromRect = target.fromRect,
            toRect = getRect(target),
            prevFromRect = target.prevFromRect,
            prevToRect = target.prevToRect,
            animatingRect = state.rect,
            targetMatrix = matrix(target, true);
          if (targetMatrix) {
            // Compensate for current animation
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            // Could also check if animatingRect is between fromRect and toRect
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
            // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              // If returning to same place as started from animation and on same axis
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }

          // if fromRect != toRect: animate
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function () {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === 'function') callback();
        } else {
          animationCallbackId = setTimeout(function () {
            if (typeof callback === 'function') callback();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, 'transition', '');
          css(target, 'transform', '');
          var elMatrix = matrix(this.el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d,
            translateX = (currentRect.left - toRect.left) / (scaleX || 1),
            translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
          this.forRepaintDummy = repaint(target); // repaint

          css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
          css(target, 'transform', 'translate3d(0,0,0)');
          typeof target.animated === 'number' && clearTimeout(target.animated);
          target.animated = setTimeout(function () {
            css(target, 'transition', '');
            css(target, 'transform', '');
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }

  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      // Set default static properties
      for (var option in defaults) {
        if (defaults.hasOwnProperty(option) && !(option in plugin)) {
          plugin[option] = defaults[option];
        }
      }
      plugins.forEach(function (p) {
        if (p.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function () {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + 'Global';
      plugins.forEach(function (plugin) {
        if (!sortable[plugin.pluginName]) return;
        // Fire global events if it exists in this sortable
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable: sortable
          }, evt));
        }

        // Only fire plugin event if plugin is enabled in this sortable,
        // and plugin has event defined
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable: sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults, options) {
      plugins.forEach(function (plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;

        // Add default options from plugin
        _extends(defaults, initialized.defaults);
      });
      for (var option in sortable.options) {
        if (!sortable.options.hasOwnProperty(option)) continue;
        var modified = this.modifyOption(sortable, option, sortable.options[option]);
        if (typeof modified !== 'undefined') {
          sortable.options[option] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name, sortable) {
      var eventProperties = {};
      plugins.forEach(function (plugin) {
        if (typeof plugin.eventProperties !== 'function') return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name, value) {
      var modifiedValue;
      plugins.forEach(function (plugin) {
        // Plugin must exist on the Sortable
        if (!sortable[plugin.pluginName]) return;

        // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
        if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
          modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
        }
      });
      return modifiedValue;
    }
  };

  function dispatchEvent(_ref) {
    var sortable = _ref.sortable,
      rootEl = _ref.rootEl,
      name = _ref.name,
      targetEl = _ref.targetEl,
      cloneEl = _ref.cloneEl,
      toEl = _ref.toEl,
      fromEl = _ref.fromEl,
      oldIndex = _ref.oldIndex,
      newIndex = _ref.newIndex,
      oldDraggableIndex = _ref.oldDraggableIndex,
      newDraggableIndex = _ref.newDraggableIndex,
      originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl && rootEl[expando];
    if (!sortable) return;
    var evt,
      options = sortable.options,
      onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
    // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent(name, true, true);
    }
    evt.to = toEl || rootEl;
    evt.from = fromEl || rootEl;
    evt.item = targetEl || rootEl;
    evt.clone = cloneEl;
    evt.oldIndex = oldIndex;
    evt.newIndex = newIndex;
    evt.oldDraggableIndex = oldDraggableIndex;
    evt.newDraggableIndex = newDraggableIndex;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
    for (var option in allEventProperties) {
      evt[option] = allEventProperties[option];
    }
    if (rootEl) {
      rootEl.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }

  var _excluded = ["evt"];
  var pluginEvent = function pluginEvent(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      originalEvent = _ref.evt,
      data = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl: dragEl,
      parentEl: parentEl,
      ghostEl: ghostEl,
      rootEl: rootEl,
      nextEl: nextEl,
      lastDownEl: lastDownEl,
      cloneEl: cloneEl,
      cloneHidden: cloneHidden,
      dragStarted: moved,
      putSortable: putSortable,
      activeSortable: Sortable.active,
      originalEvent: originalEvent,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name) {
        _dispatchEvent({
          sortable: sortable,
          name: name,
          originalEvent: originalEvent
        });
      }
    }, data));
  };
  function _dispatchEvent(info) {
    dispatchEvent(_objectSpread2({
      putSortable: putSortable,
      cloneEl: cloneEl,
      targetEl: dragEl,
      rootEl: rootEl,
      oldIndex: oldIndex,
      oldDraggableIndex: oldDraggableIndex,
      newIndex: newIndex,
      newDraggableIndex: newDraggableIndex
    }, info));
  }
  var dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    oldIndex,
    newIndex,
    oldDraggableIndex,
    newDraggableIndex,
    activeGroup,
    putSortable,
    awaitingDragStarted = false,
    ignoreNextClick = false,
    sortables = [],
    tapEvt,
    touchEvt,
    lastDx,
    lastDy,
    tapDistanceLeft,
    tapDistanceTop,
    moved,
    lastTarget,
    lastDirection,
    pastFirstInvertThresh = false,
    isCircumstantialInvert = false,
    targetMoveDistance,
    // For positioning ghost absolutely
    ghostRelativeParent,
    ghostRelativeParentInitialScroll = [],
    // (left, top)

    _silent = false,
    savedInputChecked = [];

  /** @const */
  var documentExists = typeof document !== 'undefined',
    PositionGhostAbsolutely = IOS,
    CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
    // This will not pass for IE9, because IE9 DnD only works on anchors
    supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
    supportCssPointerEvents = function () {
      if (!documentExists) return;
      // false when <= IE11
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement('x');
      el.style.cssText = 'pointer-events:auto';
      return el.style.pointerEvents === 'auto';
    }(),
    _detectDirection = function _detectDirection(el, options) {
      var elCSS = css(el),
        elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
        child1 = getChild(el, 0, options),
        child2 = getChild(el, 1, options),
        firstChildCSS = child1 && css(child1),
        secondChildCSS = child2 && css(child2),
        firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
        secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
      if (elCSS.display === 'flex') {
        return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
      }
      if (elCSS.display === 'grid') {
        return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
      }
      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
        var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
        return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
      }
      return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
    },
    _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
        dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
        dragElOppLength = vertical ? dragRect.width : dragRect.height,
        targetS1Opp = vertical ? targetRect.left : targetRect.top,
        targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
        targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    },
    /**
     * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
     * @param  {Number} x      X position
     * @param  {Number} y      Y position
     * @return {HTMLElement}   Element of the first found nearest Sortable
     */
    _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
      var ret;
      sortables.some(function (sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable)) return;
        var rect = getRect(sortable),
          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    },
    _prepareGroup = function _prepareGroup(options) {
      function toFn(value, pull) {
        return function (to, from, dragEl, evt) {
          var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
          if (value == null && (pull || sameGroup)) {
            // Default pull value
            // Default pull and put value if same group
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === 'clone') {
            return value;
          } else if (typeof value === 'function') {
            return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
          } else {
            var otherGroup = (pull ? to : from).options.group.name;
            return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }
      var group = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof(originalGroup) != 'object') {
        originalGroup = {
          name: originalGroup
        };
      }
      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    },
    _hideGhostForTarget = function _hideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, 'display', 'none');
      }
    },
    _unhideGhostForTarget = function _unhideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, 'display', '');
      }
    };

  // #1184 fix - Prevent click event on fallback if dragged but item not changed position
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener('click', function (evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        // Create imitation event
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };

  /**
   * @class  Sortable
   * @param  {HTMLElement}  el
   * @param  {Object}       [options]
   */
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el; // root element
    this.options = options = _extends({}, options);

    // Export instance
    el[expando] = this;
    var defaults = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction() {
        return _detectDirection(el, this.options);
      },
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      ignore: 'a, img',
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData(dataTransfer, dragEl) {
        dataTransfer.setData('Text', dragEl.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: 'data-id',
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: 'sortable-fallback',
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
      supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults);

    // Set default options
    for (var name in defaults) {
      !(name in options) && (options[name] = defaults[name]);
    }
    _prepareGroup(options);

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }

    // Setup drag mode
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      // Touch start threshold cannot be greater than the native dragstart threshold
      this.options.touchStartThreshold = 1;
    }

    // Bind events
    if (options.supportPointer) {
      on(el, 'pointerdown', this._onTapStart);
    } else {
      on(el, 'mousedown', this._onTapStart);
      on(el, 'touchstart', this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, 'dragover', this);
      on(el, 'dragenter', this);
    }
    sortables.push(this.el);

    // Restore sorting
    options.store && options.store.get && this.sort(options.store.get(this) || []);

    // Add animation state manager
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */{
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
      if (!evt.cancelable) return;
      var _this = this,
        el = this.el,
        options = this.options,
        preventOnFilter = options.preventOnFilter,
        type = evt.type,
        touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
        target = (touch || evt).target,
        originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
        filter = options.filter;
      _saveInputCheckedState(el);

      // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return; // only left button and enabled
      }

      // cancel dnd if original target is content editable
      if (originalTarget.isContentEditable) {
        return;
      }

      // Safari ignores further event handling after mousedown
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        // Ignoring duplicate `down`
        return;
      }

      // Get the index of the dragged element within its parent
      oldIndex = index$1(target);
      oldDraggableIndex = index$1(target, options.draggable);

      // Check filter
      if (typeof filter === 'function') {
        if (filter.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: 'filter',
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          preventOnFilter && evt.preventDefault();
          return; // cancel dnd
        }
      } else if (filter) {
        filter = filter.split(',').some(function (criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: 'filter',
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent('filter', _this, {
              evt: evt
            });
            return true;
          }
        });
        if (filter) {
          preventOnFilter && evt.preventDefault();
          return; // cancel dnd
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      }

      // Prepare `dragstart`
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
      var _this = this,
        el = _this.el,
        options = _this.options,
        ownerDocument = el.ownerDocument,
        dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style['will-change'] = 'all';
        dragStartFn = function dragStartFn() {
          pluginEvent('delayEnded', _this, {
            evt: evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          // Delayed drag has been triggered
          // we can re-enable the events: touchmove/mousemove
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }

          // Bind the events: dragstart/dragend
          _this._triggerDragStart(evt, touch);

          // Drag start event
          _dispatchEvent({
            sortable: _this,
            name: 'choose',
            originalEvent: evt
          });

          // Chosen item
          toggleClass(dragEl, options.chosenClass, true);
        };

        // Disable "draggable"
        options.ignore.split(',').forEach(function (criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
        on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
        if (options.supportPointer) {
          on(ownerDocument, 'pointerup', _this._onDrop);
          // Native D&D triggers pointercancel
          !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);
        } else {
          on(ownerDocument, 'mouseup', _this._onDrop);
          on(ownerDocument, 'touchend', _this._onDrop);
          on(ownerDocument, 'touchcancel', _this._onDrop);
        }

        // Make dragEl draggable (must be before delay for FireFox)
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent('delayStart', this, {
          evt: evt
        });

        // Delay is impossible for native DnD in Edge or IE
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          // If the user moves the pointer or let go the click or touch
          // before the delay has been reached:
          // disable the delayed drag
          if (options.supportPointer) {
            on(ownerDocument, 'pointerup', _this._disableDelayedDrag);
            on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);
          } else {
            on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
            on(ownerDocument, 'touchend', _this._disableDelayedDrag);
            on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
          }
          on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
          on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
      var touch = e.touches ? e.touches[0] : e;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._disableDelayedDrag);
      off(ownerDocument, 'touchend', this._disableDelayedDrag);
      off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
      off(ownerDocument, 'pointerup', this._disableDelayedDrag);
      off(ownerDocument, 'pointercancel', this._disableDelayedDrag);
      off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
      off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
      touch = touch || evt.pointerType == 'touch' && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._onTouchMove);
        } else if (touch) {
          on(document, 'touchmove', this._onTouchMove);
        } else {
          on(document, 'mousemove', this._onTouchMove);
        }
      } else {
        on(dragEl, 'dragend', this);
        on(rootEl, 'dragstart', this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function () {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {}
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent('dragStarted', this, {
          evt: evt
        });
        if (this.nativeDraggable) {
          on(document, 'dragover', _checkOutsideTargetEl);
        }
        var options = this.options;

        // Apply effect
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();

        // Drag start event
        _dispatchEvent({
          sortable: this,
          name: 'start',
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target: target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent; // store last element
          }
          /* jshint boss:true */ while (parent = getParentOrHost(parent));
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
      if (tapEvt) {
        var options = this.options,
          fallbackTolerance = options.fallbackTolerance,
          fallbackOffset = options.fallbackOffset,
          touch = evt.touches ? evt.touches[0] : evt,
          ghostMatrix = ghostEl && matrix(ghostEl, true),
          scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
          scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
          relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
          dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
          dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

        // only set the status to dragging, when we are actually dragging
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, 'webkitTransform', cssMatrix);
          css(ghostEl, 'mozTransform', cssMatrix);
          css(ghostEl, 'msTransform', cssMatrix);
          css(ghostEl, 'transform', cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      // Bug if using scale(): https://stackoverflow.com/questions/2637058
      // Not being adjusted for
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl,
          rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
          options = this.options;

        // Position absolutely
        if (PositionGhostAbsolutely) {
          // Get relatively positioned parent
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect.top += ghostRelativeParent.scrollTop;
            rect.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, 'transition', '');
        css(ghostEl, 'transform', '');
        css(ghostEl, 'box-sizing', 'border-box');
        css(ghostEl, 'margin', 0);
        css(ghostEl, 'top', rect.top);
        css(ghostEl, 'left', rect.left);
        css(ghostEl, 'width', rect.width);
        css(ghostEl, 'height', rect.height);
        css(ghostEl, 'opacity', '0.8');
        css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
        css(ghostEl, 'zIndex', '100000');
        css(ghostEl, 'pointerEvents', 'none');
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);

        // Set transform-origin
        css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
      }
    },
    _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent('dragStart', this, {
        evt: evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent('setupClone', this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style['will-change'] = '';
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }

      // #1143: IFrame support workaround
      _this.cloneId = _nextTick(function () {
        pluginEvent('clone', _this);
        if (Sortable.eventCanceled) return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: 'clone'
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);

      // Set proper drop events
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        // Undo what was set in _prepareDragStart before drag started
        off(document, 'mouseup', _this._onDrop);
        off(document, 'touchend', _this._onDrop);
        off(document, 'touchcancel', _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = 'move';
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, 'drop', _this);

        // #1276 fix:
        css(dragEl, 'transform', 'translateZ(0)');
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, 'selectstart', _this);
      moved = true;
      window.getSelection().removeAllRanges();
      if (Safari) {
        css(document.body, 'user-select', 'none');
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver( /**Event*/evt) {
      var el = this.el,
        target = evt.target,
        dragRect,
        targetRect,
        revert,
        options = this.options,
        group = options.group,
        activeSortable = Sortable.active,
        isOwner = activeGroup === group,
        canSort = options.sort,
        fromSortable = putSortable || activeSortable,
        vertical,
        _this = this,
        completedFired = false;
      if (_silent) return;
      function dragOverEvent(name, extra) {
        pluginEvent(name, _this, _objectSpread2({
          evt: evt,
          isOwner: isOwner,
          axis: vertical ? 'vertical' : 'horizontal',
          revert: revert,
          dragRect: dragRect,
          targetRect: targetRect,
          canSort: canSort,
          fromSortable: fromSortable,
          target: target,
          completed: completed,
          onMove: function onMove(target, after) {
            return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
          },
          changed: changed
        }, extra));
      }

      // Capture animation state
      function capture() {
        dragOverEvent('dragOverAnimationCapture');
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }

      // Return invocation when dragEl is inserted (or completed)
      function completed(insertion) {
        dragOverEvent('dragOverCompleted', {
          insertion: insertion
        });
        if (insertion) {
          // Clones must be hidden before folding animation to capture dragRectAbsolute properly
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            // Set ghost class to new sortable's ghost class
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }

          // Animation
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function () {
            dragOverEvent('dragOverAnimationComplete');
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }

        // Null lastTarget if it is not inside a previously swapped element
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }

        // no bubbling and not fallback
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

          // Do not detect for empty insert if already inserted
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }

      // Call when dragEl has been inserted
      function changed() {
        newIndex = index$1(dragEl);
        newDraggableIndex = index$1(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: 'change',
          toEl: el,
          newIndex: newIndex,
          newDraggableIndex: newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent('dragOver');
      if (Sortable.eventCanceled) return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
      : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
        vertical = this._getDirection(evt, target) === 'vertical';
        dragRect = getRect(dragEl);
        dragOverEvent('dragOverValid');
        if (Sortable.eventCanceled) return completedFired;
        if (revert) {
          parentEl = rootEl; // actualization
          capture();
          this._hideClone();
          dragOverEvent('revert');
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
          // Insert to end of list

          // If already at end of list: Do not insert
          if (elLastChild === dragEl) {
            return completed(false);
          }

          // if there is a last element, it is the target
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              // the last draggable element is not the last node
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
          // Insert to start of list
          var firstChild = getChild(el, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el; // actualization

            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction = 0,
            targetBeforeFirstSwap,
            differentLevel = dragEl.parentNode !== el,
            differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
            side1 = vertical ? 'top' : 'left',
            scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
            scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction !== 0) {
            // Check if target is beside dragEl in respective direction (ignoring hidden elements)
            var dragIndex = index$1(dragEl);
            do {
              dragIndex -= direction;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
          }
          // If dragEl is already beside target: Do not insert
          if (direction === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction;
          var nextSibling = target.nextElementSibling,
            after = false;
          after = direction === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }

            // Undo chrome's scroll adjustment (has no effect on other browsers)
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode; // actualization

            // must be done before animation
            if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, 'mousemove', this._onTouchMove);
      off(document, 'touchmove', this._onTouchMove);
      off(document, 'pointermove', this._onTouchMove);
      off(document, 'dragover', nearestEmptyInsertDetectEvent);
      off(document, 'mousemove', nearestEmptyInsertDetectEvent);
      off(document, 'touchmove', nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, 'mouseup', this._onDrop);
      off(ownerDocument, 'touchend', this._onDrop);
      off(ownerDocument, 'pointerup', this._onDrop);
      off(ownerDocument, 'pointercancel', this._onDrop);
      off(ownerDocument, 'touchcancel', this._onDrop);
      off(document, 'selectstart', this);
    },
    _onDrop: function _onDrop( /**Event*/evt) {
      var el = this.el,
        options = this.options;

      // Get the index of the dragged element within its parent
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      pluginEvent('drop', this, {
        evt: evt
      });
      parentEl = dragEl && dragEl.parentNode;

      // Get again after plugin event
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);

      // Unbind events
      if (this.nativeDraggable) {
        off(document, 'drop', this);
        off(el, 'dragstart', this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, 'user-select', '');
      }
      css(dragEl, 'transform', '');
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
          // Remove clone(s)
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, 'dragend', this);
          }
          _disableDraggable(dragEl);
          dragEl.style['will-change'] = '';

          // Remove classes
          // ghostClass is added in dragStarted
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);

          // Drag stop event
          _dispatchEvent({
            sortable: this,
            name: 'unchoose',
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              // Add event
              _dispatchEvent({
                rootEl: parentEl,
                name: 'add',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });

              // Remove event
              _dispatchEvent({
                sortable: this,
                name: 'remove',
                toEl: parentEl,
                originalEvent: evt
              });

              // drag from one list and drop into another
              _dispatchEvent({
                rootEl: parentEl,
                name: 'sort',
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                // drag & drop within the same list
                _dispatchEvent({
                  sortable: this,
                  name: 'update',
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            /* jshint eqnull:true */
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: 'end',
              toEl: parentEl,
              originalEvent: evt
            });

            // Save sorting
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent('nulling', this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function (el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent( /**Event*/evt) {
      switch (evt.type) {
        case 'drop':
        case 'dragend':
          this._onDrop(evt);
          break;
        case 'dragenter':
        case 'dragover':
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case 'selectstart':
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [],
        el,
        children = this.el.children,
        i = 0,
        n = children.length,
        options = this.options;
      for (; i < n; i++) {
        el = children[i];
        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items = {},
        rootEl = this.el;
      this.toArray().forEach(function (id, i) {
        var el = rootEl.children[i];
        if (closest(el, this.options.draggable, rootEl, false)) {
          items[id] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function (id) {
        if (items[id]) {
          rootEl.removeChild(items[id]);
          rootEl.appendChild(items[id]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name, value) {
      var options = this.options;
      if (value === void 0) {
        return options[name];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name, value);
        if (typeof modifiedValue !== 'undefined') {
          options[name] = modifiedValue;
        } else {
          options[name] = value;
        }
        if (name === 'group') {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent('destroy', this);
      var el = this.el;
      el[expando] = null;
      off(el, 'mousedown', this._onTapStart);
      off(el, 'touchstart', this._onTapStart);
      off(el, 'pointerdown', this._onTapStart);
      if (this.nativeDraggable) {
        off(el, 'dragover', this);
        off(el, 'dragenter', this);
      }
      // Remove draggable attributes
      Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
        el.removeAttribute('draggable');
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent('hideClone', this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, 'display', 'none');
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable) {
      if (putSortable.lastPutMode !== 'clone') {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent('showClone', this);
        if (Sortable.eventCanceled) return;

        // show clone at dragEl or original position
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, 'display', '');
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver( /**Event*/evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = 'move';
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt,
      sortable = fromEl[expando],
      onMoveFn = sortable.options.onMove,
      retVal;
    // Support for new CustomEvent feature
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent('move', {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent('Event');
      evt.initEvent('move', true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
      targetLength = vertical ? targetRect.height : targetRect.width,
      targetS1 = vertical ? targetRect.top : targetRect.left,
      targetS2 = vertical ? targetRect.bottom : targetRect.right,
      invert = false;
    if (!invertSwap) {
      // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
        // check if past first invert threshold on side opposite of lastDirection
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          // past first invert threshold, do not restrict inverted threshold to dragEl shadow
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          // dragEl shadow (target move distance shadow)
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
          : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert = true;
        }
      } else {
        // Regular
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert = invert || invertSwap;
    if (invert) {
      // Invert of regular
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }

  /**
   * Gets the direction dragEl must be swapped relative to target in order to make it
   * seem that dragEl has been "inserted" into that element's position
   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
   * @return {Number}                   Direction dragEl must be swapped
   */
  function _getInsertDirection(target) {
    if (index$1(dragEl) < index$1(target)) {
      return 1;
    } else {
      return -1;
    }
  }

  /**
   * Generate id
   * @param   {HTMLElement} el
   * @returns {String}
   * @private
   */
  function _generateId(el) {
    var str = el.tagName + el.className + el.src + el.href + el.textContent,
      i = str.length,
      sum = 0;
    while (i--) {
      sum += str.charCodeAt(i);
    }
    return sum.toString(36);
  }
  function _saveInputCheckedState(root) {
    savedInputChecked.length = 0;
    var inputs = root.getElementsByTagName('input');
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  function _cancelNextTick(id) {
    return clearTimeout(id);
  }

  // Fixed #973:
  if (documentExists) {
    on(document, 'touchmove', function (evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }

  // Export utils
  Sortable.utils = {
    on: on,
    off: off,
    css: css,
    find: find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend,
    throttle: throttle,
    closest: closest,
    toggleClass: toggleClass,
    clone: clone,
    index: index$1,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild: getChild,
    expando: expando
  };

  /**
   * Get the Sortable instance of an element
   * @param  {HTMLElement} element The element
   * @return {Sortable|undefined}         The instance of Sortable
   */
  Sortable.get = function (element) {
    return element[expando];
  };

  /**
   * Mount a plugin to Sortable
   * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
   */
  Sortable.mount = function () {
    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }
    if (plugins[0].constructor === Array) plugins = plugins[0];
    plugins.forEach(function (plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };

  /**
   * Create sortable instance
   * @param {HTMLElement}  el
   * @param {Object}      [options]
   */
  Sortable.create = function (el, options) {
    return new Sortable(el, options);
  };

  // Export
  Sortable.version = version;

  var autoScrolls = [],
    scrollEl,
    scrollRootEl,
    scrolling = false,
    lastAutoScrollX,
    lastAutoScrollY,
    touchEvt$1,
    pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };

      // Bind all private methods
      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, 'dragover', this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, 'touchmove', this._handleFallbackAutoScroll);
          } else {
            on(document, 'mousemove', this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop() {
        if (this.sortable.nativeDraggable) {
          off(document, 'dragover', this._handleAutoScroll);
        } else {
          off(document, 'pointermove', this._handleFallbackAutoScroll);
          off(document, 'touchmove', this._handleFallbackAutoScroll);
          off(document, 'mousemove', this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          elem = document.elementFromPoint(x, y);
        touchEvt$1 = evt;

        // IE does not seem to have native autoscroll,
        // Edge's autoscroll seems too conditional,
        // MACOS Safari does not have autoscroll,
        // Firefox and Chrome are good
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);

          // Listener for pointer element change
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            // Detect for pointer elem change, emulating native DnD behaviour
            pointerElemChangedInterval = setInterval(function () {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x;
            lastAutoScrollY = y;
          }
        } else {
          // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: 'scroll',
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function (autoScroll) {
      clearInterval(autoScroll.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
    // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
    if (!options.scroll) return;
    var x = (evt.touches ? evt.touches[0] : evt).clientX,
      y = (evt.touches ? evt.touches[0] : evt).clientY,
      sens = options.scrollSensitivity,
      speed = options.scrollSpeed,
      winScroller = getWindowScrollingElement();
    var scrollThisInstance = false,
      scrollCustomFn;

    // New scroll root, set scrollEl
    if (scrollRootEl !== rootEl) {
      scrollRootEl = rootEl;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent,
        rect = getRect(el),
        top = rect.top,
        bottom = rect.bottom,
        left = rect.left,
        right = rect.right,
        width = rect.width,
        height = rect.height,
        canScrollX = void 0,
        canScrollY = void 0,
        scrollWidth = el.scrollWidth,
        scrollHeight = el.scrollHeight,
        elCSS = css(el),
        scrollPosX = el.scrollLeft,
        scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
        canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
      }
      var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          /* jshint loopfunc:true */
          autoScrolls[layersOut].pid = setInterval(function () {
            // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === 'function') {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
  }, 30);

  var drop = function drop(_ref) {
    var originalEvent = _ref.originalEvent,
      putSortable = _ref.putSortable,
      dragEl = _ref.dragEl,
      activeSortable = _ref.activeSortable,
      dispatchSortableEvent = _ref.dispatchSortableEvent,
      hideGhostForTarget = _ref.hideGhostForTarget,
      unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent('spill');
      this.onSpill({
        dragEl: dragEl,
        putSortable: putSortable
      });
    }
  };
  function Revert() {}
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl = _ref3.dragEl,
        putSortable = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable) {
        putSortable.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl);
      }
      this.sortable.animateAll();
      if (putSortable) {
        putSortable.animateAll();
      }
    },
    drop: drop
  };
  _extends(Revert, {
    pluginName: 'revertOnSpill'
  });
  function Remove() {}
  Remove.prototype = {
    onSpill: function onSpill(_ref4) {
      var dragEl = _ref4.dragEl,
        putSortable = _ref4.putSortable;
      var parentSortable = putSortable || this.sortable;
      parentSortable.captureAnimationState();
      dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
      parentSortable.animateAll();
    },
    drop: drop
  };
  _extends(Remove, {
    pluginName: 'removeOnSpill'
  });

  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);

  var css_248z$1 = "body>*{position:relative;transform:translateZ(0)}.demo-tools-steps{background-color:#fff;border:2px solid #ddd;display:flex;flex-direction:column;font-weight:700;height:100%;min-width:200px;z-index:10001}.demo-tools-steps h2.demo-tools-steps-title{border-bottom:2px solid #eee;color:#333;font-weight:600;margin-top:0;padding-left:4px}.demo-tools-steps .demo-tools-step{border-left:4px solid #444;color:#444;cursor:pointer;padding:3px 12px}.demo-tools-steps .demo-tools-step.unfilled{font-style:italic}.demo-tools-steps .demo-tools-step.active{border-color:#52c41a;color:#52c41a}.demo-tools-steps .demo-tools-step.completed{border-color:#999;color:#999}@keyframes fade-out{0%{opacity:1;transform:translate(-50%,-50%) scale(1)}to{opacity:0;transform:translate(-50%,-50%) scale(2)}}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVybmFsL21vZHVsZXMvZGVtby10b29scy9zdGVwcy9zdGVwcy5sZXNzIiwic3RlcHMubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUNFLGlCQUFBLENBQ0EsdUJDQ0YsQ0RFQSxrQkFHRSxxQkFBQSxDQUNBLHFCQUFBLENBSEEsWUFBQSxDQUNBLHFCQUFBLENBR0EsZUFBQSxDQUNBLFdBQUEsQ0FDQSxlQUFBLENBQ0EsYUNBRixDREdBLDRDQUdFLDRCQUFBLENBREEsVUFBQSxDQURBLGVBQUEsQ0FJQSxZQUFBLENBREEsZ0JDQUYsQ0RJQSxtQ0FFRSwwQkFBQSxDQUNBLFVBQUEsQ0FDQSxjQUFBLENBSEEsZ0JDQ0YsQ0RJRSw0Q0FDRSxpQkNGSixDRE1BLDBDQUNFLG9CQUFBLENBQ0EsYUNKRixDRE9BLDZDQUNFLGlCQUFBLENBQ0EsVUNMRixDRFFBLG9CQUNFLEdBQ0UsU0FBQSxDQUNBLHVDQ05GLENEUUEsR0FDRSxTQUFBLENBQ0EsdUNDTkYsQ0FDRiIsImZpbGUiOiJzdGVwcy5sZXNzIn0= */";
  styleInject(css_248z$1);

  class PlanStepForm {
      static getForm() {
          PlanStepForm.wrapper.style.display = 'flex';
          PlanStepForm.wrapper.style.gap = '5px';
          PlanStepForm.wrapper.style.padding = '5px';
          PlanStepForm.button.innerText = 'Add';
          PlanStepForm.button.addEventListener('click', PlanStepForm.handleAddClick);
          PlanStepForm.field.addEventListener('keypress', PlanStepForm.handleKeypress);
          PlanStepForm.wrapper.appendChild(PlanStepForm.field);
          PlanStepForm.wrapper.appendChild(PlanStepForm.button);
          return PlanStepForm.wrapper;
      }
      static planStep() {
          window.dispatchEvent(new CustomEvent(PlanStepForm.eventTypes.PLAN_STEP, { detail: { title: PlanStepForm.field.value } }));
          PlanStepForm.field.value = '';
      }
      static handleAddClick(event) {
          PlanStepForm.planStep();
      }
      static handleKeypress(event) {
          if (event.key !== 'Enter')
              return;
          PlanStepForm.planStep();
      }
  }
  PlanStepForm.wrapper = document.createElement('div');
  PlanStepForm.field = document.createElement('input');
  PlanStepForm.button = document.createElement('button');
  PlanStepForm.eventTypes = {
      PLAN_STEP: 'DemoTools:Steps:PlanStepForm:PlanStep',
  };

  class Steps {
      static init() {
          Steps.state.initialized = true;
          window.addEventListener('DemoTools:StepsChanged', Steps.handleDemoToolsStepsChanged);
          window.addEventListener('DemoTools:ActiveStepChanged', Steps.handleDemoToolsActiveStepChanged);
          Steps.renderSteps();
      }
      static handleDemoToolsStepsChanged({ detail: { steps } }) {
          Steps.steps = steps;
          Steps.renderSteps();
      }
      static handleDemoToolsActiveStepChanged({ detail: { activeStep } }) {
          Steps.setActiveStep(activeStep);
      }
      static handleStepDoubleClick(index) {
          window.dispatchEvent(new CustomEvent(Steps.eventTypes.STEP_DOUBLECLICK, { detail: { index } }));
      }
      static handleStepClick(index) {
          window.dispatchEvent(new CustomEvent(Steps.eventTypes.STEP_CLICK, { detail: { index } }));
      }
      static add(step) {
          Steps.steps.push(step);
      }
      static renderSteps() {
          Steps.unmount();
          if (!Steps.state.initialized || !Steps.steps) {
              throw new Error('DemoTools: Steps are not initialized');
          }
          const area = document.createElement('div');
          area.setAttribute('class', 'demo-tools demo-tools-steps');
          const title = document.createElement('h2');
          title.innerHTML = 'Demo steps';
          title.setAttribute('class', 'demo-tools-steps-title');
          const list = document.createElement('div');
          list.setAttribute('style', 'overflow-y: auto; padding-left: 1px; display: flex; flex-direction: column; gap: 3px;');
          list.setAttribute('class', 'demo-tools-steps-list');
          Steps.steps.forEach(step => {
              const div = document.createElement('div');
              if (!step.list) {
                  div.setAttribute('style', 'display: none;');
              }
              div.setAttribute('class', 'demo-tools-step');
              if (!step.isFilled) {
                  div.classList.add('unfilled');
              }
              div.innerHTML = step.title;
              list.appendChild(div);
          });
          area.appendChild(title);
          area.appendChild(PlanStepForm.getForm());
          area.appendChild(list);
          document.body.style.display = 'flex';
          document.body.appendChild(area);
          Steps.setupInteractivity();
      }
      static setActiveStep(index) {
          if (!isNil(index) && !Steps.steps[index].list) {
              return;
          }
          const stepEls = document.querySelectorAll('.demo-tools-steps-list .demo-tools-step');
          for (let i = 0; i < stepEls.length; i++) {
              if (!Steps.steps[i].list) {
                  continue;
              }
              stepEls[i].classList.remove('completed');
              stepEls[i].classList.remove('active');
          }
          if (isNil(index)) {
              return;
          }
          for (let i = 0; i < index; i++) {
              if (!Steps.steps[i].list) {
                  continue;
              }
              stepEls[i].classList.add('completed');
              stepEls[i].classList.remove('active');
          }
          stepEls[index].classList.add('active');
          stepEls[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      static allocate(width) {
          const area = document.createElement('div');
          area.setAttribute('class', 'demo-tools-steps');
          if (width) {
              area.setAttribute('style', `width: ${width}px;`);
          }
          document.body.style.display = 'flex';
          document.body.appendChild(area);
      }
      static clear() {
          document.body.querySelectorAll('.demo-tools-steps').forEach((el) => {
              var _a;
              el.setAttribute('style', `width: ${el.clientWidth}px; min-width: ${el.clientWidth}px;`);
              (_a = el.querySelector('.demo-tools-steps-list')) === null || _a === void 0 ? void 0 : _a.remove();
          });
      }
      static unmount() {
          document.body.querySelectorAll('.demo-tools-steps').forEach(el => el.remove());
          document.body.style.display = 'block';
      }
      static destroy() {
          Steps.unmount();
          window.removeEventListener('DemoTools:StepsChanged', Steps.handleDemoToolsStepsChanged);
      }
      static setupInteractivity() {
          Sortable.create(document.querySelector('.demo-tools-steps-list'), {
              onEnd: (evt) => {
                  window.dispatchEvent(new CustomEvent(Steps.eventTypes.STEP_MOVE, { detail: { from: evt.oldIndex, to: evt.newIndex } }));
              }
          });
          document.querySelectorAll('.demo-tools-steps-list .demo-tools-step').forEach((el, index) => {
              el.addEventListener('dblclick', () => {
                  Steps.handleStepDoubleClick(index);
              });
          });
          document.querySelectorAll('.demo-tools-steps-list .demo-tools-step').forEach((el, index) => {
              el.addEventListener('click', () => {
                  Steps.handleStepClick(index);
              });
          });
      }
  }
  Steps.steps = [];
  Steps.state = {
      initialized: false,
  };
  Steps.eventTypes = {
      STEP_DOUBLECLICK: 'DemoTools:Steps:StepDoubleclick',
      STEP_MOVE: 'DemoTools:Steps:StepMove',
      STEP_CLICK: 'DemoTools:Steps:StepClick',
  };

  var css_248z = "#demo-tools-step-picker-form{display:grid;gap:5px;grid-template-columns:auto 1fr}#demo-tools-step-picker-form #demo-tools-step-picker-form-highlight-fields{display:grid;grid-column:.33333333;grid-template-columns:auto 1fr}\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImV4dGVybmFsL21vZHVsZXMvZGVtby10b29scy9zdHlsZS5sZXNzIiwic3R5bGUubGVzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2QkFDRSxZQUFBLENBRUEsT0FBQSxDQURBLDhCQ0VGLENESkEsMkVBT0ksWUFBQSxDQURBLHFCQUFBLENBRUEsOEJDQ0oiLCJmaWxlIjoic3R5bGUubGVzcyJ9 */";
  styleInject(css_248z);

  class StepForm {
      static init() {
          StepForm.driver = Ae();
      }
      static getFormValues() {
          return {
              title: document.getElementById('demo-tools-step-picker-form-title').value,
              type: document.getElementById('demo-tools-step-picker-form-type').value,
              shiftX: +document.getElementById('demo-tools-step-picker-form-shiftX').value,
              shiftY: +document.getElementById('demo-tools-step-picker-form-shiftY').value,
              shiftWidth: +document.getElementById('demo-tools-step-picker-form-shiftWidth').value,
              shiftHeight: +document.getElementById('demo-tools-step-picker-form-shiftHeight').value,
              interval: +document.getElementById('demo-tools-step-picker-form-interval').value,
              list: document.getElementById('demo-tools-step-picker-form-list').checked,
          };
      }
      static getPrompt(arg) {
          return __awaiter(this, void 0, void 0, function* () {
              if (isNil(StepForm.driver)) {
                  throw new Error('DevTools: StepPicker is not initialized');
              }
              let xPath;
              let formValues;
              if (isNil(arg)) {
                  throw new Error('DevTools: Step not passed');
              }
              if (is(String, arg)) {
                  xPath = arg;
              }
              else {
                  xPath = arg.xPath;
                  formValues = arg;
              }
              return yield new Promise((resolve) => {
                  StepForm.driver.highlight({
                      element: getElementByXPath(xPath),
                      popover: {
                          description: StepForm.getForm(formValues),
                          showButtons: ['next', 'close'],
                          nextBtnText: 'Done',
                          onPopoverRender: (popoverDom) => {
                              var _a, _b;
                              const handleKeydown = (e) => {
                                  if (e.key === 'Enter') {
                                      resolve(Object.assign(Object.assign({}, StepForm.getFormValues()), { xPath }));
                                      StepForm.driver.destroy();
                                  }
                              };
                              (_a = popoverDom.wrapper) === null || _a === void 0 ? void 0 : _a.removeEventListener('keydown', handleKeydown);
                              (_b = popoverDom.wrapper) === null || _b === void 0 ? void 0 : _b.addEventListener('keydown', handleKeydown);
                          },
                          onNextClick: () => {
                              resolve(Object.assign(Object.assign({}, StepForm.getFormValues()), { xPath }));
                              StepForm.driver.destroy();
                          },
                          onCloseClick: () => {
                              resolve(undefined);
                              StepForm.driver.destroy();
                          },
                      },
                  });
              });
          });
      }
      static getForm(values) {
          return `
      <div class="demo-tools" id="demo-tools-step-picker-form">
        <div class="demo-tools-step-picker-form-label">Title:</div>
        <div class="demo-tools-step-picker-form-control"><input type="text" id="demo-tools-step-picker-form-title" autofocus value="${(values === null || values === void 0 ? void 0 : values.title) || ''}" /></div>
        <div class="demo-tools-step-picker-form-label">Interval:</div>
        <div class="demo-tools-step-picker-form-control"><input type="number" id="demo-tools-step-picker-form-interval" value="${(values === null || values === void 0 ? void 0 : values.interval) || DemoTools.defaultInterval}" step="100" />&nbsp;ms</div>
        <div class="demo-tools-step-picker-form-label">Listed:</div>
        <div class="demo-tools-step-picker-form-control"><input type="checkbox" id="demo-tools-step-picker-form-list" checked="${is(Boolean, values === null || values === void 0 ? void 0 : values.list) ? values.list.toString() : 'true'}" /></div>
        <div class="demo-tools-step-picker-form-label">Type:</div>
        <div class="demo-tools-step-picker-form-control">
          <select id="demo-tools-step-picker-form-type" onchange="window.devTools?.demoToolsStepPicker.onStepTypeChange()">
            <option value="highlight" ${(values === null || values === void 0 ? void 0 : values.type) === 'highlight' || isNil(values === null || values === void 0 ? void 0 : values.type) ? 'selected' : ''}>Highlight</option>
            <option value="click" ${(values === null || values === void 0 ? void 0 : values.type) === 'click' ? 'selected' : ''}>Click</option>
            <option value="rightclick" ${(values === null || values === void 0 ? void 0 : values.type) === 'rightclick' ? 'selected' : ''}>Right Click</option>
            <option value="hover" ${(values === null || values === void 0 ? void 0 : values.type) === 'hover' ? 'selected' : ''}>Hover</option>
          </select>
        </div>
        <div id="demo-tools-step-picker-form-highlight-fields" style="grid-column: 1/3; display: ${(values === null || values === void 0 ? void 0 : values.type) === 'highlight' || isNil(values === null || values === void 0 ? void 0 : values.type) ? 'grid' : 'none'};">
          <div class="demo-tools-step-picker-form-label">Shift X:</div>
          <div class="demo-tools-step-picker-form-control"><input type="number" id="demo-tools-step-picker-form-shiftX" step="10" value="${values === null || values === void 0 ? void 0 : values.shiftX}" /></div>
          <div class="demo-tools-step-picker-form-label">Shift Y:</div>
          <div class="demo-tools-step-picker-form-control"><input type="number" id="demo-tools-step-picker-form-shiftY" step="10" value="${values === null || values === void 0 ? void 0 : values.shiftY}" /></div>
          <div class="demo-tools-step-picker-form-label">Shift Width:</div>
          <div class="demo-tools-step-picker-form-control"><input type="number" id="demo-tools-step-picker-form-shiftWidth" step="10" value="${values === null || values === void 0 ? void 0 : values.shiftWidth}" /></div>
          <div class="demo-tools-step-picker-form-label">Shift Height:</div>
          <div class="demo-tools-step-picker-form-control"><input type="number" id="demo-tools-step-picker-form-shiftHeight" step="10" value="${values === null || values === void 0 ? void 0 : values.shiftHeight}" /></div>
        </div>
      </div>
    `;
      }
  }
  setTimeout(() => {
      window.devTools.demoToolsStepPicker = {};
      window.devTools.demoToolsStepPicker.onStepTypeChange = () => {
          document.getElementById('demo-tools-step-picker-form-highlight-fields').style.display = document.getElementById('demo-tools-step-picker-form-type').value === 'highlight' ? 'grid' : 'none';
      };
  });

  class Step {
      constructor(step) {
          this.title = String(step.title);
          this.interval = Number(step.interval);
          this.type = step.type || 'custom';
          this.list = Boolean(step.list);
          this.selector = step.selector;
          this.func = step.func;
          this.element = step.element;
          this.xPath = step.xPath;
          this.area = step.area;
          this.shiftX = step.shiftX;
          this.shiftY = step.shiftY;
          this.shiftWidth = step.shiftWidth;
          this.shiftHeight = step.shiftHeight;
      }
      get isFilled() {
          return Boolean((this.element || this.xPath || this.selector || this.func || this.area) && this.title && this.interval);
      }
  }

  class Dom {
      static getElement(arg) {
          if (is(String, arg)) {
              return document.querySelector(arg);
          }
          else if (is(HTMLElement, arg)) {
              return arg;
          }
          else if (!isNil(arg.element)) {
              return arg.element;
          }
          else if (!isNil(arg.xPath)) {
              return getElementByXPath(arg.xPath);
          }
          else {
              return document.querySelector(arg.selector);
          }
      }
      static click(arg) {
          try {
              const element = Dom.getElement(arg);
              if (!element) {
                  return;
              }
              element.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
              Dom.blink(element.getBoundingClientRect().x + element.getBoundingClientRect().width / 2, element.getBoundingClientRect().y + element.getBoundingClientRect().height / 2);
          }
          catch (e) { }
      }
      static rightClick(arg) {
          try {
              const element = Dom.getElement(arg);
              if (!element) {
                  return;
              }
              element.dispatchEvent(new MouseEvent('rightclick', { bubbles: true, cancelable: true }));
              element.dispatchEvent(new MouseEvent('contextmenu', { bubbles: true, cancelable: true }));
              Dom.blink(element.getBoundingClientRect().x + element.getBoundingClientRect().width / 2, element.getBoundingClientRect().y + element.getBoundingClientRect().height / 2, { color: 'green' });
          }
          catch (e) { }
      }
      static hover(arg) {
          try {
              const element = Dom.getElement(arg);
              if (!element) {
                  return;
              }
              element.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, cancelable: true }));
          }
          catch (e) { }
      }
      static focus(selector) {
          try {
              const element = document.querySelector(selector);
              if (!element) {
                  return;
              }
              element.dispatchEvent(new FocusEvent('focus', { bubbles: true, cancelable: true }));
          }
          catch (e) { }
      }
      static setValue(selector, value) {
          try {
              const element = document.querySelector(selector);
              if (!element) {
                  return;
              }
              element.setAttribute('value', value);
              element.value = value;
              element.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
              element.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
          }
          catch (e) { }
      }
      static blink(x, y, options = {}) {
          const { size = 40, color = 'yellow', border = '2px solid yellow', duration = 400, } = options;
          const circle = document.createElement('div');
          circle.style.position = 'absolute';
          circle.style.left = `${x - size / 2}px`;
          circle.style.top = `${y - size / 2}px`;
          circle.style.width = `${size}px`;
          circle.style.height = `${size}px`;
          circle.style.borderRadius = '50%';
          circle.style.backgroundColor = color;
          circle.style.border = border;
          circle.style.pointerEvents = 'none';
          circle.style.zIndex = '999999999';
          circle.style.boxShadow = `0 0 10px ${color}`;
          circle.style.transition = `transform ${duration}ms ease-in-out, opacity ${duration}ms ease-in-out`;
          circle.style.transform = 'scale(0.2)';
          circle.style.opacity = '1';
          document.body.appendChild(circle);
          circle.getBoundingClientRect();
          circle.style.transform = 'scale(1)';
          circle.style.opacity = '0';
          setTimeout(() => {
              circle.remove();
          }, duration);
      }
  }

  class DemoTools {
      static addStep(step = {}) {
          DemoTools.insertStep(step, DemoTools.steps.length);
      }
      static addHighlightStep(step = {}) {
          DemoTools.addStep(Object.assign(Object.assign({}, step), { title: step.title || `Step ${DemoTools.steps.length}`, type: 'highlight' }));
          DemoTools.dispatchStepsChangedEvent();
      }
      static pickStep() {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
              const hoveredEls = document.querySelectorAll(':hover');
              if (isNil(hoveredEls) || isEmpty(hoveredEls)) {
                  return;
              }
              let xPath = '';
              hoveredEls.forEach((el, i) => {
                  let index = 0;
                  if (el.parentElement) {
                      index = Array.from(el.parentElement.children).indexOf(el);
                  }
                  xPath += `/*[${index + 1}]`;
              });
              if (isEmpty(xPath)) {
                  return;
              }
              let step;
              if (DemoTools.state.activeStep !== null) {
                  step = yield DemoTools.stepForm.getPrompt({
                      title: DemoTools.steps[DemoTools.state.activeStep].title,
                      xPath
                  });
              }
              else {
                  step = yield DemoTools.stepForm.getPrompt(xPath);
              }
              if (!step) {
                  return;
              }
              if (DemoTools.state.activeStep !== null) {
                  yield DemoTools.updateStep(DemoTools.state.activeStep, step);
                  if (((_a = DemoTools.steps[DemoTools.state.activeStep + 1]) === null || _a === void 0 ? void 0 : _a.isFilled) === false) {
                      DemoTools.state.activeStep = DemoTools.state.activeStep + 1;
                      DemoTools.dispatchActiveStepChangedEvent();
                  }
                  return;
              }
              else {
                  DemoTools.addStep(step);
                  DemoTools.dispatchStepsChangedEvent();
              }
          });
      }
      static setSteps(steps) {
          if (isNil(steps) || isEmpty(steps)) {
              return;
          }
          DemoTools.stop();
          values(steps).forEach((step) => DemoTools.insertStep(step));
      }
      static insertStep(step = {}, index) {
          const adjustedStep = new Step(Object.assign(Object.assign({}, step), { title: step.title || `Custom step ${index}`, type: step.type || 'click', list: typeof step.list === 'boolean' ? step.list : true }));
          const index1 = !isNil(index) ? Number(index) : DemoTools.state.activeStep !== null ? DemoTools.state.activeStep + 1 : DemoTools.steps.length;
          DemoTools.steps = insert(index1, adjustedStep, DemoTools.steps);
          DemoTools.state.lastUpdatedStep = index1;
          DemoTools.dispatchStepsChangedEvent();
      }
      static updateStep(title, step) {
          return __awaiter(this, void 0, void 0, function* () {
              if (!DemoTools.state.initialized) {
                  throw new Error('DevTools: DemoTools is not initialized');
              }
              if (DemoTools.state.running) {
                  DemoTools.pause();
              }
              let index;
              if (!isNil(title)) {
                  if (isNaN(Number(title))) {
                      index = findIndex((step) => step.title.toLowerCase().includes(title.toLowerCase()), DemoTools.steps);
                  }
                  else {
                      index = title;
                  }
                  if (index === -1) {
                      return;
                  }
              }
              else {
                  index = Number(isNil(DemoTools.state.activeStep) ? DemoTools.state.lastUpdatedStep : DemoTools.state.activeStep || 0);
              }
              const updatedStep = step || (yield DemoTools.stepForm.getPrompt(DemoTools.steps[index]));
              DemoTools.state.lastUpdatedStep = index;
              DemoTools.steps[index] = new Step(Object.assign(Object.assign({}, DemoTools.steps[index]), updatedStep));
              DemoTools.dispatchStepsChangedEvent();
          });
      }
      static removeStep(title) {
          let index;
          if (isNaN(Number(title))) {
              index = findIndex((step) => step.title.toLowerCase().includes(title.toLowerCase()), DemoTools.steps);
          }
          else {
              index = title;
          }
          if (index === -1) {
              return;
          }
          DemoTools.steps = remove(index, 1, DemoTools.steps);
          if (DemoTools.state.activeStep === index) {
              DemoTools.state.activeStep = null;
              DemoTools.dispatchActiveStepChangedEvent();
          }
          DemoTools.dispatchStepsChangedEvent();
      }
      static removeAllSteps() {
          DemoTools.steps = [];
          DemoTools.dispatchStepsChangedEvent();
      }
      static doStep(title) {
          if (!DemoTools.state.initialized) {
              throw new Error('DevTools: DemoTools is not initialized');
          }
          DemoTools.state.lastUpdatedStep = null;
          let index;
          if (isNaN(Number(title))) {
              index = findIndex((step) => step.title.toLowerCase().includes(title.toLowerCase()), DemoTools.steps);
          }
          else {
              index = title;
          }
          if (index === -1 || index >= DemoTools.steps.length) {
              return;
          }
          DemoTools.state.activeStep = index;
          DemoTools.dispatchActiveStepChangedEvent();
          if (DemoTools.steps[index].type === 'highlight') {
              DemoTools.highlight(index);
          }
          else if (DemoTools.steps[index].type === 'click') {
              Dom.click(DemoTools.steps[index]);
          }
          else if (DemoTools.steps[index].type === 'rightclick') {
              Dom.rightClick(DemoTools.steps[index]);
          }
          else if (DemoTools.steps[index].type === 'hover') {
              Dom.hover(DemoTools.steps[index]);
          }
          else {
              DemoTools.steps[index].func();
          }
      }
      static run(options = {}) {
          return __awaiter(this, void 0, void 0, function* () {
              DemoTools.options = Object.assign(Object.assign({}, DemoTools.options), options);
              DemoTools.state.running = true;
              for (let i = (options === null || options === void 0 ? void 0 : options.stepIndex) || DemoTools.state.activeStep || 0; i < DemoTools.steps.length; i++) {
                  if (!DemoTools.state.running) {
                      break;
                  }
                  DemoTools.doStep(i);
                  const step = DemoTools.steps[i];
                  yield new Promise(resolve => setTimeout(resolve, step.interval || DemoTools.defaultInterval));
                  if (step.type === 'highlight') {
                      DemoTools.unhighlight();
                  }
              }
              if (DemoTools.state.activeStep === DemoTools.steps.length - 1) {
                  DemoTools.state.running = false;
                  DemoTools.state.activeStep = null;
                  DemoTools.dispatchActiveStepChangedEvent();
              }
          });
      }
      static jump(index) {
          DemoTools.pause();
          DemoTools.state.activeStep = Number(index);
          DemoTools.doStep(DemoTools.state.activeStep);
      }
      static swap(index1, index2) {
          const tmp = DemoTools.steps[Number(index1)];
          DemoTools.steps[Number(index1)] = DemoTools.steps[Number(index2)];
          DemoTools.steps[Number(index2)] = tmp;
          DemoTools.dispatchStepsChangedEvent();
          if (index1 === DemoTools.state.activeStep || index2 === DemoTools.state.activeStep) {
              DemoTools.dispatchActiveStepChangedEvent();
          }
      }
      static move(index1, index2) {
          const index = !isNil(index2) ? index1 : DemoTools.state.activeStep;
          const tmp = DemoTools.steps[index];
          DemoTools.steps.splice(index, 1);
          DemoTools.steps.splice(!isNil(index2) ? index2 : index1, 0, tmp);
          DemoTools.dispatchStepsChangedEvent();
      }
      static copy(index1, index2) {
          const index = !isNil(index1) ? index1 : DemoTools.state.activeStep;
          DemoTools.insertStep(DemoTools.steps[index], !isNil(index2) ? index2 : index1 + 1);
      }
      static stop() {
          DemoTools.state.running = false;
          DemoTools.state.activeStep = null;
          DemoTools.state.lastUpdatedStep = null;
          DemoTools.unhighlight();
          DemoTools.dispatchActiveStepChangedEvent();
      }
      static pause() {
          DemoTools.state.running = false;
      }
      static resume() {
          DemoTools.run();
      }
      static reset() {
          DemoTools.pause();
          DemoTools.state.activeStep = null;
          DemoTools.state.lastUpdatedStep = null;
          DemoTools.unhighlight();
          Steps.unmount();
          DemoTools.dispatchActiveStepChangedEvent();
      }
      static destroy() {
          DemoTools.stop();
          DemoTools.removeAllSteps();
          DemoTools.state.initialized = false;
          Steps.destroy();
          window.removeEventListener('keydown', DemoTools.handleKeydown);
          DemoTools.options = {};
      }
      static highlight(stepIndex) {
          if (isNil(DemoTools.steps[stepIndex])) {
              return;
          }
          const { title, selector, xPath, area, shiftX, shiftY, shiftHeight, shiftWidth } = DemoTools.steps[stepIndex];
          let areaNew = undefined;
          if (isNil(area)) {
              let tmpElement;
              if (is(String, xPath)) {
                  tmpElement = getElementByXPath(xPath);
              }
              else if (is(String, selector)) {
                  tmpElement = document.querySelector(selector);
              }
              else {
                  tmpElement = selector;
              }
              if (!tmpElement) {
                  return;
              }
              const rect = tmpElement.getBoundingClientRect();
              areaNew = {
                  left: rect.left + (shiftX || 0) + window.scrollX,
                  top: rect.top + (shiftY || 0) + window.scrollY,
                  width: rect.width + (shiftWidth || 0),
                  height: rect.height + (shiftHeight || 0),
              };
          }
          const element = DemoTools.appendHighlightArea(area || areaNew);
          if (!element) {
              return;
          }
          DemoTools.driver = DemoTools.Driver(Object.assign(Object.assign({}, DemoTools.defaultDriverOptions), { steps: [{
                      element,
                      popover: {
                          description: title,
                      }
                  }] }));
          DemoTools.driver.drive();
      }
      static unhighlight() {
          if (DemoTools.driver) {
              DemoTools.driver.destroy();
          }
          const highlightArea = document.querySelector('#demo-tools-highlight-area');
          if (highlightArea) {
              highlightArea.remove();
          }
      }
      static appendHighlightArea(area) {
          const { left, top, width, height } = area;
          const style = `position: absolute; left: ${left}px; top: ${top}px; width: ${width}px; height: ${height}px;`;
          const div = document.createElement('div');
          div.setAttribute('style', style);
          div.setAttribute('id', 'demo-tools-highlight-area');
          document.body.appendChild(div);
          return div;
      }
      static check(selector) {
          var _a, _b, _c;
          (_a = document.querySelectorAll('#demo-tools-highlight-area')) === null || _a === void 0 ? void 0 : _a.forEach(el => { el.remove(); });
          let element;
          if (is(String, selector)) {
              element = document.querySelector(selector);
          }
          else {
              element = this.appendHighlightArea(selector);
          }
          if (!element) {
              return;
          }
          DemoTools.driver = DemoTools.Driver(Object.assign(Object.assign({}, DemoTools.defaultDriverOptions), { onDestroyed: () => { var _a; return (_a = document.querySelectorAll('#demo-tools-highlight-area')) === null || _a === void 0 ? void 0 : _a.forEach(el => { el.remove(); }); } }));
          DemoTools.driver.highlight({
              element,
              popover: {
                  description: is(String, selector) ?
                      `Element: ${element.nodeName.toLowerCase()}${selector}<br />parent element: ${(_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName.toLowerCase()}.${Array.from((_c = element.parentElement) === null || _c === void 0 ? void 0 : _c.classList).join('.')}` :
                      'Appended area',
              }
          });
      }
      static printSteps() {
          console.table(DemoTools.steps.map((step) => ({ title: step.title, type: step.type })));
      }
      static init(options = {}) {
          DemoTools.stop();
          if (DemoTools.state.initialized) {
              return;
          }
          DemoTools.options.renderSteps = Boolean(options.renderSteps);
          DemoTools.options.renderStepsStyle = options.renderStepsStyle;
          DemoTools.state.initialized = true;
          window.addEventListener('keydown', DemoTools.handleKeydown);
          DemoTools.stepForm.init();
          if (options.renderSteps) {
              DemoTools.stepList.init();
              window.addEventListener(DemoTools.stepList.eventTypes.STEP_MOVE, DemoTools.handleStepMoved);
              window.addEventListener(DemoTools.stepList.eventTypes.STEP_DOUBLECLICK, DemoTools.handleStepDoubleclick);
              window.addEventListener(DemoTools.stepList.eventTypes.STEP_CLICK, DemoTools.handleStepClick);
              window.addEventListener(PlanStepForm.eventTypes.PLAN_STEP, DemoTools.handlePlanStep);
          }
      }
      static handleKeydown(e) {
          if (e.key === 'Escape') {
              DemoTools.pause();
          }
          else if (e.ctrlKey && e.altKey) {
              if (e.key === 'p') {
                  if (DemoTools.state.running) {
                      DemoTools.pause();
                      return;
                  }
                  DemoTools.pickStep();
              }
              else if (e.key === 'r') {
                  DemoTools.run();
              }
              else if (e.key === 's') {
                  DemoTools.stop();
              }
              else if (e.key === 'ArrowRight') {
                  DemoTools.jump(DemoTools.state.activeStep + 1);
              }
              else if (e.key === 'ArrowLeft') {
                  DemoTools.jump(DemoTools.state.activeStep - 1);
              }
              else if (e.key === 'ArrowUp') {
                  DemoTools.swap(DemoTools.state.activeStep, DemoTools.state.activeStep - 1);
              }
              else if (e.key === 'ArrowDown') {
                  DemoTools.swap(DemoTools.state.activeStep, DemoTools.state.activeStep + 1);
              }
              else if (e.key === 'u') {
                  DemoTools.updateStep();
              }
              else if (e.key === 'd') {
                  DemoTools.removeStep(DemoTools.state.activeStep);
              }
          }
      }
      static handleStepMoved(e) {
          if (DemoTools.options.renderSteps) {
              DemoTools.move(e.detail.from, e.detail.to);
          }
      }
      static handleStepDoubleclick(e) {
          if (DemoTools.options.renderSteps) {
              DemoTools.jump(e.detail.index);
          }
      }
      static handleStepClick(e) {
          if (DemoTools.options.renderSteps) {
              DemoTools.state.activeStep = e.detail.index;
              DemoTools.dispatchActiveStepChangedEvent();
          }
      }
      static handlePlanStep(e) {
          if (DemoTools.options.renderSteps) {
              DemoTools.addStep(e.detail);
          }
      }
      static dispatchStepsChangedEvent() {
          window.dispatchEvent(new CustomEvent('DemoTools:StepsChanged', { detail: { steps: DemoTools.steps } }));
      }
      static dispatchActiveStepChangedEvent() {
          window.dispatchEvent(new CustomEvent('DemoTools:ActiveStepChanged', { detail: { activeStep: DemoTools.state.activeStep } }));
      }
  }
  DemoTools.defaultInterval = 2000;
  DemoTools.steps = [];
  DemoTools.Driver = Ae;
  DemoTools.stepList = Steps;
  DemoTools.stepForm = StepForm;
  DemoTools.dom = Dom;
  DemoTools.options = {};
  DemoTools.state = {
      running: false,
      activeStep: null,
      initialized: false,
      lastUpdatedStep: null,
  };
  DemoTools.defaultDriverOptions = {
      showButtons: ['close'],
      overlayOpacity: 0.3,
  };

  var index = () => console.log('dev tools');
  Error.stackTradeLimit = Infinity;
  if (window) {
      window.devTools = {};
      window.devTools.extensions = {};
      window.r = ramda;
      window.numeral = numeral;
      window.decimal = Decimal;
      window.d = datefns;
      window.setVar = setVar$1;
      window.deleteVar = deleteVar;
      window.clearVars = clearVars;
      window.stub = stub;
      window.logger = new Logger();
      window.csvParser = new JSON2CSVParser({ delimiter: '\t' });
      window.Diagnostics = Diagnostics;
      window.setOnLoad = setOnLoad;
      window.storage = storage;
      window.__ = _$1;
      window.demo = DemoTools;
      const persistent_vars = getVars();
      for (let variable of persistent_vars) {
          window[variable.name] = variable.value;
      }
      if (window === null || window === void 0 ? void 0 : window.onLoad) {
          try {
              eval(window === null || window === void 0 ? void 0 : window.onLoad)();
          }
          catch (e) { }
      }
  }

  return index;

})();
//# sourceMappingURL=dev-tools.js.map
